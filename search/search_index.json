{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"Hi, My name is V\u0169 Quang Tr\u1ecdng, Code Inside Out is my personal blog in which I take notes about what I've learned, and what I'm interested in. I am working in Embedded Automotive field, mainly focusing on In Vehicle Infortainment (IVI) and Advanced Driver-Assistance Systems (ADAS). I also do some personal projects for my sweet home, and some others as my freelance jobs. I cannot remember all of them in details, so I need somewhere to write down, I also need them searchable to quicky jump to what I want. That's the reason for me to start blogging. Hope you can find something helpful here too. Let's code ^^ .md-typeset p { text-align: justify; }","title":"About"},{"location":"projects/","text":"I have published some of my projects on vuquangtrong , if you are interested, feel free to ask me for more details. Here are some featured ones: Blogging with Material for MkDocs is the theme I am using for this blog, which has some modification to support blogging like homepage, list of posts, and tags. Simplify Theme for Pelican static site generator. It was used for this blog once. VAcamera make use of Accord framework and FFMPEG engine to record video streams from 2 cameras and write output to mp4 files. Tiva C TM4C123G LaunchPad practice on ARM Cortext-M4F , contain Bring Up, Sensors, LCD, BootLoader and Firmware Update labs. SMS WebHub use a mobile phone to process commands from a VPS via websocket , include sending SMS, checking Balance, calling a number, forwarding messages Other Proof of Concept projects has prototypes for freelance projects I have done, as their source code are not allowed to be published","title":"Projects"},{"location":"tags/","text":"","title":"Tags"},{"location":"posts/","text":"","title":"Featured posts"},{"location":"posts/markdown_syntax/","text":"Markdown Syntax \u2693\ufe0e Metadata \u2693\ufe0e In a markdown file, if you add metadata in YAML format at the begining of the file, it will be used to create page.meta object. Metadata is not shown in the page content, but it is used in rendering template to HTML. It is recommended to have at least 3 fields title , description , and tags , in each post. --- title : Lorem ipsum dolor sit amet description : Nullam urna elit, malesuada eget finibus ut, ac tortor. tags : - tag1 - tag2 --- Headings \u2693\ufe0e To create a heading, add number signs ( # ) in front of a word or phrase. The number of number signs you use should correspond to the heading level. For example, to create a heading level three ( <h3> ), use three number signs ( ### My Header level 3 ). Please remember to always put a space between the number signs and the heading name. Paragraphs \u2693\ufe0e Writing a paragraph is very straight forward. You just write down your sentences and they will be wrapped in <p> tags. To create paragraphs, use a blank line to separate one or more lines of text. To create a line break ( <br> ), end a line with two or more spaces, and then type return. You can add emphasis by making text bold or italic : To bold text, add two asterisks or underscores before and after a word or phrase To italicize text, add one asterisk or underscore before and after a word or phrase. To create a blockquote, add a > in front of a paragraph. Here is an example: Markdown: Paragraphs are the **building blocks** of papers. Many students define paragraphs in _terms of length_ : a paragraph is a group of at least five sentences, a paragraph is half a page long, etc. In reality, though, the __unity and coherence of ideas__ among sentences is what constitutes a paragraph. > excerpt from: _https://writingcenter.unc.edu/tips-and-tools/paragraphs_ Rendered: Paragraphs are the building blocks of papers. Many students define paragraphs in terms of length : a paragraph is a group of at least five sentences, a paragraph is half a page long, etc. In reality, though, the unity and coherence of ideas among sentences is what constitutes a paragraph. excerpt from: https://writingcenter.unc.edu/tips-and-tools/paragraphs Marks \u2693\ufe0e Beside standard marks to emphasize text as bold or italic , extended markdown supports some extra ways as below: Markdown: * ==This was marked== * ^^This was inserted^^ * ~~This was deleted~~ * H~2~0 * A^T^A Rendered: This was marked This was inserted This was deleted H 2 0 A T A List \u2693\ufe0e You can organize items into ordered and unordered lists. To create an ordered list, add line items with numbers followed by periods. The numbers don\u2019t have to be in numerical order, but the list should start with the number one. To create an unordered list, add dashes ( - ), asterisks ( * ), or plus signs ( + ) in front of line items. Indent one or more items to create a nested list. To create Task List, use checked box ( [ ] or [x] ) to show completed or uncompleted tasks. Markdown: 1. First item - Sub 1.1 - Sub 1.2 2. Second item * Sub 2.1 * Sub 2.2 3. Third item + Sub 3.1 + Sub 3.2 4. Fourth item 1. Sub 4.1 2. Sub 4.2 5. Task list * [x] Done * [ ] Not done yet Rendered: First item Sub 1.1 Sub 1.2 Second item Sub 2.1 Sub 2.2 Third item Sub 3.1 Sub 3.2 Fourth item Sub 4.1 Sub 4.2 Task list Done Not done yet Links \u2693\ufe0e To create a link, enclose the link text in brackets (e.g., [Google] ) and then follow it immediately with the URL in parentheses (e.g., (https://google.com) ). To quickly turn a URL or email address into a link, enclose it in angle brackets ( <> ). Markdown: [ Google ]( https://google.com ). <https://codeinsideout.com> <vuquangtrong@gmail.com> Rendered: Google https://codeinsideout.com vuquangtrong@gmail.com Reference-style links are a special kind of link that make URLs easier to display and read in Markdown. Reference-style links are constructed in two parts: the part you keep inline with your text and the part you store somewhere else in the file to keep the text easy to read. Markdown: In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it was a [ hobbit-hole ][ 1 ], and that means comfort. [ 1 ]: <https://en.wikipedia.org/wiki/Hobbit#Lifestyle> \"Hobbit lifestyles\" Rendered: In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it was a hobbit-hole , and that means comfort. Images \u2693\ufe0e To add an image, add an exclamation mark ( ! ), followed by alt text in brackets, and the path or URL to the image asset in parentheses. You can optionally add a title after the URL in the parentheses. ![ Image alt title ]( https://dummyimage.com/300x200 \"Image title\" ) Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Image alt title Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Image alt title Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Admonitions \u2693\ufe0e Default title !!! note Default title Note Default title Custom title !!! tip \"Custom title\" Custom title Custom title Custom title No title !!! info \"\" No title No title No title More details More content !!! success Embedded code ``` python def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` in side Success Embedded code def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] in side Other types note, seealso abstract, summary, tldr info, todo tip, hint, important success, check, done question, help, faq warning, caution, attention failure, fail, missing danger, error bug example quote, cite Collapse \u2693\ufe0e Collapsed ??? note Details Note Details Expanded ???+ note Expanded details Note Expanded details Tables \u2693\ufe0e markdown: | Syntax | Description | | ----------- | ----------- | | Header | Title | | Paragraph | Text | | Syntax | Description | Test Text | | :--- | :----: | ---: | | Header | Title | Here's this | | Paragraph | Text | And more | | Method | Description | | ----------- | ------------------------------------ | | `GET` | :material-check: Fetch resource | | `PUT` | :material-check-all: Update resource | | `DELETE` | :material-close: Delete resource | | Column 1 | Column 2 | Column 3 | | :----------: | -------- | -------- | | expanded || expanded | | not expanded | | | | expanded | ~~| | | expanded | ~~ | | | expanded | a cell | | | _ _ | a cell | | | a cell | a cell | _ _ | rendered: Syntax Description Header Title Paragraph Text Syntax Description Test Text Header Title Here's this Paragraph Text And more Method Description GET Fetch resource PUT Update resource DELETE Delete resource Column 1 Column 2 Column 3 expanded expanded not expanded expanded expanded expanded a cell a cell a cell a cell Actions \u2693\ufe0e The KBD Extension is an inline processor for adding markdown syntax for inline <kbd> tags. Text that is wrapped in: double brackets [[button]] double braces {{menu}} or double parenthesis ((action)) will be wrapped with an HTML <kbd> tag with different classes. markdown: [[Ctrl]]+[[Alt]]+[[Del]] or [[Details]] ((Save)) or ((Run > Run As)) {{Double click}} or {{Long press}} rendered: Ctrl + Alt + Del or Details Save or Run > Run As Double click or Long press Code blocks \u2693\ufe0e Numbered ``` python linenums=\"1\" def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Highlighted ``` python linenums=\"1\" hl_lines=\"2 3\" def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Inline The `#!python range()` function is used to generate a sequence of numbers. The `#!cpp int main(void)` function is the entry point of user application. The range () function is used to generate a sequence of numbers. The int main ( void ) function is the entry point of user application. Tabs \u2693\ufe0e markdown: === \"C\" ``` c #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } ``` === \"C++\" ``` c ++ #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } ``` rendered: C #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } C++ #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } Footnotes \u2693\ufe0e Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ( [^1] ). Identifiers can be numbers or words, but they can\u2019t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself \u2014 in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ( [^1] : My footnote.). You don\u2019t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. Here's a simple footnote,[^1] and here's a longer one.[^bignote] [ ^1 ]: This is the first footnote. [ ^bignote ]: Here's one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `{ my code }` \\ Add as many paragraphs as you like. Here's a simple footnote, 1 and here's a longer one. 2 This is the first footnote. \u21a9 Here's one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. { my code } Add as many paragraphs as you like. \u21a9","title":"Markdown Syntax"},{"location":"posts/markdown_syntax/#markdown-syntax","text":"","title":"Markdown Syntax"},{"location":"posts/markdown_syntax/#metadata","text":"In a markdown file, if you add metadata in YAML format at the begining of the file, it will be used to create page.meta object. Metadata is not shown in the page content, but it is used in rendering template to HTML. It is recommended to have at least 3 fields title , description , and tags , in each post. --- title : Lorem ipsum dolor sit amet description : Nullam urna elit, malesuada eget finibus ut, ac tortor. tags : - tag1 - tag2 ---","title":"Metadata"},{"location":"posts/markdown_syntax/#headings","text":"To create a heading, add number signs ( # ) in front of a word or phrase. The number of number signs you use should correspond to the heading level. For example, to create a heading level three ( <h3> ), use three number signs ( ### My Header level 3 ). Please remember to always put a space between the number signs and the heading name.","title":"Headings"},{"location":"posts/markdown_syntax/#paragraphs","text":"Writing a paragraph is very straight forward. You just write down your sentences and they will be wrapped in <p> tags. To create paragraphs, use a blank line to separate one or more lines of text. To create a line break ( <br> ), end a line with two or more spaces, and then type return. You can add emphasis by making text bold or italic : To bold text, add two asterisks or underscores before and after a word or phrase To italicize text, add one asterisk or underscore before and after a word or phrase. To create a blockquote, add a > in front of a paragraph. Here is an example:","title":"Paragraphs"},{"location":"posts/markdown_syntax/#marks","text":"Beside standard marks to emphasize text as bold or italic , extended markdown supports some extra ways as below:","title":"Marks"},{"location":"posts/markdown_syntax/#list","text":"You can organize items into ordered and unordered lists. To create an ordered list, add line items with numbers followed by periods. The numbers don\u2019t have to be in numerical order, but the list should start with the number one. To create an unordered list, add dashes ( - ), asterisks ( * ), or plus signs ( + ) in front of line items. Indent one or more items to create a nested list. To create Task List, use checked box ( [ ] or [x] ) to show completed or uncompleted tasks.","title":"List"},{"location":"posts/markdown_syntax/#links","text":"To create a link, enclose the link text in brackets (e.g., [Google] ) and then follow it immediately with the URL in parentheses (e.g., (https://google.com) ). To quickly turn a URL or email address into a link, enclose it in angle brackets ( <> ).","title":"Links"},{"location":"posts/markdown_syntax/#images","text":"To add an image, add an exclamation mark ( ! ), followed by alt text in brackets, and the path or URL to the image asset in parentheses. You can optionally add a title after the URL in the parentheses. ![ Image alt title ]( https://dummyimage.com/300x200 \"Image title\" ) Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Image alt title Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Image alt title Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.","title":"Images"},{"location":"posts/markdown_syntax/#admonitions","text":"Default title !!! note Default title Note Default title Custom title !!! tip \"Custom title\" Custom title Custom title Custom title No title !!! info \"\" No title No title No title More details More content !!! success Embedded code ``` python def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` in side Success Embedded code def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] in side Other types note, seealso abstract, summary, tldr info, todo tip, hint, important success, check, done question, help, faq warning, caution, attention failure, fail, missing danger, error bug example quote, cite","title":"Admonitions"},{"location":"posts/markdown_syntax/#collapse","text":"Collapsed ??? note Details Note Details Expanded ???+ note Expanded details Note Expanded details","title":"Collapse"},{"location":"posts/markdown_syntax/#tables","text":"","title":"Tables"},{"location":"posts/markdown_syntax/#actions","text":"The KBD Extension is an inline processor for adding markdown syntax for inline <kbd> tags. Text that is wrapped in: double brackets [[button]] double braces {{menu}} or double parenthesis ((action)) will be wrapped with an HTML <kbd> tag with different classes.","title":"Actions"},{"location":"posts/markdown_syntax/#code-blocks","text":"Numbered ``` python linenums=\"1\" def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Highlighted ``` python linenums=\"1\" hl_lines=\"2 3\" def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] ``` 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Inline The `#!python range()` function is used to generate a sequence of numbers. The `#!cpp int main(void)` function is the entry point of user application. The range () function is used to generate a sequence of numbers. The int main ( void ) function is the entry point of user application.","title":"Code blocks"},{"location":"posts/markdown_syntax/#tabs","text":"","title":"Tabs"},{"location":"posts/markdown_syntax/#footnotes","text":"Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ( [^1] ). Identifiers can be numbers or words, but they can\u2019t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself \u2014 in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ( [^1] : My footnote.). You don\u2019t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. Here's a simple footnote,[^1] and here's a longer one.[^bignote] [ ^1 ]: This is the first footnote. [ ^bignote ]: Here's one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `{ my code }` \\ Add as many paragraphs as you like. Here's a simple footnote, 1 and here's a longer one. 2 This is the first footnote. \u21a9 Here's one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. { my code } Add as many paragraphs as you like. \u21a9","title":"Footnotes"},{"location":"posts/stm32/intro/","text":"Introduction to STM32 MCUs \u2693\ufe0e ARM Based Processors \u2693\ufe0e ARM processors use Reduced Instruction Set Computing (RISC) architectures, and nowaday have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.,). An ARM architecture is a set of specifications regarding the instruction set , the execution model, the memory organization and layout, the instruction cycles and more, which describes precisely a machine that will implement said architecture. ARM Cortex is a wide set of 32/64-bit architectures and cores really popular in the embedded world. Cortex microcontrollers are divided into three main subfamilies: Cortex-A, which stands for Application, is a series of processors providing a range of solutions for devices undertaking complex computing tasks, such as hosting a rich Operating System (OS) platform (Linux and its derivative Android are the most common ones), and supporting multiple software applications. Cortex-M, which stands for eMbedded, is a range of scalable, compatible, energy efficient and easy to use processors designed for the low-cost embedded market. The Cortex-M family is optimized for cost and power sensitive MCUs suitable for single applications on small devices. Cortex-R, which stand for Real-Time, is a series of processors offering high-performance computing solutions for embedded systems where reliability, high availability, fault tolerance, maintainability and deterministic real-time response are essential. Core Registers \u2693\ufe0e Like all RISC architectures, Cortex-M processors perform operations on CPU registers and load/save data from/to memory locations. There are some General Purpose Registers numbered as R0 to R12 and some Specific Registers have alias names such as R13 (Stack Pointer) or R15 (Program Counter) . ARM Contex-M Registers Memory Map \u2693\ufe0e ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4 GB wide, and it is organized in several sub-regions with different logical functionalities, such as the first 512 MB are dedicated to code area. All Cortex-M processors map the code area starting at address 0x00000000 which has the pointers to the beginning of the Stack , to the Reset Handler , and Vectore Table for MCUs to start. The internal MCU flash memory is the area where program code resides, and it locates at 0x08000000 . In the Code Area, there are Flash space, System Memory (in ROM) space, and Options Bytes (in Flash) space, which are used for storing firmware code, bootloader, and system configurations. Depending on BOOT configuration (BOOT pins, and Boot Option in Option Bytes), system will boot from either SRAM, or FLash, or System Memory. Because system always boots at the startup address 0x00000000 , there is a mapping method to make SRAM, Flash, or System Memory be aliased from the startup address. It means, fox example, data on the aliased Flash area with offset 0x00001234 can be refered from either the ogirinal address 0x08001234 or from the aliased address 0x00001234 . ARM Cortex-M Memory Map ARM Cortex-M Memory Map in Code Area Exceptions Handling \u2693\ufe0e Interrupts and Exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. These could be fault events such as an attempt to access an invalid memory location, or events generated by the Operating System, if any. Each exception (and hence interrupt) has a number which uniquely identifies it. This number reflects the position of the exception handler routine inside the vector table, where the actual address of the routine is stored. Number Exception Type Priority Function 1 Reset -3 Reset Handler 2 NMI -2 Non-maskable Interrupt 3 Hard Fault -1 All classes of Fault which is not handled 4 Memory Management Configurable MPU Fault 5 Bus Fault Configurable Pre-fetch or Memory access Fault 6 Usage Fault Configurable Undefined instruaction or Illegal state 7~10 - - Reserved 11 SVCall Configurable System Call 12 Debug Monitor Configurable Software-based Debugger 13 - - Reserved 14 Pending SV Configurable Pending request for System Service 15 SysTick Configurable System Timer has fired every tick 16~ IRQ Configurable Interrupt Request CMIS Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE: API for the Cortex-M processor core and peripherals. It provides a standardized interface for Cortex-M0/3/4/7 CMSIS-Driver: defines generic peripheral driver interfaces for middleware making them reusable across supported devices. The API is RTOS independent and connects microcontroller peripherals to middleware which implements, amongst other things, communication stacks, file systems or graphical user interfaces CMSIS-RTOS: Common APIs for Real-Time Operating Systems . It provides a standardized programming interface which is portable to many RTOS and therefore enables software templates, middleware, libraries, and other components which can work across supported RTOS systems. STM32 MCUs \u2693\ufe0e MCU Families \u2693\ufe0e STM32 is a broad range of microcontrollers divided in nine sub-families, each one with its features. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various other peripherals. Some MCUs provide additional types of memory (EEPROM, CCM, etc.), and a whole line of devices targeting low-power applications is continuously growing. Cortex-M based MCUs with large community, free tool-chain, and many shared knowledge articles. Pin-to-Pin compatibility for most of STM32 MCUs, which helps you to change the MCU while keeping pin assignments 5 V tolerant means you can interface with other devices which do not use 3.3 V without using level shifter. Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS. Integrated bootloader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals (USART, I\u00b2C, etc.) STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards You can choose any board to try but it is recommended to start with F0 families as it is easy to learn with small number of pins, and then you can move to F4 families to learn most of available features in STM32 MCUs. Here is some brieft information about STM32 MCUs families: STM32 Families Features F0 ARM Cortex-M0 core at a maximum clock rate of 48 MHz Upto 32 KB SRAM, 256 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) F1 ARM Cortex-M3 core at a maximum clock rate ranging from 24 MHz to 72 MHz Upto 96 KB SRAM, 256 KB Flash, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 80 fast I/Os, 5 V tolerant F2 ARM Cortex-M3 core at a maximum clock rate of 120 MHz Upto 128 KB SRAM, 1024 KB Flash, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant F3 ARM Cortex-M4F core at a maximum clock rate of 72 MHz Upto 80 KB SRAM, 512 KB Flash, 128 B Backup Memory, 8 KB Core Coupled Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant Ultra-fast comparators (25 ns) Op-amp with programmable gain Ultra-fast 12-bit ADCs Precise 16-bit sigma-delta ADC F4 ARM Cortex-M4F core at a maximum clock ranging from 84 to 180 MHz Upto 384 KB SRAM, 2048 KB Flash, 64 KB Coupled Memory, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant I2S and Audio PLL F7 ARM Cortex-M7 core at a maximum clock of 216 MHz Upto 512 Kb SRAM, 2048 KB Flash, 16 KB + 16 KB L1 Cache Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 164 fast I/Os, 5 V tolerant Double-precision FPU, SAI, Audio PLL, CAN, USB OTG, HDMI-ECE, Ethernet H7 ARM Cortex-M7 core at a maximum clock of 400 MHz Upto 1024 KB SRAM, 2048 KB Flash, 16 KB + 16 KB L1 Cache Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 164 fast I/Os, 5 V tolerant 14-bit ADC, SAI, Double-precision FPU, CAN, Audio PLL Support to SDMMC and FSMC interfaces L0 ARM Cortex-M0+ core at a maximum clock rate of 32 MHz Upto 8 KB SRAM, 64 KB Flash, 20 B Backup Memory, 2 KB EEPROM Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Ultra-low-power mode + backup register: 250 nA Wake-up time: 3.5 \u00b5s L1 ARM Cortex-M3 core with FPU at a maximum clock rate of 32 MHz Upto 320 KB SRAM, 1024 KB Flash, 20 B Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Ultra-low-power mode + backup register: 250 nA Wake-up time: 3.5 \u00b5s L4 ARM Cortex-M4F core with FPU at a maximum clock rate of 80 MHz Upto 320 KB SRAM, 1024 KB Flash, 20 B Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to SDMMC and FSMC interfaces Ultra-low-power mode: 30 nA baseline of current comsumption L4+ ARM Cortex-M4F core with FPU at a maximum clock rate of 120 MHz. Upto 640 KB SRAM, 2048 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to SDMMC and FSMC interfaces Ultra-low-power mode: 20 nA baseline of current comsumption Wake-up time: 5 \u03bcs. Dynamic run mode: down to 43 \u03bcA/MHz. WB ARM Cortex-M4F core with FPU at a maximum clock rate of 64 MHz, or ARM Cortex-M0+ core a maximum clock rate of 32 MHz Upto 256 KB SRAM, 1024 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to Quad-SPI interface BLE 5.0 compatible radio front-end and stack. IEEE 802.15.4 compatible radio front-end ART(tm) Accelerator Select your MCU \u2693\ufe0e If you are going to develop a CPU intensive application , focused on multimedia and graphic applications, then you have to shift our attention to the High-Performance group of STM32 microcontrollers. If, on the other hand, the computing power is not the main requirement of our electronic device, you can focus on the Mainstream segment, giving a close look at the STM32F1 series which offers the most extensive selection to choose from. If you need to interact with the external world through an Ethernet connection or other industrial protocols such as a CAN bus , and our application has to be responsive and able to deal with several Internet Protocols , then the STM32F4 portfolio is probably your best option. If you are going to develop a battery-powered device, then you have to look at the STM32L selection. STM32CubeIDE \u2693\ufe0e While there are many Integrated Development Environment (IDE) software can be used to develop applications on ARM Cortex-M MCUs, ST has their own free STM32CubeIDE , easy-to-use, fully-featured IDE for STM32 MCUs. STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration , code generation , code navigation , code compilation , programmer and debugger for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC toolchain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. Download at: https://www.st.com/en/development-tools/stm32cubeide.html STM32CubeIDE is a complete toolchain for ST's STM32 MCUs, you can read more about ARM Toolchain & Makefile . Key Features Integration of services from STM32CubeMX: STM32 microcontroller, microprocessor, development platform and example project selection Pinout, clock, peripheral, and middleware configuration Project creation and generation of the initialization code Software and middleware completed with enhanced STM32Cube Expansion Packages Based on Eclipse\u00ae/CDT, with support of Eclipse\u00ae add-ons, GNU C/C++ for Arm\u00ae toolchain and GDB debugger Additional advanced debug features including: CPU core, peripheral register, and memory views Live variable watch view System analysis and real-time tracing (SWV) CPU fault analysis tool Support of ST-LINK (STMicroelectronics) and J-Link (SEGGER) debug probes Import project from Atollic\u00ae TrueSTUDIO\u00ae and AC6 System Workbench for STM32 (SW4STM32) Multi-OS support: Windows\u00ae, Linux\u00ae, and macOS\u00ae, 64-bit versions only Create a new project \u2693\ufe0e Start new project It is recommended to start a new project with STM32CudeIDE as it will automatically configure your project for your target MCU. you also can convert other type of projects to STM32CudeIDE project. Sometimes, you have to re-configure settings manually if the IDE cannot do it for you. Welcome screen of STM32CudeIDE Choose the target MCU You can search for your target MCU by using Selectors: MCU/MPU Name, Board, Example, or Custome Filters. Select your target MCU Select Firmware Library Package You will be able to choose the Targeted Language as C or C++, Binary Type , and the Firmware Package Setup settings for a new project At the beginning level, it is recommended to let STM32CubeIDE initialize all peripherals with their default mode. If you select a discovery board, the IDE will assign pins and generate code based on the settings on your selected boards, such as LEDs, Buttons, and Serial Wire Debug (SWD). Configuire target device You will be started with Device Configuration Tool which is known as STM32CubeMX to start setting up your MCU with interactive components. The first tab is Pinout & Configuration in which you can select on available modules to configure them. Pinout View is a greate view to see the pin assignment for your MCU. you can quickly assign a function to a pin by left click on that pin. There will be a popup with a list of functions which can be assigned. If you right click on the pin, you can assign a readable friendly name for it. Pin assignment If you click on a specific module, there is a detail page for you to config that modules, including Name, Pin, Pin Type, Interrupt, DMA, or any other available settings. GPIO configuration The Clock Configuration show the clock paths across your devices from the clock source to the modules. It also allows you to change the multiplier of clock path to increase or decrease the clock frequence. Clock Configuration In the Project Manager tab, you can change some advanced functions of STM32CudeMX such as the size of Heap and Stack, Code Generation. You should leave them default unless you understand about these settings. Project Manager Generate Code If you save your project ( Ctrl + S ) in Device Confirguration Tool it will automatically generate code for you, based on your settings. you can press Alt + K or choose the menu Project > Generate Code too. When you choose to use a Firmware Library in your project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling your processor. HAL also makes use of CMSIS library to access processor's registers. Let's an example of using STM32F0 MCU: Code dependency starts from your startup_stm32f0xx.s file. This file include main.h which then includes HAL files which eventually include CMSIS files. The startup file also call to your main function in main.c to run your program. Generated Code Structure #table1 table, #table2 table { table-layout: fixed; } File Description stm32f0xx_hal.h This file is used for HAL initialization and contains DBGMCU, Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS. headers stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices. Example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c . stm32f0xx_hal_ppp_ex.h/.c Extension file of the peripheral/module ppp driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way. Example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library). This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR. The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 Call to HAL_Init() \u2022 assert_failed() implementation \u2022 system clock configuration \u2022 peripheral HAL initialization and user application code. Write your code The generayed code has some block marked with pairs of comments /* USER CODE BEGIN */ and /* USER CODE END */ . Inside those pairs, you can write your code and they will be untouched by STM32CubeMX when it it re-generates new code. For example: main.c /* Private includes */ /* USER CODE BEGIN Includes */ < YOUR CODE HERE > #include <stdio.h> /* USER CODE END Includes */ /* Private define */ /* USER CODE BEGIN PD */ < YOUR CODE HERE > #define SECRET_NUMBER 0x12345678 /* USER CODE END PD */ /* Private variables */ /* USER CODE BEGIN PV */ < YOUR CODE HERE > uint8_t key = 0xFF ; /* USER CODE END PV */ int main ( void ) { HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); /* Infinite loop */ /* USER CODE BEGIN WHILE */ < YOUR CODE HERE > HAL_GPIO_WritePin ( Green_Led_GPIO_Port , Green_Led_Pin , GPIO_PIN_SET ); while ( 1 ) { < YOUR CODE HERE > HAL_GPIO_TogglePin ( Blue_Led_GPIO_Port , Blue_Led_Pin ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ < YOUR CODE HERE > } /* USER CODE END 3 */ } Run on board First, you must compile your code by press Ctrl + B , or menu Project > Build Project Memory report after compilation Then after you connect the cable from your board to your computer, press F11 or Run > Debug to download your code to board and start debugging session. Your application will paused at the main() function by default. Press F8 to Resume . Related documents \u2693\ufe0e In embedded programming, documents have a very important role as they are the main reference source for developer to know how the processor works and how to configure it. Those documents mainly come from the processsor manufacture, it means you can download it from the manufacture website. STM32CudeIDE has a better way to list all related documents of selected processor, and it can download documents for you. you can find the documents in menu Help > Target device docs and resources . Open documents browser Related documents for selected STM32F051R8 MCUs Here is the list of important documents you have to read in order to understand about the processor and its peripherals: Example documents are for STM32F051 MCUs. Board Manual & Schematic \u2693\ufe0e UM1525 - Discovery kit for STM32F0 microcontrollers https://my.st.com/resource/en/user_manual/dm00050135-stm32f0discovery-discovery-kit-for-stm32-f0-microcontrollers-stmicroelectronics.pdf Main content includes: Hardware components and their locations and markers Pinouts and jumpers for connections or configurations Solder Bridges for enabling/disabling features or hardware connections MB1034 RevB.0 - STM32F0-DISCOVERY Schematic https://my.st.com/resource/en/schematic_pack/stm32f0discovery_sch.zip This document show the wires between all hardware components. Reading this document can help to understand: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors) Working conditions (Power level, Votage Level torelance) Processor Datasheet \u2693\ufe0e PM0215 - STM32F0xxx Cortex-M0 programming manual https://my.st.com/resource/en/programming_manual/dm00051352-stm32f0xxx-cortexm0-programming-manual-stmicroelectronics.pdf The main content is: Processor modes: in application and interruption routine Stacks: manage context's data Core Registers: contain instruaction's data and result, system status Memory Model: fixed memory map with address ranges Vector Table: start address, stack pointer, and interruption handlers Sleep mode: condition about clock, data rate, regiter mode Instruction set: assembly mnemonic for instructions Core registers: Address and Name of registers used in core and peripherals. This is the based for progamming the processor. It also have API function name for accessing the registers using CMSIS. DS8668 - STM32F051x4/6/8 Datasheet https://www.st.com/resource/en/datasheet/stm32f051r8.pdf This document shows below information: Functional features Memory Mapping, Boot Mode Pinouts and altenative functions Core and Peripherals' diagrams, protocols RM0091 - Reference manual for STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM-based 32-bit MCUs https://www.st.com/resource/en/reference_manual/dm00031936-stm32f0x1stm32f0x2stm32f0x8-advanced-armbased-32bit-mcus-stmicroelectronics.pdf This is a very important document as it defines all register structure, bit-fields to control core and peripherals . This document includes: System Architecture, Register-Level designs Memory Mapping and Boot configuration Register name and bit-fields for all accessible registers Library Manual \u2693\ufe0e UM1785 - Description of STM32F0 HAL and low-layer drivers https://www.st.com/resource/en/user_manual/dm00122015-description-of-stm32f0-hal-and-lowlayer-drivers-stmicroelectronics.pdf This document describes HAL and LL APIs for programming. Those functions wrap all internal registers and settings, and create a friendly function names and data structure for developer. The HAL drivers include a set of driver modules, each module being linked to a standalone peripheral. The HAL main features are the following: Cross-family portable set of APIs covering the common peripheral features as well as extension APIs in case of specific peripheral features. Three API programming models: polling, interrupt and DMA. APIs are RTOS compliant: Fully reentrant APIs Systematic usage of timeouts in polling mode Support of peripheral multi-instance allowing concurrent API calls for multiple instances of a given peripheral (USART1, USART2...) All HAL APIs implement user-callback functions mechanism: Peripheral Init/DeInit HAL APIs can call user-callback functions to perform peripheral system level. Initialization/De-Initialization (clock, GPIOs, interrupt, DMA) Peripherals interrupt events Error events Object locking mechanism: safe hardware access to prevent multiple spurious accesses to shared resources Timeout used for all blocking processes: the timeout can be a simple counter or a timebase UM1722 - Developing applications on STM32Cube with RTOS https://www.st.com/resource/en/user_manual/dm00105262-developing-applications-on-stm32cube-with-rtos-stmicroelectronics.pdf This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managementm, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard https://developer.arm.com/tools-and-software/embedded/cmsis https://developer.arm.com/embedded/cmsis/cmsis-packs/devices/STMicroelectronics/STM32F051R8 ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process Conclusion \u2693\ufe0e By reading to this point, I hope you can get an overview of what STM32 MCUs are, how to run a simple project with STM32CubeIDE, and where to find more information about your target MCUs.","title":"Introduction to STM32 MCUs"},{"location":"posts/stm32/intro/#introduction-to-stm32-mcus","text":"","title":"Introduction to STM32 MCUs"},{"location":"posts/stm32/intro/#arm-based-processors","text":"ARM processors use Reduced Instruction Set Computing (RISC) architectures, and nowaday have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.,). An ARM architecture is a set of specifications regarding the instruction set , the execution model, the memory organization and layout, the instruction cycles and more, which describes precisely a machine that will implement said architecture. ARM Cortex is a wide set of 32/64-bit architectures and cores really popular in the embedded world. Cortex microcontrollers are divided into three main subfamilies: Cortex-A, which stands for Application, is a series of processors providing a range of solutions for devices undertaking complex computing tasks, such as hosting a rich Operating System (OS) platform (Linux and its derivative Android are the most common ones), and supporting multiple software applications. Cortex-M, which stands for eMbedded, is a range of scalable, compatible, energy efficient and easy to use processors designed for the low-cost embedded market. The Cortex-M family is optimized for cost and power sensitive MCUs suitable for single applications on small devices. Cortex-R, which stand for Real-Time, is a series of processors offering high-performance computing solutions for embedded systems where reliability, high availability, fault tolerance, maintainability and deterministic real-time response are essential.","title":"ARM Based Processors"},{"location":"posts/stm32/intro/#core-registers","text":"Like all RISC architectures, Cortex-M processors perform operations on CPU registers and load/save data from/to memory locations. There are some General Purpose Registers numbered as R0 to R12 and some Specific Registers have alias names such as R13 (Stack Pointer) or R15 (Program Counter) . ARM Contex-M Registers","title":"Core Registers"},{"location":"posts/stm32/intro/#memory-map","text":"ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4 GB wide, and it is organized in several sub-regions with different logical functionalities, such as the first 512 MB are dedicated to code area. All Cortex-M processors map the code area starting at address 0x00000000 which has the pointers to the beginning of the Stack , to the Reset Handler , and Vectore Table for MCUs to start. The internal MCU flash memory is the area where program code resides, and it locates at 0x08000000 . In the Code Area, there are Flash space, System Memory (in ROM) space, and Options Bytes (in Flash) space, which are used for storing firmware code, bootloader, and system configurations. Depending on BOOT configuration (BOOT pins, and Boot Option in Option Bytes), system will boot from either SRAM, or FLash, or System Memory. Because system always boots at the startup address 0x00000000 , there is a mapping method to make SRAM, Flash, or System Memory be aliased from the startup address. It means, fox example, data on the aliased Flash area with offset 0x00001234 can be refered from either the ogirinal address 0x08001234 or from the aliased address 0x00001234 . ARM Cortex-M Memory Map ARM Cortex-M Memory Map in Code Area","title":"Memory Map"},{"location":"posts/stm32/intro/#exceptions-handling","text":"Interrupts and Exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. These could be fault events such as an attempt to access an invalid memory location, or events generated by the Operating System, if any. Each exception (and hence interrupt) has a number which uniquely identifies it. This number reflects the position of the exception handler routine inside the vector table, where the actual address of the routine is stored. Number Exception Type Priority Function 1 Reset -3 Reset Handler 2 NMI -2 Non-maskable Interrupt 3 Hard Fault -1 All classes of Fault which is not handled 4 Memory Management Configurable MPU Fault 5 Bus Fault Configurable Pre-fetch or Memory access Fault 6 Usage Fault Configurable Undefined instruaction or Illegal state 7~10 - - Reserved 11 SVCall Configurable System Call 12 Debug Monitor Configurable Software-based Debugger 13 - - Reserved 14 Pending SV Configurable Pending request for System Service 15 SysTick Configurable System Timer has fired every tick 16~ IRQ Configurable Interrupt Request","title":"Exceptions Handling"},{"location":"posts/stm32/intro/#stm32-mcus","text":"","title":"STM32 MCUs"},{"location":"posts/stm32/intro/#mcu-families","text":"STM32 is a broad range of microcontrollers divided in nine sub-families, each one with its features. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various other peripherals. Some MCUs provide additional types of memory (EEPROM, CCM, etc.), and a whole line of devices targeting low-power applications is continuously growing. Cortex-M based MCUs with large community, free tool-chain, and many shared knowledge articles. Pin-to-Pin compatibility for most of STM32 MCUs, which helps you to change the MCU while keeping pin assignments 5 V tolerant means you can interface with other devices which do not use 3.3 V without using level shifter. Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS. Integrated bootloader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals (USART, I\u00b2C, etc.) STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards You can choose any board to try but it is recommended to start with F0 families as it is easy to learn with small number of pins, and then you can move to F4 families to learn most of available features in STM32 MCUs. Here is some brieft information about STM32 MCUs families: STM32 Families Features F0 ARM Cortex-M0 core at a maximum clock rate of 48 MHz Upto 32 KB SRAM, 256 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) F1 ARM Cortex-M3 core at a maximum clock rate ranging from 24 MHz to 72 MHz Upto 96 KB SRAM, 256 KB Flash, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 80 fast I/Os, 5 V tolerant F2 ARM Cortex-M3 core at a maximum clock rate of 120 MHz Upto 128 KB SRAM, 1024 KB Flash, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant F3 ARM Cortex-M4F core at a maximum clock rate of 72 MHz Upto 80 KB SRAM, 512 KB Flash, 128 B Backup Memory, 8 KB Core Coupled Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant Ultra-fast comparators (25 ns) Op-amp with programmable gain Ultra-fast 12-bit ADCs Precise 16-bit sigma-delta ADC F4 ARM Cortex-M4F core at a maximum clock ranging from 84 to 180 MHz Upto 384 KB SRAM, 2048 KB Flash, 64 KB Coupled Memory, 4 KB Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 136 fast I/Os, 5 V tolerant I2S and Audio PLL F7 ARM Cortex-M7 core at a maximum clock of 216 MHz Upto 512 Kb SRAM, 2048 KB Flash, 16 KB + 16 KB L1 Cache Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 164 fast I/Os, 5 V tolerant Double-precision FPU, SAI, Audio PLL, CAN, USB OTG, HDMI-ECE, Ethernet H7 ARM Cortex-M7 core at a maximum clock of 400 MHz Upto 1024 KB SRAM, 2048 KB Flash, 16 KB + 16 KB L1 Cache Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Upto 164 fast I/Os, 5 V tolerant 14-bit ADC, SAI, Double-precision FPU, CAN, Audio PLL Support to SDMMC and FSMC interfaces L0 ARM Cortex-M0+ core at a maximum clock rate of 32 MHz Upto 8 KB SRAM, 64 KB Flash, 20 B Backup Memory, 2 KB EEPROM Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Ultra-low-power mode + backup register: 250 nA Wake-up time: 3.5 \u00b5s L1 ARM Cortex-M3 core with FPU at a maximum clock rate of 32 MHz Upto 320 KB SRAM, 1024 KB Flash, 20 B Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Ultra-low-power mode + backup register: 250 nA Wake-up time: 3.5 \u00b5s L4 ARM Cortex-M4F core with FPU at a maximum clock rate of 80 MHz Upto 320 KB SRAM, 1024 KB Flash, 20 B Backup Memory Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to SDMMC and FSMC interfaces Ultra-low-power mode: 30 nA baseline of current comsumption L4+ ARM Cortex-M4F core with FPU at a maximum clock rate of 120 MHz. Upto 640 KB SRAM, 2048 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to SDMMC and FSMC interfaces Ultra-low-power mode: 20 nA baseline of current comsumption Wake-up time: 5 \u03bcs. Dynamic run mode: down to 43 \u03bcA/MHz. WB ARM Cortex-M4F core with FPU at a maximum clock rate of 64 MHz, or ARM Cortex-M0+ core a maximum clock rate of 32 MHz Upto 256 KB SRAM, 1024 KB Flash Basic Peripherals (WDT, CRC, RTC, TMR, ADC, DMA, USART, SWD, SPI, I2C) Support to Quad-SPI interface BLE 5.0 compatible radio front-end and stack. IEEE 802.15.4 compatible radio front-end ART(tm) Accelerator","title":"MCU Families"},{"location":"posts/stm32/intro/#select-your-mcu","text":"If you are going to develop a CPU intensive application , focused on multimedia and graphic applications, then you have to shift our attention to the High-Performance group of STM32 microcontrollers. If, on the other hand, the computing power is not the main requirement of our electronic device, you can focus on the Mainstream segment, giving a close look at the STM32F1 series which offers the most extensive selection to choose from. If you need to interact with the external world through an Ethernet connection or other industrial protocols such as a CAN bus , and our application has to be responsive and able to deal with several Internet Protocols , then the STM32F4 portfolio is probably your best option. If you are going to develop a battery-powered device, then you have to look at the STM32L selection.","title":"Select your MCU"},{"location":"posts/stm32/intro/#stm32cubeide","text":"While there are many Integrated Development Environment (IDE) software can be used to develop applications on ARM Cortex-M MCUs, ST has their own free STM32CubeIDE , easy-to-use, fully-featured IDE for STM32 MCUs. STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration , code generation , code navigation , code compilation , programmer and debugger for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC toolchain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. Download at: https://www.st.com/en/development-tools/stm32cubeide.html STM32CubeIDE is a complete toolchain for ST's STM32 MCUs, you can read more about ARM Toolchain & Makefile .","title":"STM32CubeIDE"},{"location":"posts/stm32/intro/#create-a-new-project","text":"Start new project It is recommended to start a new project with STM32CudeIDE as it will automatically configure your project for your target MCU. you also can convert other type of projects to STM32CudeIDE project. Sometimes, you have to re-configure settings manually if the IDE cannot do it for you. Welcome screen of STM32CudeIDE Choose the target MCU You can search for your target MCU by using Selectors: MCU/MPU Name, Board, Example, or Custome Filters. Select your target MCU Select Firmware Library Package You will be able to choose the Targeted Language as C or C++, Binary Type , and the Firmware Package Setup settings for a new project At the beginning level, it is recommended to let STM32CubeIDE initialize all peripherals with their default mode. If you select a discovery board, the IDE will assign pins and generate code based on the settings on your selected boards, such as LEDs, Buttons, and Serial Wire Debug (SWD). Configuire target device You will be started with Device Configuration Tool which is known as STM32CubeMX to start setting up your MCU with interactive components. The first tab is Pinout & Configuration in which you can select on available modules to configure them. Pinout View is a greate view to see the pin assignment for your MCU. you can quickly assign a function to a pin by left click on that pin. There will be a popup with a list of functions which can be assigned. If you right click on the pin, you can assign a readable friendly name for it. Pin assignment If you click on a specific module, there is a detail page for you to config that modules, including Name, Pin, Pin Type, Interrupt, DMA, or any other available settings. GPIO configuration The Clock Configuration show the clock paths across your devices from the clock source to the modules. It also allows you to change the multiplier of clock path to increase or decrease the clock frequence. Clock Configuration In the Project Manager tab, you can change some advanced functions of STM32CudeMX such as the size of Heap and Stack, Code Generation. You should leave them default unless you understand about these settings. Project Manager Generate Code If you save your project ( Ctrl + S ) in Device Confirguration Tool it will automatically generate code for you, based on your settings. you can press Alt + K or choose the menu Project > Generate Code too. When you choose to use a Firmware Library in your project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling your processor. HAL also makes use of CMSIS library to access processor's registers. Let's an example of using STM32F0 MCU: Code dependency starts from your startup_stm32f0xx.s file. This file include main.h which then includes HAL files which eventually include CMSIS files. The startup file also call to your main function in main.c to run your program. Generated Code Structure #table1 table, #table2 table { table-layout: fixed; } File Description stm32f0xx_hal.h This file is used for HAL initialization and contains DBGMCU, Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS. headers stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices. Example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c . stm32f0xx_hal_ppp_ex.h/.c Extension file of the peripheral/module ppp driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way. Example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library). This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR. The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 Call to HAL_Init() \u2022 assert_failed() implementation \u2022 system clock configuration \u2022 peripheral HAL initialization and user application code. Write your code The generayed code has some block marked with pairs of comments /* USER CODE BEGIN */ and /* USER CODE END */ . Inside those pairs, you can write your code and they will be untouched by STM32CubeMX when it it re-generates new code. For example: main.c /* Private includes */ /* USER CODE BEGIN Includes */ < YOUR CODE HERE > #include <stdio.h> /* USER CODE END Includes */ /* Private define */ /* USER CODE BEGIN PD */ < YOUR CODE HERE > #define SECRET_NUMBER 0x12345678 /* USER CODE END PD */ /* Private variables */ /* USER CODE BEGIN PV */ < YOUR CODE HERE > uint8_t key = 0xFF ; /* USER CODE END PV */ int main ( void ) { HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); /* Infinite loop */ /* USER CODE BEGIN WHILE */ < YOUR CODE HERE > HAL_GPIO_WritePin ( Green_Led_GPIO_Port , Green_Led_Pin , GPIO_PIN_SET ); while ( 1 ) { < YOUR CODE HERE > HAL_GPIO_TogglePin ( Blue_Led_GPIO_Port , Blue_Led_Pin ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ < YOUR CODE HERE > } /* USER CODE END 3 */ } Run on board First, you must compile your code by press Ctrl + B , or menu Project > Build Project Memory report after compilation Then after you connect the cable from your board to your computer, press F11 or Run > Debug to download your code to board and start debugging session. Your application will paused at the main() function by default. Press F8 to Resume .","title":"Create a new project"},{"location":"posts/stm32/intro/#related-documents","text":"In embedded programming, documents have a very important role as they are the main reference source for developer to know how the processor works and how to configure it. Those documents mainly come from the processsor manufacture, it means you can download it from the manufacture website. STM32CudeIDE has a better way to list all related documents of selected processor, and it can download documents for you. you can find the documents in menu Help > Target device docs and resources . Open documents browser Related documents for selected STM32F051R8 MCUs Here is the list of important documents you have to read in order to understand about the processor and its peripherals: Example documents are for STM32F051 MCUs.","title":"Related documents"},{"location":"posts/stm32/intro/#board-manual--schematic","text":"UM1525 - Discovery kit for STM32F0 microcontrollers https://my.st.com/resource/en/user_manual/dm00050135-stm32f0discovery-discovery-kit-for-stm32-f0-microcontrollers-stmicroelectronics.pdf Main content includes: Hardware components and their locations and markers Pinouts and jumpers for connections or configurations Solder Bridges for enabling/disabling features or hardware connections MB1034 RevB.0 - STM32F0-DISCOVERY Schematic https://my.st.com/resource/en/schematic_pack/stm32f0discovery_sch.zip This document show the wires between all hardware components. Reading this document can help to understand: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors) Working conditions (Power level, Votage Level torelance)","title":"Board Manual &amp; Schematic"},{"location":"posts/stm32/intro/#processor-datasheet","text":"PM0215 - STM32F0xxx Cortex-M0 programming manual https://my.st.com/resource/en/programming_manual/dm00051352-stm32f0xxx-cortexm0-programming-manual-stmicroelectronics.pdf The main content is: Processor modes: in application and interruption routine Stacks: manage context's data Core Registers: contain instruaction's data and result, system status Memory Model: fixed memory map with address ranges Vector Table: start address, stack pointer, and interruption handlers Sleep mode: condition about clock, data rate, regiter mode Instruction set: assembly mnemonic for instructions Core registers: Address and Name of registers used in core and peripherals. This is the based for progamming the processor. It also have API function name for accessing the registers using CMSIS. DS8668 - STM32F051x4/6/8 Datasheet https://www.st.com/resource/en/datasheet/stm32f051r8.pdf This document shows below information: Functional features Memory Mapping, Boot Mode Pinouts and altenative functions Core and Peripherals' diagrams, protocols RM0091 - Reference manual for STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM-based 32-bit MCUs https://www.st.com/resource/en/reference_manual/dm00031936-stm32f0x1stm32f0x2stm32f0x8-advanced-armbased-32bit-mcus-stmicroelectronics.pdf This is a very important document as it defines all register structure, bit-fields to control core and peripherals . This document includes: System Architecture, Register-Level designs Memory Mapping and Boot configuration Register name and bit-fields for all accessible registers","title":"Processor Datasheet"},{"location":"posts/stm32/intro/#library-manual","text":"UM1785 - Description of STM32F0 HAL and low-layer drivers https://www.st.com/resource/en/user_manual/dm00122015-description-of-stm32f0-hal-and-lowlayer-drivers-stmicroelectronics.pdf This document describes HAL and LL APIs for programming. Those functions wrap all internal registers and settings, and create a friendly function names and data structure for developer. The HAL drivers include a set of driver modules, each module being linked to a standalone peripheral. The HAL main features are the following: Cross-family portable set of APIs covering the common peripheral features as well as extension APIs in case of specific peripheral features. Three API programming models: polling, interrupt and DMA. APIs are RTOS compliant: Fully reentrant APIs Systematic usage of timeouts in polling mode Support of peripheral multi-instance allowing concurrent API calls for multiple instances of a given peripheral (USART1, USART2...) All HAL APIs implement user-callback functions mechanism: Peripheral Init/DeInit HAL APIs can call user-callback functions to perform peripheral system level. Initialization/De-Initialization (clock, GPIOs, interrupt, DMA) Peripherals interrupt events Error events Object locking mechanism: safe hardware access to prevent multiple spurious accesses to shared resources Timeout used for all blocking processes: the timeout can be a simple counter or a timebase UM1722 - Developing applications on STM32Cube with RTOS https://www.st.com/resource/en/user_manual/dm00105262-developing-applications-on-stm32cube-with-rtos-stmicroelectronics.pdf This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managementm, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard https://developer.arm.com/tools-and-software/embedded/cmsis https://developer.arm.com/embedded/cmsis/cmsis-packs/devices/STMicroelectronics/STM32F051R8 ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process","title":"Library Manual"},{"location":"posts/stm32/intro/#conclusion","text":"By reading to this point, I hope you can get an overview of what STM32 MCUs are, how to run a simple project with STM32CubeIDE, and where to find more information about your target MCUs.","title":"Conclusion"},{"location":"posts/stm32/semihost/","text":"Semihosting on ARM MCUs \u2693\ufe0e Semihosting is a mechanism that allows target boards to \"exchange messages\" from the embedded firmware to a host computer running a debugger attached to it. This mechanism enables some functions in the C library, such as printf() and scanf() , to use the screen and keyboard of the host instead of having a screen and keyboard on the target system. Semihosting is implemented by a set of defined software instructions, for example, SVCs , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debug agent then handles the exception. The debug agent provides the required communication with the host. Semihost overview The semihosting interface is common across all debug agents provided by ARM. Semihosted operations only work when the target board is under debugging session and connected to semihosting-enabled development platform. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, if you are compiling for an ARMv6-M or ARMv7-M, for example a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting is resource intensive and very slow. However, every ARM controller should have semihosting available, which can be a lifesaver if that\u2019s all you have. Application or interrupt code will NOT run while semihosting transfers are active, so you can miss interrupts. The easiest method to use semihosting is to compile your application with --specs=rdimon.specs and rdimon library which already implements instructions to handle semihosting functional calls. rdimon rdimon library implements interrupt for some special system calls, which pause the processor and interract with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . Linker settings \u2693\ufe0e Start a new project if needed! Firstly, you should check which libraries are linked to you program. Open Project > Properties to show the Properties dialog, go to C/C++ Build > Settings , then select Tool Settings tab, then MCU GCC Linker . By default, STM32CubeIDE will compile your project with --specs=nano.specs and --specs=nosys.specs . Library: newlib and newlib-nano \u2693\ufe0e There are several implementations of the C Standard Library, and Newlib is an implementation targeted at bare-metal embedded systems that is maintained by RedHat . It has become the standard in embedded software because it is complete, has optimizations for a wide range of architectures, and produces relatively small code. Newlib is enabled by default when you build a project with arm-none-eabi-gcc . However, the toolchain is released with two prebuilt C libraries based on newlib: The standard newlib , included by default The optimized for code size newlib-nano , included when you use an additional liker option --specs=nano.specs . Formatted input/output of floating-point number are implemented as weak symbol in newlib-nano . If you want to use %f , you have to pull in the symbol by explicitly specifying -u _printf_float and -u _scanf_float command options Library: nosys and rdimon \u2693\ufe0e NewLib maps standard C functions to a specific implementation environment through a chain of functions for example: application uses printf() which calls write() system function write() invokes _write_r() with the current reentrancy context (e.g. thread/task-unique errno); _write_r() invokes _write() and copies errno appropriately; _write() must be provided by something to finally write out data If nothing provides an implementation of _write() but the application requires one, the application will fail to link. The standard solution for newlib is to add -specs=nosys.specs to the gcc linker command line. This links in a separate library with implementations for all required system functions. Most of them simply return an error; some (like _sbrk() ) provide a usable definition. When enabling rdimon , this library already implements all required system functions in which it interacts with debugger to exchange messages. Therefore, you can remove nosys.specs when you use rdimon . In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . you must exclude syscalls.c from build to avoid compilation error of duplicated function definition . GCC Linker settings Here are steps to enable semihost in linker: In MCU GCC Linker > Libraries menu, add rdimon into Libraries (-l) options In MCU GCC Linker > Miscellaneous menu, add --specs=rdimon.specs into Other Flags options (Optional) In MCU GCC Linker > General menu, choose Do not use system call from library in System Calls options. Finally, you must exclude syscalls.c from build script by right click on that file and choose Properties , check on Exclude resource from build option. Steps to enable semihost Debugger settings \u2693\ufe0e Another side that makes semihost work is Debugger. As mentioned above, semihost on firmware will call to function in debugger to run funcationalities of exchanging message, therefore, you need a debugger that supports semihosting functions. Open Debug Configuration window from Run menu In tab Debugger , set Debug Probe to ST-LINK OpenOCD , and click on Show generator options and choose Reset Mode to Software system reset In tab Startup , add monitor arm semihosting enable into Initialization Commands options. Setup debugger for semihost Code settings \u2693\ufe0e Before you can use semihosting functions, you must enable it. In the main.c file, add reference to the function initialise_monitor_handles () and call that function at the begining of the main () function. Now, you should write some simple code to see how semihost works. It can be printing a counting up counter as below example code. main.c /* USER CODE BEGIN PFP */ extern void initialise_monitor_handles ( void ); /* USER CODE END PFP */ int main ( void ) { /* USER CODE BEGIN 1 */ uint8_t counter = 0 ; // init semihost initialise_monitor_handles (); /* USER CODE END 1 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while ( 1 ) { printf ( \"counter=%d \\n \" , counter ++ ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ Build and Debug \u2693\ufe0e Compile your project and start a debug session by pressing F11 , your program will start to and pause at main function. Press F8 to resume the program and check the output in debug console. Output from semihosting Semihost and newline character Output on debugger is buffered, that means prinf() only pushes character to semihost debug console when it reaches the newline character \\n . Be ware to add newline characters! You can use scanf() to get user input too. Let's write some code: main.c /* USER CODE BEGIN PFP */ extern void initialise_monitor_handles ( void ); /* USER CODE END PFP */ int main ( void ) { /* USER CODE BEGIN 1 */ uint8_t counter = 0 ; // init semihost initialise_monitor_handles (); /* USER CODE END 1 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ printf ( \"Please enter your name: \\n \" ); scanf ( \"%s\" , buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); while ( 1 ) { printf ( \"counter=%d \\n \" , counter ++ ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ Using scanf() with semihost Note \u2693\ufe0e Applications built with semihosting output active normally cannot be executed without the debugger connected and active, since they use BKPT to communicate with the host. However, with a carefully written HardFault_Handler() , the semihosting BKPT calls can be processed, making possible to run semihosting applications as standalone, without being terminated with hardware faults.","title":"Semihosting on ARM MCUs"},{"location":"posts/stm32/semihost/#semihosting-on-arm-mcus","text":"Semihosting is a mechanism that allows target boards to \"exchange messages\" from the embedded firmware to a host computer running a debugger attached to it. This mechanism enables some functions in the C library, such as printf() and scanf() , to use the screen and keyboard of the host instead of having a screen and keyboard on the target system. Semihosting is implemented by a set of defined software instructions, for example, SVCs , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debug agent then handles the exception. The debug agent provides the required communication with the host. Semihost overview The semihosting interface is common across all debug agents provided by ARM. Semihosted operations only work when the target board is under debugging session and connected to semihosting-enabled development platform. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, if you are compiling for an ARMv6-M or ARMv7-M, for example a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting is resource intensive and very slow. However, every ARM controller should have semihosting available, which can be a lifesaver if that\u2019s all you have. Application or interrupt code will NOT run while semihosting transfers are active, so you can miss interrupts. The easiest method to use semihosting is to compile your application with --specs=rdimon.specs and rdimon library which already implements instructions to handle semihosting functional calls. rdimon rdimon library implements interrupt for some special system calls, which pause the processor and interract with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) .","title":"Semihosting on ARM MCUs"},{"location":"posts/stm32/semihost/#linker-settings","text":"Start a new project if needed! Firstly, you should check which libraries are linked to you program. Open Project > Properties to show the Properties dialog, go to C/C++ Build > Settings , then select Tool Settings tab, then MCU GCC Linker . By default, STM32CubeIDE will compile your project with --specs=nano.specs and --specs=nosys.specs .","title":"Linker settings"},{"location":"posts/stm32/semihost/#library-newlib-and-newlib-nano","text":"There are several implementations of the C Standard Library, and Newlib is an implementation targeted at bare-metal embedded systems that is maintained by RedHat . It has become the standard in embedded software because it is complete, has optimizations for a wide range of architectures, and produces relatively small code. Newlib is enabled by default when you build a project with arm-none-eabi-gcc . However, the toolchain is released with two prebuilt C libraries based on newlib: The standard newlib , included by default The optimized for code size newlib-nano , included when you use an additional liker option --specs=nano.specs . Formatted input/output of floating-point number are implemented as weak symbol in newlib-nano . If you want to use %f , you have to pull in the symbol by explicitly specifying -u _printf_float and -u _scanf_float command options","title":"Library: newlib and newlib-nano"},{"location":"posts/stm32/semihost/#library-nosys-and-rdimon","text":"NewLib maps standard C functions to a specific implementation environment through a chain of functions for example: application uses printf() which calls write() system function write() invokes _write_r() with the current reentrancy context (e.g. thread/task-unique errno); _write_r() invokes _write() and copies errno appropriately; _write() must be provided by something to finally write out data If nothing provides an implementation of _write() but the application requires one, the application will fail to link. The standard solution for newlib is to add -specs=nosys.specs to the gcc linker command line. This links in a separate library with implementations for all required system functions. Most of them simply return an error; some (like _sbrk() ) provide a usable definition. When enabling rdimon , this library already implements all required system functions in which it interacts with debugger to exchange messages. Therefore, you can remove nosys.specs when you use rdimon . In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . you must exclude syscalls.c from build to avoid compilation error of duplicated function definition . GCC Linker settings Here are steps to enable semihost in linker: In MCU GCC Linker > Libraries menu, add rdimon into Libraries (-l) options In MCU GCC Linker > Miscellaneous menu, add --specs=rdimon.specs into Other Flags options (Optional) In MCU GCC Linker > General menu, choose Do not use system call from library in System Calls options. Finally, you must exclude syscalls.c from build script by right click on that file and choose Properties , check on Exclude resource from build option. Steps to enable semihost","title":"Library: nosys and rdimon"},{"location":"posts/stm32/semihost/#debugger-settings","text":"Another side that makes semihost work is Debugger. As mentioned above, semihost on firmware will call to function in debugger to run funcationalities of exchanging message, therefore, you need a debugger that supports semihosting functions. Open Debug Configuration window from Run menu In tab Debugger , set Debug Probe to ST-LINK OpenOCD , and click on Show generator options and choose Reset Mode to Software system reset In tab Startup , add monitor arm semihosting enable into Initialization Commands options. Setup debugger for semihost","title":"Debugger settings"},{"location":"posts/stm32/semihost/#code-settings","text":"Before you can use semihosting functions, you must enable it. In the main.c file, add reference to the function initialise_monitor_handles () and call that function at the begining of the main () function. Now, you should write some simple code to see how semihost works. It can be printing a counting up counter as below example code. main.c /* USER CODE BEGIN PFP */ extern void initialise_monitor_handles ( void ); /* USER CODE END PFP */ int main ( void ) { /* USER CODE BEGIN 1 */ uint8_t counter = 0 ; // init semihost initialise_monitor_handles (); /* USER CODE END 1 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while ( 1 ) { printf ( \"counter=%d \\n \" , counter ++ ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */","title":"Code settings"},{"location":"posts/stm32/semihost/#build-and-debug","text":"Compile your project and start a debug session by pressing F11 , your program will start to and pause at main function. Press F8 to resume the program and check the output in debug console. Output from semihosting Semihost and newline character Output on debugger is buffered, that means prinf() only pushes character to semihost debug console when it reaches the newline character \\n . Be ware to add newline characters! You can use scanf() to get user input too. Let's write some code: main.c /* USER CODE BEGIN PFP */ extern void initialise_monitor_handles ( void ); /* USER CODE END PFP */ int main ( void ) { /* USER CODE BEGIN 1 */ uint8_t counter = 0 ; // init semihost initialise_monitor_handles (); /* USER CODE END 1 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ printf ( \"Please enter your name: \\n \" ); scanf ( \"%s\" , buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); while ( 1 ) { printf ( \"counter=%d \\n \" , counter ++ ); HAL_Delay ( 1000 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ Using scanf() with semihost","title":"Build and Debug"},{"location":"posts/stm32/semihost/#note","text":"Applications built with semihosting output active normally cannot be executed without the debugger connected and active, since they use BKPT to communicate with the host. However, with a carefully written HardFault_Handler() , the semihosting BKPT calls can be processed, making possible to run semihosting applications as standalone, without being terminated with hardware faults.","title":"Note"},{"location":"posts/stm32/toolchain/","text":"ARM Toolchain & Makefile \u2693\ufe0e Toolchain \u2693\ufe0e Before you can start developing applications for the STM32 MCUs, you need a complete toolchain. A toolchain is a set of programs, compilers, and tools that allows you: to write down your code and to navigate inside source files of your application; to navigate inside the application code, allowing you to inspect variables, function definitions/declarations, and so on; to compile the source code using a cross-platform compiler; to upload and debug your application on the target board Example of a toolchain In the post Introduction to STM32 MCUs , you are guided to install STM32CubeIDE which actually is a complete toolchain for ST's STM32 MCUs. STM32CubeMX is used for Device Configuration and Code Generation Eclipse IDE is an source code editor and manager which supports many plugins in which we use C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build script GNU ARM Cross-compiler with ST patch for STM32 MCUs compiles our code to executable and linkable file (.elf) or binary file (.bin, .hex) STM32 Cube Programmer downloads our .elf or .bin file to the target MCU's flash ST-LINK GDB or ST-LINK openOCD debugger to proble our target MCUs What Is a Cross-Compiler? You usually refer to term compiler as a tool able to generate machine code for the processor in our PC. A compiler is just a \u201clanguage translator\u201d from a given programming language (C in our case) to a low-level machine language, also known as assembly . For example, if you are working on Intel x86 machine, you use a compiler to generate x86 assembly code from the C programming language. For the sake of completeness, you have to say that nowadays a compiler is a more complex tool that addresses both the specific target hardware processor and the Operating System you are using (e.g. Windows 7). A cross-platform compiler is a compiler able to generate machine code for a hardware machine different from the one you are using to develop our applications. In our a case, the GCC ARM Embedded compiler generates machine code for Cortex-M processors while compiling on an x86 machine with a given OS (e.g. Windows or Mac OSX). Example of Cross-Compiler for MIPS on Linux GNU ARM Embedded Toolchain \u2693\ufe0e In this section, you will know how to install a general GNU ARM Toolchain for Windows machines and use it to compile a simple program for STM32 MCUs. Download the latest GNU ARM Embedded Toolchain from the official ARM site, such as gcc-arm-none-eabi-9-2020-q2-update-win32.exe and start to install. Please note that we must select GNU-RM version for ARM Cortext-M processors. Install GNU ARM Toolchain You should add GNU into the system PATH to use GCC tools directly in termial without the need of changing the current working directory to the GNU installation folder. To test GNU CC for ARM, you can try to compile a simple program in C: main.c void main ( void ) { }","title":"ARM Toolchain & Makefile"},{"location":"posts/stm32/toolchain/#arm-toolchain--makefile","text":"","title":"ARM Toolchain &amp; Makefile"},{"location":"posts/stm32/toolchain/#toolchain","text":"Before you can start developing applications for the STM32 MCUs, you need a complete toolchain. A toolchain is a set of programs, compilers, and tools that allows you: to write down your code and to navigate inside source files of your application; to navigate inside the application code, allowing you to inspect variables, function definitions/declarations, and so on; to compile the source code using a cross-platform compiler; to upload and debug your application on the target board Example of a toolchain In the post Introduction to STM32 MCUs , you are guided to install STM32CubeIDE which actually is a complete toolchain for ST's STM32 MCUs. STM32CubeMX is used for Device Configuration and Code Generation Eclipse IDE is an source code editor and manager which supports many plugins in which we use C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build script GNU ARM Cross-compiler with ST patch for STM32 MCUs compiles our code to executable and linkable file (.elf) or binary file (.bin, .hex) STM32 Cube Programmer downloads our .elf or .bin file to the target MCU's flash ST-LINK GDB or ST-LINK openOCD debugger to proble our target MCUs What Is a Cross-Compiler? You usually refer to term compiler as a tool able to generate machine code for the processor in our PC. A compiler is just a \u201clanguage translator\u201d from a given programming language (C in our case) to a low-level machine language, also known as assembly . For example, if you are working on Intel x86 machine, you use a compiler to generate x86 assembly code from the C programming language. For the sake of completeness, you have to say that nowadays a compiler is a more complex tool that addresses both the specific target hardware processor and the Operating System you are using (e.g. Windows 7). A cross-platform compiler is a compiler able to generate machine code for a hardware machine different from the one you are using to develop our applications. In our a case, the GCC ARM Embedded compiler generates machine code for Cortex-M processors while compiling on an x86 machine with a given OS (e.g. Windows or Mac OSX). Example of Cross-Compiler for MIPS on Linux","title":"Toolchain"},{"location":"posts/stm32/toolchain/#gnu-arm-embedded-toolchain","text":"In this section, you will know how to install a general GNU ARM Toolchain for Windows machines and use it to compile a simple program for STM32 MCUs. Download the latest GNU ARM Embedded Toolchain from the official ARM site, such as gcc-arm-none-eabi-9-2020-q2-update-win32.exe and start to install. Please note that we must select GNU-RM version for ARM Cortext-M processors. Install GNU ARM Toolchain You should add GNU into the system PATH to use GCC tools directly in termial without the need of changing the current working directory to the GNU installation folder. To test GNU CC for ARM, you can try to compile a simple program in C: main.c void main ( void ) { }","title":"GNU ARM Embedded Toolchain"}]}