{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Code Inside Out \u2693\ufe0e Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89\u25d5\u30ee\u25d5)\uff89*:\u30fb\uff9f\u2727 .welcome { padding-left: .1em; margin-bottom: 0 } .site-name { margin-bottom: .5em !important; color: orangered !important; } .site-description { font-size: large; padding-left: .05em; margin-bottom: 0; } .md-typeset .md-button { font-size: unset; min-width: 3em; text-align: center; padding: .3em 0 0 0; border-radius: .5em; border: 1px solid lightgray; color: unset; }","title":"Home"},{"location":"#code-inside-out","text":"Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89\u25d5\u30ee\u25d5)\uff89*:\u30fb\uff9f\u2727 .welcome { padding-left: .1em; margin-bottom: 0 } .site-name { margin-bottom: .5em !important; color: orangered !important; } .site-description { font-size: large; padding-left: .05em; margin-bottom: 0; } .md-typeset .md-button { font-size: unset; min-width: 3em; text-align: center; padding: .3em 0 0 0; border-radius: .5em; border: 1px solid lightgray; color: unset; }","title":"Code Inside Out"},{"location":"blog/","text":"Blog \u2693\ufe0e","title":"Recent posts"},{"location":"blog/#blog","text":"","title":"Blog"},{"location":"blog/c_cpp/notes/","text":"Do not use sizeof for array parameters \u2693\ufe0e The function fun() receives an array parameter arr[] and tries to find out number of elements in arr[] using sizeof operator. In main, there is also a statement calculating the number of elements in arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) { // ??? } } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which results in 1 .","title":"Notes"},{"location":"blog/c_cpp/notes/#do-not-use-sizeof-for-array-parameters","text":"The function fun() receives an array parameter arr[] and tries to find out number of elements in arr[] using sizeof operator. In main, there is also a statement calculating the number of elements in arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) { // ??? } } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which results in 1 .","title":"Do not use sizeof for array parameters"},{"location":"blog/pi/backup_sdcard/","text":"1. Win32 Disk Imager \u2693\ufe0e Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. Then the size of the backup file is equal to the device total size. This method will take long time to complete, depending on the size of the device. Download it from win32diskimager and install it. 1.1. Backup \u2693\ufe0e Select the Image File to save the SDCard content Select the source Device Click on Read Win32 Disk Imager: save device to image 1.2. Restore \u2693\ufe0e Select the Image File of the SDCard content Select the target Device Click on Write Win32 Disk Imager: restore from image to device 2. Acronis True Image \u2693\ufe0e This application is a commercial product, try it for free at Acronis Quick backup & Incremental mode Acronis does not backup empty space on the SDCard, it only saves useful data, therefore the backup progress is much faster and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. Acronis True Image: backup/restore disk","title":"Backup SDCard"},{"location":"blog/pi/backup_sdcard/#1-win32-disk-imager","text":"Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. Then the size of the backup file is equal to the device total size. This method will take long time to complete, depending on the size of the device. Download it from win32diskimager and install it.","title":"1. Win32 Disk Imager"},{"location":"blog/pi/backup_sdcard/#11-backup","text":"Select the Image File to save the SDCard content Select the source Device Click on Read Win32 Disk Imager: save device to image","title":"1.1. Backup"},{"location":"blog/pi/backup_sdcard/#12-restore","text":"Select the Image File of the SDCard content Select the target Device Click on Write Win32 Disk Imager: restore from image to device","title":"1.2. Restore"},{"location":"blog/pi/backup_sdcard/#2-acronis-true-image","text":"This application is a commercial product, try it for free at Acronis Quick backup & Incremental mode Acronis does not backup empty space on the SDCard, it only saves useful data, therefore the backup progress is much faster and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. Acronis True Image: backup/restore disk","title":"2. Acronis True Image"},{"location":"blog/pi/check_camera_i2c/","text":"Camera I2C Address responses Scan on I2C Bus 0, the camera module will response on two addresses 0x10 (camera sensor) and 0x64 (camera board). Missing one of two above addresses means that there is an issue happened. 1. Hardware check \u2693\ufe0e Run the command: vcgencmd get_camera which should print out supported=1 detected=1 with a working camera. If the output shows detected=0 , check the ribbon cable first. If other camera still works after swapping the camera module, then do a software check. 2. Software check \u2693\ufe0e An interesting topic: Camera not detected despite being plugged in on official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on a I2C interface. 2.1. Install I2C tools \u2693\ufe0e Install i2c-tools : sudo apt-get install i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect detect I2C chips i2cdump examine I2C registers i2cget read from I2C/SMBus chip registers i2cset set I2C registers i2ctransfer send user-defined I2C messages in one transfer 2.2. Load I2C driver \u2693\ufe0e Permanently enable I2C interface by running sudo raspi-config or adding i2c-dev to /etc/modules : Enable I2C Interface via raspi-config Or just load driver temporarily for a quick check: sudo modprobe i2c-dev 2.3. Config GPIOs \u2693\ufe0e GPIO pin number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh 2.4. Scan I2C bus \u2693\ufe0e Run i2cdetect on I2C BUS0 at /dev/i2c-0 : i2cdetect 0 press Y to continue and it should print out: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera's I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and connectors. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection.","title":"Diagnostic Camera"},{"location":"blog/pi/check_camera_i2c/#1-hardware-check","text":"Run the command: vcgencmd get_camera which should print out supported=1 detected=1 with a working camera. If the output shows detected=0 , check the ribbon cable first. If other camera still works after swapping the camera module, then do a software check.","title":"1. Hardware check"},{"location":"blog/pi/check_camera_i2c/#2-software-check","text":"An interesting topic: Camera not detected despite being plugged in on official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on a I2C interface.","title":"2. Software check"},{"location":"blog/pi/check_camera_i2c/#21-install-i2c-tools","text":"Install i2c-tools : sudo apt-get install i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect detect I2C chips i2cdump examine I2C registers i2cget read from I2C/SMBus chip registers i2cset set I2C registers i2ctransfer send user-defined I2C messages in one transfer","title":"2.1. Install I2C tools"},{"location":"blog/pi/check_camera_i2c/#22-load-i2c-driver","text":"Permanently enable I2C interface by running sudo raspi-config or adding i2c-dev to /etc/modules : Enable I2C Interface via raspi-config Or just load driver temporarily for a quick check: sudo modprobe i2c-dev","title":"2.2. Load I2C driver"},{"location":"blog/pi/check_camera_i2c/#23-config-gpios","text":"GPIO pin number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh","title":"2.3. Config GPIOs"},{"location":"blog/pi/check_camera_i2c/#24-scan-i2c-bus","text":"Run i2cdetect on I2C BUS0 at /dev/i2c-0 : i2cdetect 0 press Y to continue and it should print out: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera's I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and connectors. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection.","title":"2.4. Scan I2C bus"},{"location":"blog/pi/compile_ffmpeg/","text":"Pre-built FFmpeg in Raspbian OS The FFmpeg package in Raspbian OS is built with H264 Hardware Acceleration already, just need to download it from the package manager: sudo apt install ffmpeg -y 1. pi_streaming_setup script \u2693\ufe0e Thank cdgriffith for this awesome script\" There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a raspberry pi with a compatible camera into a MPEG-DASH / HLS streaming server . The steps it will attempt to take: Install FFmpeg OR (optional) Compile and Install FFmpeg ( with h264 hardware acceleration and free libraries) Install NGINX for DASH / HLS OR install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile ffmpeg, just need 2 options: --compile-ffmpeg --compile-only 2. Compile FFmpeg \u2693\ufe0e Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from github: git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script's folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow RPi, such as Pi Zero. 3. Test compiled FFmpeg \u2693\ufe0e After the compilation finishes, reboot the Pi, and when it's booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"Compile FFmpeg"},{"location":"blog/pi/compile_ffmpeg/#1-pi_streaming_setup-script","text":"Thank cdgriffith for this awesome script\" There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a raspberry pi with a compatible camera into a MPEG-DASH / HLS streaming server . The steps it will attempt to take: Install FFmpeg OR (optional) Compile and Install FFmpeg ( with h264 hardware acceleration and free libraries) Install NGINX for DASH / HLS OR install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile ffmpeg, just need 2 options: --compile-ffmpeg --compile-only","title":"1. pi_streaming_setup script"},{"location":"blog/pi/compile_ffmpeg/#2-compile-ffmpeg","text":"Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from github: git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script's folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow RPi, such as Pi Zero.","title":"2. Compile FFmpeg"},{"location":"blog/pi/compile_ffmpeg/#3-test-compiled-ffmpeg","text":"After the compilation finishes, reboot the Pi, and when it's booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"3. Test compiled FFmpeg"},{"location":"blog/pi/notes/","text":"Search 1 for a package distributed by Debian: Search 1. Utilities \u2693\ufe0e 1.1. Terminal multiplexer \u2693\ufe0e screen is a terminal multiplexer program that allows managing several Terminal sessions from with the single window. Start a new session and detach it to leave it running in background even the terminal is ended (like disconnected ssh session), then resume that session later. Similar to tmux 1.2. CPU Usage \u2693\ufe0e top shows the average CPU Usage in an interval of time, such as 1 second. ps shows the average CPU Usage of a process from when it has started. tload shows the CPU Usage history in simple graph in terminal. 2. Python packages \u2693\ufe0e Most packages can be installed using sudo apt-get install followed by python-<packagename> (for Python2) or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install python-pip python3-pip Then install the target package. For example: sudo apt install python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package pip3 install ws4py Add a form in markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" > < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"Notes"},{"location":"blog/pi/notes/#1-utilities","text":"","title":"1. Utilities"},{"location":"blog/pi/notes/#11-terminal-multiplexer","text":"screen is a terminal multiplexer program that allows managing several Terminal sessions from with the single window. Start a new session and detach it to leave it running in background even the terminal is ended (like disconnected ssh session), then resume that session later. Similar to tmux","title":"1.1. Terminal multiplexer"},{"location":"blog/pi/notes/#12-cpu-usage","text":"top shows the average CPU Usage in an interval of time, such as 1 second. ps shows the average CPU Usage of a process from when it has started. tload shows the CPU Usage history in simple graph in terminal.","title":"1.2. CPU Usage"},{"location":"blog/pi/notes/#2-python-packages","text":"Most packages can be installed using sudo apt-get install followed by python-<packagename> (for Python2) or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install python-pip python3-pip Then install the target package. For example: sudo apt install python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package pip3 install ws4py Add a form in markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" > < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"2. Python packages"},{"location":"blog/pi/resource_usage/","text":"The final monitor.sh Download monitor.sh then save to ~/monitor.sh . Add below line to ~/.bashrc : source monitor.sh Usage: monitor title command params This post is written as a walk through guide to help understanding how the script is made. 1. Export a function in bash \u2693\ufe0e In a bash file, define a function with a name and its body, then export the function with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"Params: $@ \" } export -f myfunc To make function available outside of the script, run source command before calling the function: source myfunc.sh myfunc abc All params are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $FUNCNAME Name of the current function, effective inside a function only $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th param $# The number of command-line arguments $* All of the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself 2. Command-Grouping \u2693\ufe0e Refer to Bash Manual - Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters. The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace. 3. Run a process \u2693\ufe0e The basic idea is to run a process in background and while it's running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor 4. ps or top \u2693\ufe0e Both ps and top report CPU Usage, but returned values are different. Let's check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU -- CPU Usage, The task's share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let's check top 's options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n' command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one's personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 ... or -pN1,N2,N3 ... Monitor only processes with specified process IDs. Switch to use top get the the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg 5. grep and awk \u2693\ufe0e Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline. 6. Line buffered mode \u2693\ufe0e When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered but block buffered, usually the block is 4KB,leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive sets un-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4 7. Save log with tee \u2693\ufe0e Use tee to read from standard input and write to standard output and files. That is simple enough to clone the output to a file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are too issues happened: an empty log.txt file usage.txt content is invalid 7.1. Fix empty log \u2693\ufe0e When making pipeline to tee , only STDOUT (1) is forwarded, while ffmpeg prints output on STDERR (2) not on STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt & 7.2. Fix wrong data \u2693\ufe0e Add some debug lines ps -p $pid to check the process ID after creating the process: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee's PID will be saved in the macro $! . The solution is to save the pid in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top 8. Graph with gnuplot \u2693\ufe0e Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many different types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage 9. Command template \u2693\ufe0e Let's modify the script to accept params in this format: monitor title command by extracting those params at the beginning of the script: monitor () ( # extract params title = $1 command = ${ @: 2 } # get params from the 2nd one 10. Some enhanced modifications \u2693\ufe0e Save output to a separated folder: # create result folder if not existed [ ! -d $title ] && mkdir $title Change output format to CPU= X MEM= Y then change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \" 11. The final script \u2693\ufe0e monitor.sh #!/bin/bash # vuquangtrong@gmail.com # # usage: # monitor title command params # example # monitor test ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 # monitor () ( # extract params title = $1 command = ${ @: 2 } # get command and params from the 2nd one # create result folder if not existed [ ! -d $title ] && mkdir $title # measure execution time start = $SECONDS # run command in background ( $command 2 > & 1 & echo $! > pid.txt ) | tee \" ${ title } / ${ title } _log.txt\" & sleep 1 # get command's PID of last job in background pid = $( <pid.txt ) # use top to monitor the process # use grep to catch useful lines, using line buffered mode to send output in lines # use awk to extract data columns, reading input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) \\ | grep --line-buffered $pid \\ | awk -W interactive '{printf \"\\nCPU= %d MEM= %d\\n\", $9, $10}' \\ | tee > ( grep CPU > \" ${ title } / ${ title } _usage.txt\" ) & sleep 1 # save top's PID to control it toppid = $( <pid.txt ) # check if the command is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt # output average data, exclude sleeping time echo -e \"\\nTotal time: $(( $SECONDS - $start - 3 )) seconds\" cat \" ${ title } / ${ title } _usage.txt\" \\ | awk '\\ { sum1 += $2; sum2 += $4; n++} \\ END { printf \"Average: CPU= %d MEM= %d\\n\", sum1/n, sum2/n} \\ ' # draw to terminal gnuplot -e \" \\ set term dumb; \\ set yrange [0:100]; \\ plot \\ ' ${ title } / ${ title } _usage.txt' using 2 title 'CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \" # export to image gnuplot -e \" \\ set term png size 640, 480; \\ set output ' ${ title } / ${ title } _usage.png'; \\ set yrange [0:100]; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ ' ${ title } / ${ title } _usage.txt' using 2 title 'CPU' with lines lw 2, \\ '' using 4 title 'MEM' with lines lw 2 \\ \" ) export -f monitor","title":"Resource usage"},{"location":"blog/pi/resource_usage/#1-export-a-function-in-bash","text":"In a bash file, define a function with a name and its body, then export the function with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"Params: $@ \" } export -f myfunc To make function available outside of the script, run source command before calling the function: source myfunc.sh myfunc abc All params are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $FUNCNAME Name of the current function, effective inside a function only $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th param $# The number of command-line arguments $* All of the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself","title":"1. Export a function in bash"},{"location":"blog/pi/resource_usage/#2-command-grouping","text":"Refer to Bash Manual - Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters. The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace.","title":"2. Command-Grouping"},{"location":"blog/pi/resource_usage/#3-run-a-process","text":"The basic idea is to run a process in background and while it's running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor","title":"3. Run a process"},{"location":"blog/pi/resource_usage/#4-ps-or-top","text":"Both ps and top report CPU Usage, but returned values are different. Let's check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU -- CPU Usage, The task's share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let's check top 's options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n' command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one's personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 ... or -pN1,N2,N3 ... Monitor only processes with specified process IDs. Switch to use top get the the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg","title":"4. ps or top"},{"location":"blog/pi/resource_usage/#5-grep-and-awk","text":"Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline.","title":"5. grep and awk"},{"location":"blog/pi/resource_usage/#6-line-buffered-mode","text":"When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered but block buffered, usually the block is 4KB,leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive sets un-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4","title":"6. Line buffered mode"},{"location":"blog/pi/resource_usage/#7-save-log-with-tee","text":"Use tee to read from standard input and write to standard output and files. That is simple enough to clone the output to a file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are too issues happened: an empty log.txt file usage.txt content is invalid","title":"7. Save log with tee"},{"location":"blog/pi/resource_usage/#71-fix-empty-log","text":"When making pipeline to tee , only STDOUT (1) is forwarded, while ffmpeg prints output on STDERR (2) not on STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt &","title":"7.1. Fix empty log"},{"location":"blog/pi/resource_usage/#72-fix-wrong-data","text":"Add some debug lines ps -p $pid to check the process ID after creating the process: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee's PID will be saved in the macro $! . The solution is to save the pid in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top","title":"7.2. Fix wrong data"},{"location":"blog/pi/resource_usage/#8-graph-with-gnuplot","text":"Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many different types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage","title":"8. Graph with gnuplot"},{"location":"blog/pi/resource_usage/#9-command-template","text":"Let's modify the script to accept params in this format: monitor title command by extracting those params at the beginning of the script: monitor () ( # extract params title = $1 command = ${ @: 2 } # get params from the 2nd one","title":"9. Command template"},{"location":"blog/pi/resource_usage/#10-some-enhanced-modifications","text":"Save output to a separated folder: # create result folder if not existed [ ! -d $title ] && mkdir $title Change output format to CPU= X MEM= Y then change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \"","title":"10. Some enhanced modifications"},{"location":"blog/pi/resource_usage/#11-the-final-script","text":"monitor.sh #!/bin/bash # vuquangtrong@gmail.com # # usage: # monitor title command params # example # monitor test ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 # monitor () ( # extract params title = $1 command = ${ @: 2 } # get command and params from the 2nd one # create result folder if not existed [ ! -d $title ] && mkdir $title # measure execution time start = $SECONDS # run command in background ( $command 2 > & 1 & echo $! > pid.txt ) | tee \" ${ title } / ${ title } _log.txt\" & sleep 1 # get command's PID of last job in background pid = $( <pid.txt ) # use top to monitor the process # use grep to catch useful lines, using line buffered mode to send output in lines # use awk to extract data columns, reading input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) \\ | grep --line-buffered $pid \\ | awk -W interactive '{printf \"\\nCPU= %d MEM= %d\\n\", $9, $10}' \\ | tee > ( grep CPU > \" ${ title } / ${ title } _usage.txt\" ) & sleep 1 # save top's PID to control it toppid = $( <pid.txt ) # check if the command is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt # output average data, exclude sleeping time echo -e \"\\nTotal time: $(( $SECONDS - $start - 3 )) seconds\" cat \" ${ title } / ${ title } _usage.txt\" \\ | awk '\\ { sum1 += $2; sum2 += $4; n++} \\ END { printf \"Average: CPU= %d MEM= %d\\n\", sum1/n, sum2/n} \\ ' # draw to terminal gnuplot -e \" \\ set term dumb; \\ set yrange [0:100]; \\ plot \\ ' ${ title } / ${ title } _usage.txt' using 2 title 'CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \" # export to image gnuplot -e \" \\ set term png size 640, 480; \\ set output ' ${ title } / ${ title } _usage.png'; \\ set yrange [0:100]; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ ' ${ title } / ${ title } _usage.txt' using 2 title 'CPU' with lines lw 2, \\ '' using 4 title 'MEM' with lines lw 2 \\ \" ) export -f monitor","title":"11. The final script"},{"location":"blog/pi/save_power/","text":"1. Turn off USB \u2693\ufe0e Turn OFF the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind 2. Turn off HDMI \u2693\ufe0e Turn OFF the HDMI output: sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p 3. Throttle CPU \u2693\ufe0e Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0 4. Disable Wi-Fi & Bluetooth \u2693\ufe0e Starting from Raspberry Pi 3, Wifi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It's correct to use the word pi3 in the params's value, for other version of RPi. Soft-block The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background. 5. Disable on-board LEDs \u2693\ufe0e Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on","title":"Save Power"},{"location":"blog/pi/save_power/#1-turn-off-usb","text":"Turn OFF the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind","title":"1. Turn off USB"},{"location":"blog/pi/save_power/#2-turn-off-hdmi","text":"Turn OFF the HDMI output: sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p","title":"2. Turn off HDMI"},{"location":"blog/pi/save_power/#3-throttle-cpu","text":"Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0","title":"3. Throttle CPU"},{"location":"blog/pi/save_power/#4-disable-wi-fi--bluetooth","text":"Starting from Raspberry Pi 3, Wifi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It's correct to use the word pi3 in the params's value, for other version of RPi. Soft-block The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background.","title":"4. Disable Wi-Fi &amp; Bluetooth"},{"location":"blog/pi/save_power/#5-disable-on-board-leds","text":"Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on","title":"5. Disable on-board LEDs"},{"location":"blog/pi/setup_camera/","text":"RaspberryPi Camera Module This tutorial is for setting up the official Raspberry Pi Camera which is attached with a CSI cable. Other types of USB Camera should work on RPi out-of-the-box. 1. Enable Camera module \u2693\ufe0e Run raspi-config configuration tool: sudo raspi-config Select Interfacing Options > Camera > Yes . This method does the same thing with setting up start_x = 1 in /boot/config.txt . raspi-config raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in RPi OS. This tool requires root permission, therefore, it must be run with sudo . User interface of raspi-config 2. Increase GPU memory \u2693\ufe0e In the raspi-config configuration tool, Go to Performance Options > GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem = 256 in /boot/config.txt . 3. Test Camera \u2693\ufe0e Detect the camera connection by running the checking tool: vcgencmd get_camera which should print out supported = 1 detected=1 telling that the camera is supported and connected. vcgencmd vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record an video: raspivid -o vid.h264 4. Video for Linux 2 - V4L2 \u2693\ufe0e Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written an user space V4L driver for the Raspberry Pi camera but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included in to Raspbian OS by default. Use v4l2-ctl utility tool to capture from the camera. 4.1. List devices \u2693\ufe0e v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0 4.2. Driver info \u2693\ufe0e v4l2-ctl -d /dev/video0 --all 4.3. Supported formats \u2693\ufe0e v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly. 4.4. Capture JPEG Image \u2693\ufe0e v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg 4.5. Record H264 Video \u2693\ufe0e Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264 5. FFmpeg \u2693\ufe0e The pre-built ffmpeg package of RPi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y Compile FFmpeg An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator . 5.1. Encoders \u2693\ufe0e To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . For example: ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V...... 5.2. Performance \u2693\ufe0e Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor - Script to check performance . Video settings Video side: 1024x768 Framerate: 30 fps Input Length: 60 seconds Note that ffmpeg uses v4l2 driver! 5.2.1. Raw to MJPEG (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average CPU: 93 (too high) Average MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG 5.2.2. Raw to H264_OMX @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average CPU: 16 (OK) Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps 5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average CPU: 23 Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps 5.2.4. V4L2 MJPEG direct copy (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG strem 5.2.5. V4L2 H264 direct copy (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream After above tests, it says that using compressed input format from v4l2 is much more effective than compressing by an software encoder. Let's add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4 6. Install picamera \u2693\ufe0e The picamera package is a pure Python interface to the Raspberry Pi camera module for Python. Homepage is at https://picamera.readthedocs.io/en/latest/install.html . If using the Raspbian distro, probably it has picamera installed by default. Run a test: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of example in the official guide of Picamera at https://picamera.readthedocs.io/en/latest/recipes1.html . Get maximum resolution of the camera: import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot: from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for testing. record a 60-second video from camera and measure resource usage with monitor , then use ffmpeg to convert raw h264 to mp4: 6.1. Picamera H264 (.h264) \u2693\ufe0e from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) Picamera 6.2. Picamera H264 (.h264) with Text overlay \u2693\ufe0e Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime # macro TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive CPU and MEM usage, comparing to using FFmpeg. The result shows that the CPU uses twice as much as it does in non-overlay text, while the MEM keeps the same percentage.","title":"Setup Camera"},{"location":"blog/pi/setup_camera/#1-enable-camera-module","text":"Run raspi-config configuration tool: sudo raspi-config Select Interfacing Options > Camera > Yes . This method does the same thing with setting up start_x = 1 in /boot/config.txt . raspi-config raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in RPi OS. This tool requires root permission, therefore, it must be run with sudo . User interface of raspi-config","title":"1. Enable Camera module"},{"location":"blog/pi/setup_camera/#2-increase-gpu-memory","text":"In the raspi-config configuration tool, Go to Performance Options > GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem = 256 in /boot/config.txt .","title":"2. Increase GPU memory"},{"location":"blog/pi/setup_camera/#3-test-camera","text":"Detect the camera connection by running the checking tool: vcgencmd get_camera which should print out supported = 1 detected=1 telling that the camera is supported and connected. vcgencmd vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record an video: raspivid -o vid.h264","title":"3. Test Camera"},{"location":"blog/pi/setup_camera/#4-video-for-linux-2---v4l2","text":"Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written an user space V4L driver for the Raspberry Pi camera but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included in to Raspbian OS by default. Use v4l2-ctl utility tool to capture from the camera.","title":"4. Video for Linux 2 - V4L2"},{"location":"blog/pi/setup_camera/#41-list-devices","text":"v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0","title":"4.1. List devices"},{"location":"blog/pi/setup_camera/#42-driver-info","text":"v4l2-ctl -d /dev/video0 --all","title":"4.2. Driver info"},{"location":"blog/pi/setup_camera/#43-supported-formats","text":"v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly.","title":"4.3. Supported formats"},{"location":"blog/pi/setup_camera/#44-capture-jpeg-image","text":"v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg","title":"4.4. Capture JPEG Image"},{"location":"blog/pi/setup_camera/#45-record-h264-video","text":"Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264","title":"4.5. Record H264 Video"},{"location":"blog/pi/setup_camera/#5-ffmpeg","text":"The pre-built ffmpeg package of RPi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y Compile FFmpeg An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator .","title":"5. FFmpeg"},{"location":"blog/pi/setup_camera/#51-encoders","text":"To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . For example: ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V......","title":"5.1. Encoders"},{"location":"blog/pi/setup_camera/#52--performance","text":"Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor - Script to check performance . Video settings Video side: 1024x768 Framerate: 30 fps Input Length: 60 seconds Note that ffmpeg uses v4l2 driver!","title":"5.2.  Performance"},{"location":"blog/pi/setup_camera/#521-raw-to-mjpeg-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average CPU: 93 (too high) Average MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG","title":"5.2.1. Raw to MJPEG (.avi)"},{"location":"blog/pi/setup_camera/#522-raw-to-h264_omx-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average CPU: 16 (OK) Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps","title":"5.2.2. Raw to H264_OMX @8Mbps (.mp4)"},{"location":"blog/pi/setup_camera/#523-raw-to-h264_v4l2m2m-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average CPU: 23 Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps","title":"5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4)"},{"location":"blog/pi/setup_camera/#524-v4l2-mjpeg-direct-copy-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG strem","title":"5.2.4. V4L2 MJPEG direct copy (.avi)"},{"location":"blog/pi/setup_camera/#525-v4l2-h264-direct-copy-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream After above tests, it says that using compressed input format from v4l2 is much more effective than compressing by an software encoder. Let's add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4","title":"5.2.5. V4L2 H264 direct copy (.mp4)"},{"location":"blog/pi/setup_camera/#6-install-picamera","text":"The picamera package is a pure Python interface to the Raspberry Pi camera module for Python. Homepage is at https://picamera.readthedocs.io/en/latest/install.html . If using the Raspbian distro, probably it has picamera installed by default. Run a test: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of example in the official guide of Picamera at https://picamera.readthedocs.io/en/latest/recipes1.html . Get maximum resolution of the camera: import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot: from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for testing. record a 60-second video from camera and measure resource usage with monitor , then use ffmpeg to convert raw h264 to mp4:","title":"6. Install picamera"},{"location":"blog/pi/setup_camera/#61-picamera-h264-h264","text":"from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) Picamera","title":"6.1. Picamera H264 (.h264)"},{"location":"blog/pi/setup_camera/#62-picamera-h264-h264-with-text-overlay","text":"Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime # macro TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive CPU and MEM usage, comparing to using FFmpeg. The result shows that the CPU uses twice as much as it does in non-overlay text, while the MEM keeps the same percentage.","title":"6.2. Picamera H264 (.h264) with Text overlay"},{"location":"blog/pi/setup_headless/","text":"1. Download OS Image \u2693\ufe0e Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please follow the guide in the official download page. 2. Burn Image to SDCard \u2693\ufe0e The application balenaEtcher from Balena is a very good image writer that will write OS image to SDCard. Download and install it, then run it. Just follow the guided steps. Etcher is writing OS image After copying the image to a SDCard, File Explorer may have trouble seeing the content of that SDCard. A simple fix is to pull the SDCard out then plug it back in. It should appear with a partition named boot . 3. Enable SSH \u2693\ufe0e For security reasons, ssh is no longer enabled by default. To enable it, place a blank text file called ssh in the root of the boot partition on the SDCard. 4. Add Wifi Network Info \u2693\ufe0e To add network info, create a text file called wpa_supplicant.conf and place that in the root of the boot partition on SDCard too. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } Added ssh and wpa_supplicant.conf in boot partition 5. Login to RPi \u2693\ufe0e Power RPi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the RPi. A plugin on MobaXterm can be used too. Scan for RPi IP For the official Raspberry Pi OS, the default user name is pi , with password raspberry , on the host raspberrypi . Login on ssh to RPi Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan To edit or review the wifi settings, run this command: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Connect to an other Wifi network Open the wpa-supplicant configuration file in nano: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0 6. Update system \u2693\ufe0e (optional) To get the latest version of RPi OS and its packages, please update the system by entering below commands: sudo apt-get update sudo apt-get upgrade -y 7. Expand Filesystem \u2693\ufe0e (optional) To use all of available space on the SDCard, expand the filesystem by running: sudo raspi-config Select Advanced Options > Expand Filesystem Then reboot the system. 8. Others \u2693\ufe0e (optional) Please read the Save Power post. Show who is logged on and what they are doing Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w pi pts/1 fe80::1936:b4d4: 06 :34 2 :18m 0 .74s 0 .74s -bash","title":"Headless mode"},{"location":"blog/pi/setup_headless/#1-download-os-image","text":"Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please follow the guide in the official download page.","title":"1. Download OS Image"},{"location":"blog/pi/setup_headless/#2-burn-image-to-sdcard","text":"The application balenaEtcher from Balena is a very good image writer that will write OS image to SDCard. Download and install it, then run it. Just follow the guided steps. Etcher is writing OS image After copying the image to a SDCard, File Explorer may have trouble seeing the content of that SDCard. A simple fix is to pull the SDCard out then plug it back in. It should appear with a partition named boot .","title":"2. Burn Image to SDCard"},{"location":"blog/pi/setup_headless/#3-enable-ssh","text":"For security reasons, ssh is no longer enabled by default. To enable it, place a blank text file called ssh in the root of the boot partition on the SDCard.","title":"3. Enable SSH"},{"location":"blog/pi/setup_headless/#4-add-wifi-network-info","text":"To add network info, create a text file called wpa_supplicant.conf and place that in the root of the boot partition on SDCard too. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } Added ssh and wpa_supplicant.conf in boot partition","title":"4. Add Wifi Network Info"},{"location":"blog/pi/setup_headless/#5-login-to-rpi","text":"Power RPi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the RPi. A plugin on MobaXterm can be used too. Scan for RPi IP For the official Raspberry Pi OS, the default user name is pi , with password raspberry , on the host raspberrypi . Login on ssh to RPi Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan To edit or review the wifi settings, run this command: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Connect to an other Wifi network Open the wpa-supplicant configuration file in nano: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0","title":"5. Login to RPi"},{"location":"blog/pi/setup_headless/#6-update-system","text":"(optional) To get the latest version of RPi OS and its packages, please update the system by entering below commands: sudo apt-get update sudo apt-get upgrade -y","title":"6. Update system"},{"location":"blog/pi/setup_headless/#7-expand-filesystem","text":"(optional) To use all of available space on the SDCard, expand the filesystem by running: sudo raspi-config Select Advanced Options > Expand Filesystem Then reboot the system.","title":"7. Expand Filesystem"},{"location":"blog/pi/setup_headless/#8-others","text":"(optional) Please read the Save Power post. Show who is logged on and what they are doing Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w pi pts/1 fe80::1936:b4d4: 06 :34 2 :18m 0 .74s 0 .74s -bash","title":"8. Others"},{"location":"blog/pi/setup_wifi_ap/","text":"1. Update the system \u2693\ufe0e Ensure the system is at the latest version: sudo apt-get update sudo apt-get upgrade -y and then reboot. 2. Install necessary packages \u2693\ufe0e Next, in order to work as an access point, the Raspberry Pi needs to have the hostapd access point software package installed: sudo apt-get install hostapd Enable the wireless access point service and set it to start when the Raspberry Pi boots up: sudo systemctl unmask hostapd sudo systemctl enable hostapd In order to provide network management services (DNS, DHCP) to wireless clients, the Raspberry Pi needs to have the dnsmasq software package installed: sudo apt-get install dnsmasq Finally, install netfilter-persistent and its plugin iptables-persistent . This utility helps by saving firewall rules and restoring them when the Raspberry Pi boots: sudo DEBIAN_FRONTEND = noninteractive apt-get install -y netfilter-persistent iptables-persistent 3. Setup Wifi Interface IP \u2693\ufe0e The Raspberry Pi runs a DHCP server for the wireless network; this requires static IP configuration for the wireless interface ( wlan0 ) in the Raspberry Pi. The Raspberry Pi also acts as the router on the wireless network, and as is customary, set the first IP address in the network, e.g: 192.168.4.1 . sudo nano /etc/dhcpcd.conf Add below line to the file and save it: /etc/dhcpcd.conf interface wlan0 static ip_address = 192.168.4.1/24 nohook wpa_supplicant 4. Setup DHCP and DNS \u2693\ufe0e Rename the default configuration file and edit a new one: sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig sudo nano /etc/dnsmasq.conf Add the following to the file and save it: /etc/dnsmasq.conf # Listening interface interface = wlan0 # Pool of IP addresses served via DHCP dhcp-range = 192.168.4.2,192.168.4.20,255.255.255.0,24h # Local wireless DNS domain domain = wlan # Alias for this router address = /gw.wlan/192.168.4.1 The address range 192.168.4.2 ~ 192.168.4.20 is an example The Raspberry Pi will deliver IP addresses between 192.168.4.2 and 192.168.4.20 , with a lease time of 24 hours, to wireless DHCP clients. Raspberry Pi can be accessed under the name gw.wlan from wireless clients. 5. Turn on Wifi \u2693\ufe0e To ensure WiFi radio is not blocked on the Raspberry Pi, execute the following command: sudo rfkill unblock wlan 6. Setup Access Point \u2693\ufe0e Create the hostapd configuration file, located at /etc/hostapd/hostapd.conf , to add the various parameters for a new wireless network: sudo nano /etc/hostapd/hostapd.conf Add the information below to the configuration file. This configuration assumes to use channel 7 , with a network name of NameOfNetwork , and a password AardvarkBadgerHedgehog . Note that the name and password should not have quotes around them. The passphrase should be between 8 and 64 characters in length. /etc/hostapd/hostapd.conf country_code = US interface = wlan0 ssid = NameOfNetwork hw_mode = g channel = 7 macaddr_acl = 0 auth_algs = 1 ignore_broadcast_ssid = 0 wpa = 2 wpa_passphrase = AardvarkBadgerHedgehog wpa_key_mgmt = WPA-PSK wpa_pairwise = TKIP rsn_pairwise = CCMP Now restart the Raspberry Pi and verify that the wireless access point becomes automatically available. sudo systemctl reboot Once the Raspberry Pi has restarted, search for wireless networks with a wireless client. The network SSID specified in file /etc/hostapd/hostapd.conf should now be present, and it should be accessible with the specified password. If SSH is enabled on the Raspberry Pi, it should be possible to connect to it from a wireless client as follows, assuming the pi account is present: ssh pi@192.168.4.1 or ssh pi@gw.wlan .","title":"Wifi Access Point"},{"location":"blog/pi/setup_wifi_ap/#1-update-the-system","text":"Ensure the system is at the latest version: sudo apt-get update sudo apt-get upgrade -y and then reboot.","title":"1. Update the system"},{"location":"blog/pi/setup_wifi_ap/#2-install-necessary-packages","text":"Next, in order to work as an access point, the Raspberry Pi needs to have the hostapd access point software package installed: sudo apt-get install hostapd Enable the wireless access point service and set it to start when the Raspberry Pi boots up: sudo systemctl unmask hostapd sudo systemctl enable hostapd In order to provide network management services (DNS, DHCP) to wireless clients, the Raspberry Pi needs to have the dnsmasq software package installed: sudo apt-get install dnsmasq Finally, install netfilter-persistent and its plugin iptables-persistent . This utility helps by saving firewall rules and restoring them when the Raspberry Pi boots: sudo DEBIAN_FRONTEND = noninteractive apt-get install -y netfilter-persistent iptables-persistent","title":"2. Install necessary packages"},{"location":"blog/pi/setup_wifi_ap/#3-setup-wifi-interface-ip","text":"The Raspberry Pi runs a DHCP server for the wireless network; this requires static IP configuration for the wireless interface ( wlan0 ) in the Raspberry Pi. The Raspberry Pi also acts as the router on the wireless network, and as is customary, set the first IP address in the network, e.g: 192.168.4.1 . sudo nano /etc/dhcpcd.conf Add below line to the file and save it: /etc/dhcpcd.conf interface wlan0 static ip_address = 192.168.4.1/24 nohook wpa_supplicant","title":"3. Setup Wifi Interface IP"},{"location":"blog/pi/setup_wifi_ap/#4-setup-dhcp-and-dns","text":"Rename the default configuration file and edit a new one: sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig sudo nano /etc/dnsmasq.conf Add the following to the file and save it: /etc/dnsmasq.conf # Listening interface interface = wlan0 # Pool of IP addresses served via DHCP dhcp-range = 192.168.4.2,192.168.4.20,255.255.255.0,24h # Local wireless DNS domain domain = wlan # Alias for this router address = /gw.wlan/192.168.4.1 The address range 192.168.4.2 ~ 192.168.4.20 is an example The Raspberry Pi will deliver IP addresses between 192.168.4.2 and 192.168.4.20 , with a lease time of 24 hours, to wireless DHCP clients. Raspberry Pi can be accessed under the name gw.wlan from wireless clients.","title":"4. Setup DHCP and DNS"},{"location":"blog/pi/setup_wifi_ap/#5-turn-on-wifi","text":"To ensure WiFi radio is not blocked on the Raspberry Pi, execute the following command: sudo rfkill unblock wlan","title":"5. Turn on Wifi"},{"location":"blog/pi/setup_wifi_ap/#6-setup-access-point","text":"Create the hostapd configuration file, located at /etc/hostapd/hostapd.conf , to add the various parameters for a new wireless network: sudo nano /etc/hostapd/hostapd.conf Add the information below to the configuration file. This configuration assumes to use channel 7 , with a network name of NameOfNetwork , and a password AardvarkBadgerHedgehog . Note that the name and password should not have quotes around them. The passphrase should be between 8 and 64 characters in length. /etc/hostapd/hostapd.conf country_code = US interface = wlan0 ssid = NameOfNetwork hw_mode = g channel = 7 macaddr_acl = 0 auth_algs = 1 ignore_broadcast_ssid = 0 wpa = 2 wpa_passphrase = AardvarkBadgerHedgehog wpa_key_mgmt = WPA-PSK wpa_pairwise = TKIP rsn_pairwise = CCMP Now restart the Raspberry Pi and verify that the wireless access point becomes automatically available. sudo systemctl reboot Once the Raspberry Pi has restarted, search for wireless networks with a wireless client. The network SSID specified in file /etc/hostapd/hostapd.conf should now be present, and it should be accessible with the specified password. If SSH is enabled on the Raspberry Pi, it should be possible to connect to it from a wireless client as follows, assuming the pi account is present: ssh pi@192.168.4.1 or ssh pi@gw.wlan .","title":"6. Setup Access Point"},{"location":"blog/pi/stream_ffmpeg_hls_dash/","text":"Delay when streaming in HLS protocol Big Buck Bunny movie, \u00a9 2008, Blender Foundation / www.bigbuckbunny.org Download stream_ffmpeg_hls Delay in HLS streaming Source code available at https://github.com/vuquangtrong/pi_streaming 1. Install FFmpeg \u2693\ufe0e Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y or compile an executable file by following Compile FFmpeg manually guide. 2. HLS vs. MPEG-DASH \u2693\ufe0e A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol. 2.1. HLS \u2693\ufe0e HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bitrate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly. 2.2. MPEG-DASH \u2693\ufe0e As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bitrate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH. 3. Setup web server \u2693\ufe0e Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files. 3.1. Apache \u2693\ufe0e Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache's design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/index.html . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device's browsers. 3.2. NGINX \u2693\ufe0e NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX's design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html . Goto http://localhost/etc/nginx/sites-available to see the site's links. As the article Apache Vs NGINX \u2013 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests). 4. Stream live video \u2693\ufe0e MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SDCard, use RAM memory to write video chunks. When the number of chunks go high, clear old ones to get more space . Let's do it with HLS first! 4.1. Create video chunks \u2693\ufe0e Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8 4.2. Create HLS webpage \u2693\ufe0e A javascript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = utf-8 /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( 'video' ); var videoSrc = 'hls/live.m3u8' ; // First check for native browser HLS support if ( video . canPlayType ( 'application/vnd.apple.mpegurl' )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension. 4.3. Move to MPEG-DASH \u2693\ufe0e DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!doctype html> < html > < head > < meta charset = utf-8 /> < title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function (){ var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , } } }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later. 5. Python Web Server \u2693\ufe0e Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: var config = Hls . DefaultConfig ; config . liveSyncDurationCount = 1 ; config . startFragPrefetch = true ; console . log ( config ); var hls = new Hls ( config ); hls.js HLS Stream player written in Javascript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button: Download stream_ffmpeg_hls Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only. Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it's really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"HLS/DASH Streaming"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#1-install-ffmpeg","text":"Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y or compile an executable file by following Compile FFmpeg manually guide.","title":"1. Install FFmpeg"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#2-hls-vs-mpeg-dash","text":"A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol.","title":"2. HLS vs. MPEG-DASH"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#21-hls","text":"HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bitrate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly.","title":"2.1. HLS"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#22-mpeg-dash","text":"As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bitrate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH.","title":"2.2. MPEG-DASH"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#3-setup-web-server","text":"Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files.","title":"3. Setup web server"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#31-apache","text":"Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache's design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/index.html . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device's browsers.","title":"3.1. Apache"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#32-nginx","text":"NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX's design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html . Goto http://localhost/etc/nginx/sites-available to see the site's links. As the article Apache Vs NGINX \u2013 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests).","title":"3.2. NGINX"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#4-stream-live-video","text":"MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SDCard, use RAM memory to write video chunks. When the number of chunks go high, clear old ones to get more space . Let's do it with HLS first!","title":"4. Stream live video"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#41-create-video-chunks","text":"Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8","title":"4.1. Create video chunks"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#42-create-hls-webpage","text":"A javascript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = utf-8 /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( 'video' ); var videoSrc = 'hls/live.m3u8' ; // First check for native browser HLS support if ( video . canPlayType ( 'application/vnd.apple.mpegurl' )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension.","title":"4.2. Create HLS webpage"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#43-move-to-mpeg-dash","text":"DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!doctype html> < html > < head > < meta charset = utf-8 /> < title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function (){ var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , } } }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later.","title":"4.3. Move to MPEG-DASH"},{"location":"blog/pi/stream_ffmpeg_hls_dash/#5-python-web-server","text":"Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: var config = Hls . DefaultConfig ; config . liveSyncDurationCount = 1 ; config . startFragPrefetch = true ; console . log ( config ); var hls = new Hls ( config ); hls.js HLS Stream player written in Javascript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button: Download stream_ffmpeg_hls Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only. Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it's really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"5. Python Web Server"},{"location":"blog/pi/stream_picamera_h264/","text":"Low latency streaming using H264 format Big Buck Bunny movie, \u00a9 2008, Blender Foundation / www.bigbuckbunny.org Download stream_picamera_h264 Low latency in H264 streaming Source code available at https://github.com/vuquangtrong/pi_streaming An example of streaming real video (not frame by frame) is pistreaming which uses mpeg1video format. The video stream is sent to user's browser via a websocket , and is decoded by JSMPEG javascript library. 1. Broadway.js - H264 decoder \u2693\ufe0e The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , websocket , and Broadway.js . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (h264 frames), then transported using websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player's canvas to an element to display the video; and call decode function on the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > ); 2. Create a webpage \u2693\ufe0e The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html > 3. Create server \u2693\ufe0e Here is the structure of streaming system: graph LR subgraph RPi subgraph Server ws[WebSocket] i[index.html] --> h[HTTPServer] end Camera --> Picamera --> FrameBuffer --> ws end subgraph User[User's webpage] ws --> Decoder h --> w[Web View] YUVCanvas --> w subgraph bw[Broadway.js] Decoder --> Player --> YUVCanvas end end 3.1. Frame buffer \u2693\ufe0e The FrameBuffer is implemented as an output of Picamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all () 3.2. HTTP Server \u2693\ufe0e The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever ) 3.3. Websocket Server \u2693\ufe0e One of WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever ) 3.4. Main thread \u2693\ufe0e The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a Main Frame to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button: Download stream_picamera_h264","title":"H264 streaming"},{"location":"blog/pi/stream_picamera_h264/#1-broadwayjs---h264-decoder","text":"The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , websocket , and Broadway.js . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (h264 frames), then transported using websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player's canvas to an element to display the video; and call decode function on the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > );","title":"1. Broadway.js - H264 decoder"},{"location":"blog/pi/stream_picamera_h264/#2-create-a-webpage","text":"The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html >","title":"2. Create a webpage"},{"location":"blog/pi/stream_picamera_h264/#3-create-server","text":"Here is the structure of streaming system: graph LR subgraph RPi subgraph Server ws[WebSocket] i[index.html] --> h[HTTPServer] end Camera --> Picamera --> FrameBuffer --> ws end subgraph User[User's webpage] ws --> Decoder h --> w[Web View] YUVCanvas --> w subgraph bw[Broadway.js] Decoder --> Player --> YUVCanvas end end","title":"3. Create server"},{"location":"blog/pi/stream_picamera_h264/#31-frame-buffer","text":"The FrameBuffer is implemented as an output of Picamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all ()","title":"3.1. Frame buffer"},{"location":"blog/pi/stream_picamera_h264/#32-http-server","text":"The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever )","title":"3.2. HTTP Server"},{"location":"blog/pi/stream_picamera_h264/#33-websocket-server","text":"One of WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever )","title":"3.3. Websocket Server"},{"location":"blog/pi/stream_picamera_h264/#34-main-thread","text":"The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a Main Frame to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button: Download stream_picamera_h264","title":"3.4. Main thread"},{"location":"blog/pi/stream_picamera_mjpeg/","text":"Low latency streaming using MJPEG format Big Buck Bunny movie, \u00a9 2008, Blender Foundation / www.bigbuckbunny.org Download stream_picamera_mjpeg A low latency in MJPEG streaming Source code available at https://github.com/vuquangtrong/pi_streaming There are many choices to start streaming with MJPEG (MJPG) format. The basic method is to send a series of JPEG (JPG) image to the user's webpage and display it in an <img> tag. An example of streaming server is mjpg-streamer . This post shows a method to develop a streaming system, starting with a Python package named picamera . Setup PiCamera To setup picamera , please see more in Setup Camera Picamera has an example to stream MJPEG at Web streaming section. Just copy and run their code to see how it works. The basic structure of this streaming server is as below: graph LR subgraph RPi subgraph Server i[index.html] --> h[HTTPServer] end Camera --> Picamera --> FrameBuffer --> h end subgraph User[User's webpage] h --> w[Web View] end 1. Record video to a stream \u2693\ufe0e This is a basic step to write a video stream to a buffered memory. Python has io package which provides binary I/O which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'h264' , quality = 23 ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording () That's very easy. 2. Frame buffer \u2693\ufe0e Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs : A file-like object (as far as picamera is concerned) is simply an object with: a write(b) method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. a flush() method with no parameters, which will be called at the end of output. In write method, it can implement code that reacts to each and every frame. write method is called so frequently, its implementation must be sufficiently rapid that it doesn\u2019t stall the encoder. Let's write a class FrameBuffer() like below: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user's webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' ) 3. Streaming Web server \u2693\ufe0e Python has built-in a simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler ( request , client_address , server ) This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). BaseHTTPRequestHandler provides a number of class and instance variables, and methods for use by subclasses. The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler ( request , client_address , server , directory = None ) This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler ( request , client_address , server ) This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let's start with SimpleHTTPRequestHandler which has some implemented features. 4. Request Handler \u2693\ufe0e Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will looking for index.html for the homepage. To display image, create an <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web serve should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) read more at HTTP response status codes Send header with information to notify web client about type of responded content read more at Content-Type Send the content in a stream format (loop forever!): send content type of each frame, then send the actual frame data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating instances of FrameBuffer, PiCamera, HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is availabe. 5. Synchronize between threads \u2693\ufe0e Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming 6. Some updates in the script \u2693\ufe0e The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let's check how they work. 6.1. Class variable \u2693\ufe0e Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer 6.2. Instance variable \u2693\ufe0e Instance variables are for the data unique to each instance, they are create in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected params list to new params list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the param directory which is an optional param in original constructor of SimpleHTTPRequestHandler . To solve this problem, let's use special *args and **kwargs params. 6.3. *args and **kwargs \u2693\ufe0e The special *args and **kwargs params allow to pass multiple arguments or keyword arguments to a function. Read about them in here . So, change the param list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) 6.4. Lambda function \u2693\ufe0e Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args )) 6.5. Measure FPS \u2693\ufe0e In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button. Download stream_picamera_mjpeg","title":"MJPEG streaming"},{"location":"blog/pi/stream_picamera_mjpeg/#1-record-video-to-a-stream","text":"This is a basic step to write a video stream to a buffered memory. Python has io package which provides binary I/O which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'h264' , quality = 23 ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording () That's very easy.","title":"1. Record video to a stream"},{"location":"blog/pi/stream_picamera_mjpeg/#2-frame-buffer","text":"Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs : A file-like object (as far as picamera is concerned) is simply an object with: a write(b) method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. a flush() method with no parameters, which will be called at the end of output. In write method, it can implement code that reacts to each and every frame. write method is called so frequently, its implementation must be sufficiently rapid that it doesn\u2019t stall the encoder. Let's write a class FrameBuffer() like below: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user's webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' )","title":"2. Frame buffer"},{"location":"blog/pi/stream_picamera_mjpeg/#3-streaming-web-server","text":"Python has built-in a simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler ( request , client_address , server ) This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). BaseHTTPRequestHandler provides a number of class and instance variables, and methods for use by subclasses. The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler ( request , client_address , server , directory = None ) This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler ( request , client_address , server ) This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let's start with SimpleHTTPRequestHandler which has some implemented features.","title":"3. Streaming Web server"},{"location":"blog/pi/stream_picamera_mjpeg/#4-request-handler","text":"Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will looking for index.html for the homepage. To display image, create an <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web serve should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) read more at HTTP response status codes Send header with information to notify web client about type of responded content read more at Content-Type Send the content in a stream format (loop forever!): send content type of each frame, then send the actual frame data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating instances of FrameBuffer, PiCamera, HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is availabe.","title":"4. Request Handler"},{"location":"blog/pi/stream_picamera_mjpeg/#5-synchronize-between-threads","text":"Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming","title":"5. Synchronize between threads"},{"location":"blog/pi/stream_picamera_mjpeg/#6-some-updates-in-the-script","text":"The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let's check how they work.","title":"6. Some updates in the script"},{"location":"blog/pi/stream_picamera_mjpeg/#61-class-variable","text":"Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer","title":"6.1. Class variable"},{"location":"blog/pi/stream_picamera_mjpeg/#62-instance-variable","text":"Instance variables are for the data unique to each instance, they are create in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected params list to new params list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the param directory which is an optional param in original constructor of SimpleHTTPRequestHandler . To solve this problem, let's use special *args and **kwargs params.","title":"6.2. Instance variable"},{"location":"blog/pi/stream_picamera_mjpeg/#63-args-and-kwargs","text":"The special *args and **kwargs params allow to pass multiple arguments or keyword arguments to a function. Read about them in here . So, change the param list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler )","title":"6.3. *args and **kwargs"},{"location":"blog/pi/stream_picamera_mjpeg/#64-lambda-function","text":"Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args ))","title":"6.4. Lambda function"},{"location":"blog/pi/stream_picamera_mjpeg/#65-measure-fps","text":"In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking the below button. Download stream_picamera_mjpeg","title":"6.5. Measure FPS"},{"location":"blog/setup_blog/customize_theme/","text":"Material for MkDocs comes with some configs to change the look of the site. Follow the official homepage of Material for MkDocs to learn how to configure or override the theme with more information. 1. Theme settings \u2693\ufe0e 1.1. Color \u2693\ufe0e Changing color to white for header and background make the site now look like a white paper, and users can focus on the content only. theme : palette : primary : white 1.2. Fonts \u2693\ufe0e Serifed fonts are widely used for body text because they are considered easier to read than sans-serif fonts in print 1 . For better reading, distinguishing the digit zero from the Latin script letter is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed/ dotted/ open zero 2 , but fonts for reading don't have. It's also needed to clearly distinguish the digit one with lowercase i, the uppercase i with the lowercase l. Luckily, they usually do not stand close to each other. This site uses Noto Serif for body text, and Roboto Mono for code block, to replace the defaults font . theme : font : text : Noto Serif code : Roboto Mono Preview of confusing pairs of letters: Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL 1.3. Logo & Icon \u2693\ufe0e Replace the default icon and logo with this symbol: theme : icon : logo : fontawesome/solid/code favicon : favicon.ico 1.4. Navigation \u2693\ufe0e Here are some interesting features for navigation : Navigation tabs : make top-level sections become header tabs Back-to-top button : scroll up when user has scrolled down so far Hide header bar : the header is automatically hidden when the user scrolls down Those are activated as below: theme : features : - navigation.tabs - navigation.top - header.autohide 1.5. Table of Content \u2693\ufe0e The Table of Content extension provides a quick navigation between sections in the post, have anchor link at each header. markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4 1.6. Additional assets \u2693\ufe0e Stylesheets and Javascripts are easily added to the theme by declaring the paths in the config file mkdocs.yml : extra_css : - stylesheets/extra.css extra_javascript : - javascripts/extra.js which finds see the folder structure as below: . \u251c\u2500 docs/ \u2502 \u251c\u2500 stylesheets/ \u2502 \u2502 \u2514\u2500 extra.css \u2502 \u2514\u2500 javascripts/ \u2502 \u2514\u2500 extra.js \u2514\u2500 mkdocs.yml 2. Override theme \u2693\ufe0e MkDocs allows to override the them by just adding extra files that will replace the original ones when MkDocs sees the config of them extending. Enable theme extending mkdocs.yml , and create a new folder overrides : theme : name : material custom_dir : overrides Override files : The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , original path is in .venv\\Lib\\site-packages\\material , is the starting point of any site's page. All other page should extend from it. The main.html will be used for all markdown pages. Override blocks : Besides overriding partials, it's also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new templat .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>Lorem ipsum dolor sit amet</title> {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available) 2.1. Index page \u2693\ufe0e The index.html at the root of the docs folder will be the initial page of the site. At this moment, it should show the site name, and the site description. Add site information in mkdocs.yml : site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming Modify the default content of docs\\index.md with jinja template, which is enabled by Macro plugin , and markdown advanced syntax for attribute lists: --- title: Home disqus: \"\" hide: - navigation - toc --- Welcome to {.welcome} # {{ config.site_name }} {.site-name} {{ config.site_description_full }} {.site-description} --- {# create a list of social buttons use - to remove leading or trailing spaces #} {%- if config.extra.social -%} {%- for social in config.extra.social -%} [ :{{ social.icon | replace('/', '-') }}: ]( {{ social.link }} ){.md-button} {% endfor %} {% endif %} <style> .welcome { padding-left: .1em; margin-bottom: 0 } .site-name { margin-bottom: .5em !important; color: orangered !important; } .site-description { font-size: large; padding-left: .05em; margin-bottom: 0; } .md-typeset .md-button { font-size: unset; min-width: 3em; text-align: center; padding: .3em 0 0 0; border-radius: .5em; border: 1px solid lightgray; color: unset; } </style> 2.2. Error page \u2693\ufe0e The 404.html page is a special page that will be served whenever the requested URL does not exist. Add new file 404.html in the folder override , and write a short message to inform users about the unhandled request. {% extends \"base.html\" %} {% block styles %} {{ super () }} <style> .md-sidebar { display: none; } </style> {% endblock %} {% block content %} <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage,<br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %} 2.3. Zoom-in Image \u2693\ufe0e As mentioned in Images , view-bigimg library helps to make image zoom-able and pan-able. Download view-bigimg.css and view-bigimg.js files from the src folder . Add them into additions assests configs in mkdocs.yml extra_css : - stylesheets/view-bigimg.css extra_javascript : - javascripts/view-bigimg.js Add a function to quick close the image on one mouse click extra.js var dragged = false ; document . addEventListener ( 'mousedown' , () => dragged = false ); document . addEventListener ( 'mousemove' , () => dragged = true ); var viewer = new ViewBigimg () var figures = document . querySelectorAll ( 'figure' ) for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === 'IMG' ) { viewer . show ( e . target . src ); } } } var containers = document . querySelectorAll ( '#iv-container .iv-image-view' ) for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } } } 2.4. Modified styles \u2693\ufe0e Change the look of HTML elements by adding styles in the additional stylesheet assets\\extra.css . extra.css 2.4.1. Page \u2693\ufe0e List of modifications: Set Orange color for the logo Set White background color in the Search input field Clear the top margin of the Main content Clear background color in the footer Make active links in navigation bolder Show scrollbar only hover on sidebars 2.4.2. Content \u2693\ufe0e List of modifications: Make headers Orange Make buttons smaller Set Dark Red color for codeblocks Make codeblocks wrap long lines 3. Add tags \u2693\ufe0e 3.1. Meta-data \u2693\ufe0e Tags are added in the meta-data section in each document. For example: --- title : title description : description tags : - python - mkdocs - jinja --- 3.2. Tag page \u2693\ufe0e Add new page for showing tags at docs\\tags\\index.md which will use tags.html template: --- title : Tags template : tags.html disqus : \"\" --- ## Tags then write tags.html template to include 2 parts: {% extends \"main.html\" %} {% block styles %} {{ super () }} <style> .md-sidebar__inner { display: none; } @media screen and (max-width: 76.1875em) { .md-sidebar { display: none !important; } } </style> {% endblock %} {% block content %} {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-list-pages.html\" %} {% endblock %} 3.3. Tag cloud \u2693\ufe0e Scan all pages and create a list of pairs (tag, pages[]) Show each tag with different text size: tag which has more page count will show in bigger size Tag cloud can be show in all pages, by adding tag-cloud.html to the sidebars in base.html template. <div style=\"font-weight:700; font-size:.7rem; margin:0 0.6rem;\"> <label>Tag cloud</label> </div> <div style=\"padding: 0.4rem 0.6rem;\"> {% include \"partials/tag-cloud.html\" %} </div> 3.4. Tag list \u2693\ufe0e List all tags of the current page: {% if page and page.meta and page.meta.tags %} <p> {% for tag in page.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} 3.5. Page list \u2693\ufe0e Scan all pages and create a list of pairs (tag, pages[]) Show each tag with the list of pages in collapsible block Only one block is open at a time [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false D . addEventListener ( \"toggle\" , E => D . open && A . forEach ( d => d != E . target && ( d . open = false ) ) ) } ) var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"Customize theme"},{"location":"blog/setup_blog/customize_theme/#1-theme-settings","text":"","title":"1. Theme settings"},{"location":"blog/setup_blog/customize_theme/#11-color","text":"Changing color to white for header and background make the site now look like a white paper, and users can focus on the content only. theme : palette : primary : white","title":"1.1. Color"},{"location":"blog/setup_blog/customize_theme/#12-fonts","text":"Serifed fonts are widely used for body text because they are considered easier to read than sans-serif fonts in print 1 . For better reading, distinguishing the digit zero from the Latin script letter is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed/ dotted/ open zero 2 , but fonts for reading don't have. It's also needed to clearly distinguish the digit one with lowercase i, the uppercase i with the lowercase l. Luckily, they usually do not stand close to each other. This site uses Noto Serif for body text, and Roboto Mono for code block, to replace the defaults font . theme : font : text : Noto Serif code : Roboto Mono Preview of confusing pairs of letters: Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL","title":"1.2. Fonts"},{"location":"blog/setup_blog/customize_theme/#13-logo--icon","text":"Replace the default icon and logo with this symbol: theme : icon : logo : fontawesome/solid/code favicon : favicon.ico","title":"1.3. Logo &amp; Icon"},{"location":"blog/setup_blog/customize_theme/#14-navigation","text":"Here are some interesting features for navigation : Navigation tabs : make top-level sections become header tabs Back-to-top button : scroll up when user has scrolled down so far Hide header bar : the header is automatically hidden when the user scrolls down Those are activated as below: theme : features : - navigation.tabs - navigation.top - header.autohide","title":"1.4. Navigation"},{"location":"blog/setup_blog/customize_theme/#15-table-of-content","text":"The Table of Content extension provides a quick navigation between sections in the post, have anchor link at each header. markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4","title":"1.5. Table of Content"},{"location":"blog/setup_blog/customize_theme/#16-additional-assets","text":"Stylesheets and Javascripts are easily added to the theme by declaring the paths in the config file mkdocs.yml : extra_css : - stylesheets/extra.css extra_javascript : - javascripts/extra.js which finds see the folder structure as below: . \u251c\u2500 docs/ \u2502 \u251c\u2500 stylesheets/ \u2502 \u2502 \u2514\u2500 extra.css \u2502 \u2514\u2500 javascripts/ \u2502 \u2514\u2500 extra.js \u2514\u2500 mkdocs.yml","title":"1.6. Additional assets"},{"location":"blog/setup_blog/customize_theme/#2-override-theme","text":"MkDocs allows to override the them by just adding extra files that will replace the original ones when MkDocs sees the config of them extending. Enable theme extending mkdocs.yml , and create a new folder overrides : theme : name : material custom_dir : overrides Override files : The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , original path is in .venv\\Lib\\site-packages\\material , is the starting point of any site's page. All other page should extend from it. The main.html will be used for all markdown pages. Override blocks : Besides overriding partials, it's also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new templat .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>Lorem ipsum dolor sit amet</title> {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available)","title":"2. Override theme"},{"location":"blog/setup_blog/customize_theme/#21-index-page","text":"The index.html at the root of the docs folder will be the initial page of the site. At this moment, it should show the site name, and the site description. Add site information in mkdocs.yml : site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming Modify the default content of docs\\index.md with jinja template, which is enabled by Macro plugin , and markdown advanced syntax for attribute lists: --- title: Home disqus: \"\" hide: - navigation - toc --- Welcome to {.welcome} # {{ config.site_name }} {.site-name} {{ config.site_description_full }} {.site-description} --- {# create a list of social buttons use - to remove leading or trailing spaces #} {%- if config.extra.social -%} {%- for social in config.extra.social -%} [ :{{ social.icon | replace('/', '-') }}: ]( {{ social.link }} ){.md-button} {% endfor %} {% endif %} <style> .welcome { padding-left: .1em; margin-bottom: 0 } .site-name { margin-bottom: .5em !important; color: orangered !important; } .site-description { font-size: large; padding-left: .05em; margin-bottom: 0; } .md-typeset .md-button { font-size: unset; min-width: 3em; text-align: center; padding: .3em 0 0 0; border-radius: .5em; border: 1px solid lightgray; color: unset; } </style>","title":"2.1. Index page"},{"location":"blog/setup_blog/customize_theme/#22-error-page","text":"The 404.html page is a special page that will be served whenever the requested URL does not exist. Add new file 404.html in the folder override , and write a short message to inform users about the unhandled request. {% extends \"base.html\" %} {% block styles %} {{ super () }} <style> .md-sidebar { display: none; } </style> {% endblock %} {% block content %} <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage,<br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %}","title":"2.2. Error page"},{"location":"blog/setup_blog/customize_theme/#23-zoom-in-image","text":"As mentioned in Images , view-bigimg library helps to make image zoom-able and pan-able. Download view-bigimg.css and view-bigimg.js files from the src folder . Add them into additions assests configs in mkdocs.yml extra_css : - stylesheets/view-bigimg.css extra_javascript : - javascripts/view-bigimg.js Add a function to quick close the image on one mouse click extra.js var dragged = false ; document . addEventListener ( 'mousedown' , () => dragged = false ); document . addEventListener ( 'mousemove' , () => dragged = true ); var viewer = new ViewBigimg () var figures = document . querySelectorAll ( 'figure' ) for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === 'IMG' ) { viewer . show ( e . target . src ); } } } var containers = document . querySelectorAll ( '#iv-container .iv-image-view' ) for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } } }","title":"2.3. Zoom-in Image"},{"location":"blog/setup_blog/customize_theme/#24-modified-styles","text":"Change the look of HTML elements by adding styles in the additional stylesheet assets\\extra.css . extra.css","title":"2.4. Modified styles"},{"location":"blog/setup_blog/customize_theme/#241-page","text":"List of modifications: Set Orange color for the logo Set White background color in the Search input field Clear the top margin of the Main content Clear background color in the footer Make active links in navigation bolder Show scrollbar only hover on sidebars","title":"2.4.1. Page"},{"location":"blog/setup_blog/customize_theme/#242-content","text":"List of modifications: Make headers Orange Make buttons smaller Set Dark Red color for codeblocks Make codeblocks wrap long lines","title":"2.4.2. Content"},{"location":"blog/setup_blog/customize_theme/#3-add-tags","text":"","title":"3. Add tags"},{"location":"blog/setup_blog/customize_theme/#31-meta-data","text":"Tags are added in the meta-data section in each document. For example: --- title : title description : description tags : - python - mkdocs - jinja ---","title":"3.1. Meta-data"},{"location":"blog/setup_blog/customize_theme/#32-tag-page","text":"Add new page for showing tags at docs\\tags\\index.md which will use tags.html template: --- title : Tags template : tags.html disqus : \"\" --- ## Tags then write tags.html template to include 2 parts: {% extends \"main.html\" %} {% block styles %} {{ super () }} <style> .md-sidebar__inner { display: none; } @media screen and (max-width: 76.1875em) { .md-sidebar { display: none !important; } } </style> {% endblock %} {% block content %} {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-list-pages.html\" %} {% endblock %}","title":"3.2. Tag page"},{"location":"blog/setup_blog/customize_theme/#33-tag-cloud","text":"Scan all pages and create a list of pairs (tag, pages[]) Show each tag with different text size: tag which has more page count will show in bigger size Tag cloud can be show in all pages, by adding tag-cloud.html to the sidebars in base.html template. <div style=\"font-weight:700; font-size:.7rem; margin:0 0.6rem;\"> <label>Tag cloud</label> </div> <div style=\"padding: 0.4rem 0.6rem;\"> {% include \"partials/tag-cloud.html\" %} </div>","title":"3.3. Tag cloud"},{"location":"blog/setup_blog/customize_theme/#34-tag-list","text":"List all tags of the current page: {% if page and page.meta and page.meta.tags %} <p> {% for tag in page.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %}","title":"3.4. Tag list"},{"location":"blog/setup_blog/customize_theme/#35-page-list","text":"Scan all pages and create a list of pairs (tag, pages[]) Show each tag with the list of pages in collapsible block Only one block is open at a time [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false D . addEventListener ( \"toggle\" , E => D . open && A . forEach ( d => d != E . target && ( d . open = false ) ) ) } ) var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"3.5. Page list"},{"location":"blog/setup_blog/install_and_configure/","text":"1. Installation \u2693\ufe0e 1.1. Python \u2693\ufe0e Download and install Python 3 . 1.2. Material for MkDocs \u2693\ufe0e There are some static site generators written in Python: MkDocs, Pelican, Sphinx, etc. MkDocs is the most popular one. MkDocs is a fast and simple engine to build project documentation. Content source files are written in Markdown , and configured with a single YAML config file. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features, has flexible settings, and makes a clear layout for printing. Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs Start a new project: mkdir CodeInsideOut cd CodeInsideOut Create project's virtual environment : python -m venv .venv Why should use virtual environment? Read more here. Activate the environment: .venv\\Scripts\\activate.bat Then update the pip and setuptools : python -m pip install -U pip setuptools -U or --upgrade will upgrade the package if it is already installed Then install Material for Mkdocs : pip install -U mkdocs-material Finally, bring up the base of the site mkdocs new . This will create the following structure . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material That's it. Start a local server with : mkdocs serve and preview the site at http://localhost:8000 . To publish the site, build it: mkdocs build then copy all the content in the site folder to the website root folder. 1.3. Visual Studio Code \u2693\ufe0e Install Visual Studio Code - a lightweight but powerful source code editor. It well supports users to write code, documents, notes. Useful extensions for writing in Markdown and editing HTML template: Code Spell Checker : catch common spelling errors Markdown All in One : keyboard shortcuts, auto completions, list and task list, table formatter Markdown Paste : paste image, links from clipboard Jinja : highlight Jinja syntax (HTML template) Git History : view history edits from git log 2. Configuration \u2693\ufe0e 2.1. Markdown extensions \u2693\ufe0e Original Markdown syntax just renders some basic elements. Therefore many extensions are made to extend Markdown syntax: Official Markdown extensions has more syntaxes to make Tables, Table of Content, Abbreviations, Admonitions, Codeblocks. PyMdown Extensions has a list of useful extensions to replace the official ones which eventually produce much better formats such as Nested Code Bocks, Tabs, Progress Bars, Tasks. 3 rd party extensions which extend the Python Markdown APIs to deal with Math/Latex, Diagrams, Advanced formats, and more. Material for MkDocs comes with both Official Python Markdown extensions and PyMdown Extensions, but those are not fully activated. To enable an extension, just need to declare its name in the project config file mkdocs.yml under markdown_extensions field. For example: markdown_extensions : - admonition Refer to Markdown Syntax to know the list of extensions and their usage. 2.2. MkDocs plugins \u2693\ufe0e To extend the abilities of MkDocs, there are some plugins can be installed. Check the list at the official MkDocs plugin list . To enable an extension, just need to declare its name in the project config file mkdocs.yml under plugins field. For example: plugins : - search # built-in search engine Refer to MkDocs plugins to know the list of plugins and their usage. 2.3. Theme configs \u2693\ufe0e Material for MkDocs comes with some configs to change the look of the site. Follow the official homepage of Material for MkDocs to learn how to configure or override the theme with more information. List of modifications: Theme settings Overridden templates Additional styles Refer to Customize theme to know the list of modifications in details.","title":"Install and configure"},{"location":"blog/setup_blog/install_and_configure/#1-installation","text":"","title":"1. Installation"},{"location":"blog/setup_blog/install_and_configure/#11-python","text":"Download and install Python 3 .","title":"1.1. Python"},{"location":"blog/setup_blog/install_and_configure/#12-material-for-mkdocs","text":"There are some static site generators written in Python: MkDocs, Pelican, Sphinx, etc. MkDocs is the most popular one. MkDocs is a fast and simple engine to build project documentation. Content source files are written in Markdown , and configured with a single YAML config file. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features, has flexible settings, and makes a clear layout for printing. Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs.Refer to the official homepage of Material for MkDocs Start a new project: mkdir CodeInsideOut cd CodeInsideOut Create project's virtual environment : python -m venv .venv Why should use virtual environment? Read more here. Activate the environment: .venv\\Scripts\\activate.bat Then update the pip and setuptools : python -m pip install -U pip setuptools -U or --upgrade will upgrade the package if it is already installed Then install Material for Mkdocs : pip install -U mkdocs-material Finally, bring up the base of the site mkdocs new . This will create the following structure . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material That's it. Start a local server with : mkdocs serve and preview the site at http://localhost:8000 . To publish the site, build it: mkdocs build then copy all the content in the site folder to the website root folder.","title":"1.2. Material for MkDocs"},{"location":"blog/setup_blog/install_and_configure/#13-visual-studio-code","text":"Install Visual Studio Code - a lightweight but powerful source code editor. It well supports users to write code, documents, notes. Useful extensions for writing in Markdown and editing HTML template: Code Spell Checker : catch common spelling errors Markdown All in One : keyboard shortcuts, auto completions, list and task list, table formatter Markdown Paste : paste image, links from clipboard Jinja : highlight Jinja syntax (HTML template) Git History : view history edits from git log","title":"1.3. Visual Studio Code"},{"location":"blog/setup_blog/install_and_configure/#2-configuration","text":"","title":"2. Configuration"},{"location":"blog/setup_blog/install_and_configure/#21-markdown-extensions","text":"Original Markdown syntax just renders some basic elements. Therefore many extensions are made to extend Markdown syntax: Official Markdown extensions has more syntaxes to make Tables, Table of Content, Abbreviations, Admonitions, Codeblocks. PyMdown Extensions has a list of useful extensions to replace the official ones which eventually produce much better formats such as Nested Code Bocks, Tabs, Progress Bars, Tasks. 3 rd party extensions which extend the Python Markdown APIs to deal with Math/Latex, Diagrams, Advanced formats, and more. Material for MkDocs comes with both Official Python Markdown extensions and PyMdown Extensions, but those are not fully activated. To enable an extension, just need to declare its name in the project config file mkdocs.yml under markdown_extensions field. For example: markdown_extensions : - admonition Refer to Markdown Syntax to know the list of extensions and their usage.","title":"2.1. Markdown extensions"},{"location":"blog/setup_blog/install_and_configure/#22-mkdocs-plugins","text":"To extend the abilities of MkDocs, there are some plugins can be installed. Check the list at the official MkDocs plugin list . To enable an extension, just need to declare its name in the project config file mkdocs.yml under plugins field. For example: plugins : - search # built-in search engine Refer to MkDocs plugins to know the list of plugins and their usage.","title":"2.2. MkDocs plugins"},{"location":"blog/setup_blog/install_and_configure/#23-theme-configs","text":"Material for MkDocs comes with some configs to change the look of the site. Follow the official homepage of Material for MkDocs to learn how to configure or override the theme with more information. List of modifications: Theme settings Overridden templates Additional styles Refer to Customize theme to know the list of modifications in details.","title":"2.3. Theme configs"},{"location":"blog/setup_blog/markdown_syntax/","text":"For basic markdown syntax, refer to Markdown Guide . 1. Meta-data \u2693\ufe0e The Meta-Data extension adds a syntax for defining meta-data about a document. It is inspired by and follows the syntax of MultiMarkdown . Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a markdown document like this: title : The page title description : The summary of the page content tags : page markdown Alternatively, YAML style, using triple-dash --- , can be used to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content tags : - page - markdown --- The metadata can be used in the template and page content. In jinja syntax, each page is represented as a page object, then Markdown syntax will be replaced by the page's title. Read more about using metadata in page content, and customize the theme. 2. Admonition \u2693\ufe0e The Admonition extension adds rST-style admonitions to Markdown documents. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax: !!! type \"Title\" Content of the admonition is indented. Title Content of the admonition is indented. Using custom class and style to make admonition which does not have title but still have icon: !!! type notitle \"&nbsp;\" Content of the admonition is indented. Content of the admonition is indented. Other types : note, seealso Content of the admonition is indented. abstract, summary, tldr Content of the admonition is indented. info, todo Content of the admonition is indented. tip, hint, important Content of the admonition is indented. success, check, done Content of the admonition is indented. question, help, faq Content of the admonition is indented. warning, caution, attention Content of the admonition is indented. failure, fail, missing Content of the admonition is indented. danger, error Content of the admonition is indented. bug Content of the admonition is indented. example Content of the admonition is indented. quote, cite Content of the admonition is indented. 3. Attribute \u2693\ufe0e The Attribute Lists extension adds a syntax to define attributes on the various HTML elements in markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example attribute list might look like this: { #someid .someclass somekey='somevalue' } Block attribute : To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. {style=\"font-style:italic;\"} Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. Element attribute : To define attributes on inline elements, the attribute list should be defined immediately after the inline element generated by markdown with no white space. This is a _green_ {style=\"color:green\"} word. This is a <span>green</span>{style=\"color:green\"} word. This is a green word. This is a non-green {style=\"color:green\"} word. 4. Lists \u2693\ufe0e Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist - def_list - sane_lists Ordered list : 1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2 Unordered list : * Unordered item 1 * Child 1 * Child 2 * Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2 Sane list : 1. Ordered item 1 2. Ordered item 2 * Unordered item 1 * Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2 Tasks : - [x] item 1 * [x] item A * [ ] item B - [ ] item 2 item 1 item A item B item 2 Definitions : Roses : are red Violets : are blue Roses are red Violets are blue 5. Code blocks \u2693\ufe0e The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The format is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in simpler syntax which does not support id , class or custom key=value : ``` language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y to z . Line numbers are always referenced starting at 1 ignoring what the line number is labeled by the option linenums = \"n\" . ``` c linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } 6. Inline code \u2693\ufe0e the InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite's existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language mycode` or `#!language mycode` This will render as below example: A line of python code: `#!python [x for x in range(1, 10) if x % 2]` . A line of python code: [ x for x in range ( 1 , 10 ) if x % 2 ] . 7. Images \u2693\ufe0e There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses alt text to make caption, accepts markdown in alt text. ![ Caption ]( link to image ) Some images have big size that does not show the detail, therefore, it's better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library do that requirement well. Enable it by following Customize theme . For example: ![ Lorem Picsum ]( https://picsum.photos/1280/720 ) Lorem Picsum 8. Tabs \u2693\ufe0e Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab 2\" Some other texts Inner tabs: === \"Tab A\" Text A === \"Tab B\" Text B Tab 1 Some texts Tab 2 Some other texts Inner tabs: Tab A Text A Tab B Text B 9. Tables \u2693\ufe0e The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | Some texts | Some texts | Some texts | Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts 10. Formatting \u2693\ufe0e Carets : Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert me^^ H^2^0 Insert me H 2 0 Marks : Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== ==smart==mark== mark me smart==mark Tildes : The PyMdown extension optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete me~~ CH~3~CH~2~OH Delete me CH 3 CH 2 OH 11. Critic \u2693\ufe0e Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text you can use {\u200b++insert me++} and {\u200b--remove me--} respectively. You can also denote a substitution with {\u200b~~substitute this~>with this~~}. You can also highlight specific text with {\u200b==highlight me==}. Or even comment, which is generally done by highlighting text and following it with a comment: {\u200b==highlight me==}{\u200b>>Add a comment<<}. To insert or remove text you can use insert me and remove me respectively. You can also denote a substitution with substitute this with this . You can also highlight specific text with highlight me . Or even comment, which is generally done by highlighting text and following it with a comment: highlight me Add a comment . 12. HTML block \u2693\ufe0e The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With the md-in-html extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed__ by Markdown. This is a bold word parsed by Markdown. 13. Icons & Emojis \u2693\ufe0e The Emoji extension Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg Emojis : Emojis can be written by putting the shortcode of the emoji between two colons. Look up the shortcodes at Emojipedia . :smile: :heart: Icons : Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - : - :material-account-circle: \u2013 `.icons/material/account-circle.svg` - :fontawesome-regular-laugh-wink: \u2013 `.icons/fontawesome/regular/laugh-wink.svg` - :octicons-octoface-24: \u2013 `.icons/octicons/octoface-24.svg` Include in theme : Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span> 14. Custom block \u2693\ufe0e The Custom Blocks extension defines a common markup to create parametrizable and nestable custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: mytype \"value 1\" param2=value2 Indented content Example usage : Add the filename of a codeblock, to show where the it belongs. Syntax: ::: file main.c ``` cpp int main(void) { return 0; } ``` with style: . md-typeset . file > p { font-size : .9 em ; font-style : italic ; color : darkred ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; } 15. Footnotes \u2693\ufe0e The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label _fn_. to get: Footnotes 1 have a label 2 and the footnote's content. This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"Markdown syntax"},{"location":"blog/setup_blog/markdown_syntax/#1-meta-data","text":"The Meta-Data extension adds a syntax for defining meta-data about a document. It is inspired by and follows the syntax of MultiMarkdown . Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a markdown document like this: title : The page title description : The summary of the page content tags : page markdown Alternatively, YAML style, using triple-dash --- , can be used to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content tags : - page - markdown --- The metadata can be used in the template and page content. In jinja syntax, each page is represented as a page object, then Markdown syntax will be replaced by the page's title. Read more about using metadata in page content, and customize the theme.","title":"1. Meta-data"},{"location":"blog/setup_blog/markdown_syntax/#2-admonition","text":"The Admonition extension adds rST-style admonitions to Markdown documents. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax: !!! type \"Title\" Content of the admonition is indented. Title Content of the admonition is indented. Using custom class and style to make admonition which does not have title but still have icon: !!! type notitle \"&nbsp;\" Content of the admonition is indented. Content of the admonition is indented. Other types : note, seealso Content of the admonition is indented. abstract, summary, tldr Content of the admonition is indented. info, todo Content of the admonition is indented. tip, hint, important Content of the admonition is indented. success, check, done Content of the admonition is indented. question, help, faq Content of the admonition is indented. warning, caution, attention Content of the admonition is indented. failure, fail, missing Content of the admonition is indented. danger, error Content of the admonition is indented. bug Content of the admonition is indented. example Content of the admonition is indented. quote, cite Content of the admonition is indented.","title":"2. Admonition"},{"location":"blog/setup_blog/markdown_syntax/#3-attribute","text":"The Attribute Lists extension adds a syntax to define attributes on the various HTML elements in markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example attribute list might look like this: { #someid .someclass somekey='somevalue' } Block attribute : To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. {style=\"font-style:italic;\"} Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. Element attribute : To define attributes on inline elements, the attribute list should be defined immediately after the inline element generated by markdown with no white space. This is a _green_ {style=\"color:green\"} word. This is a <span>green</span>{style=\"color:green\"} word. This is a green word. This is a non-green {style=\"color:green\"} word.","title":"3. Attribute"},{"location":"blog/setup_blog/markdown_syntax/#4-lists","text":"Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist - def_list - sane_lists Ordered list : 1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2 Unordered list : * Unordered item 1 * Child 1 * Child 2 * Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2 Sane list : 1. Ordered item 1 2. Ordered item 2 * Unordered item 1 * Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2 Tasks : - [x] item 1 * [x] item A * [ ] item B - [ ] item 2 item 1 item A item B item 2 Definitions : Roses : are red Violets : are blue Roses are red Violets are blue","title":"4. Lists"},{"location":"blog/setup_blog/markdown_syntax/#5-code-blocks","text":"The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The format is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in simpler syntax which does not support id , class or custom key=value : ``` language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y to z . Line numbers are always referenced starting at 1 ignoring what the line number is labeled by the option linenums = \"n\" . ``` c linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; }","title":"5. Code blocks"},{"location":"blog/setup_blog/markdown_syntax/#6-inline-code","text":"the InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite's existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language mycode` or `#!language mycode` This will render as below example: A line of python code: `#!python [x for x in range(1, 10) if x % 2]` . A line of python code: [ x for x in range ( 1 , 10 ) if x % 2 ] .","title":"6. Inline code"},{"location":"blog/setup_blog/markdown_syntax/#7-images","text":"There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses alt text to make caption, accepts markdown in alt text. ![ Caption ]( link to image ) Some images have big size that does not show the detail, therefore, it's better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library do that requirement well. Enable it by following Customize theme . For example: ![ Lorem Picsum ]( https://picsum.photos/1280/720 ) Lorem Picsum","title":"7. Images"},{"location":"blog/setup_blog/markdown_syntax/#8-tabs","text":"Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab 2\" Some other texts Inner tabs: === \"Tab A\" Text A === \"Tab B\" Text B Tab 1 Some texts Tab 2 Some other texts Inner tabs: Tab A Text A Tab B Text B","title":"8. Tabs"},{"location":"blog/setup_blog/markdown_syntax/#9-tables","text":"The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | Some texts | Some texts | Some texts | Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts","title":"9. Tables"},{"location":"blog/setup_blog/markdown_syntax/#10-formatting","text":"Carets : Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert me^^ H^2^0 Insert me H 2 0 Marks : Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== ==smart==mark== mark me smart==mark Tildes : The PyMdown extension optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete me~~ CH~3~CH~2~OH Delete me CH 3 CH 2 OH","title":"10. Formatting"},{"location":"blog/setup_blog/markdown_syntax/#11-critic","text":"Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text you can use {\u200b++insert me++} and {\u200b--remove me--} respectively. You can also denote a substitution with {\u200b~~substitute this~>with this~~}. You can also highlight specific text with {\u200b==highlight me==}. Or even comment, which is generally done by highlighting text and following it with a comment: {\u200b==highlight me==}{\u200b>>Add a comment<<}. To insert or remove text you can use insert me and remove me respectively. You can also denote a substitution with substitute this with this . You can also highlight specific text with highlight me . Or even comment, which is generally done by highlighting text and following it with a comment: highlight me Add a comment .","title":"11. Critic"},{"location":"blog/setup_blog/markdown_syntax/#12-html-block","text":"The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With the md-in-html extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed__ by Markdown. This is a bold word parsed by Markdown.","title":"12. HTML block"},{"location":"blog/setup_blog/markdown_syntax/#13-icons--emojis","text":"The Emoji extension Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg Emojis : Emojis can be written by putting the shortcode of the emoji between two colons. Look up the shortcodes at Emojipedia . :smile: :heart: Icons : Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - : - :material-account-circle: \u2013 `.icons/material/account-circle.svg` - :fontawesome-regular-laugh-wink: \u2013 `.icons/fontawesome/regular/laugh-wink.svg` - :octicons-octoface-24: \u2013 `.icons/octicons/octoface-24.svg` Include in theme : Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span>","title":"13. Icons &amp; Emojis"},{"location":"blog/setup_blog/markdown_syntax/#14-custom-block","text":"The Custom Blocks extension defines a common markup to create parametrizable and nestable custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: mytype \"value 1\" param2=value2 Indented content Example usage : Add the filename of a codeblock, to show where the it belongs. Syntax: ::: file main.c ``` cpp int main(void) { return 0; } ``` with style: . md-typeset . file > p { font-size : .9 em ; font-style : italic ; color : darkred ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; }","title":"14. Custom block"},{"location":"blog/setup_blog/markdown_syntax/#15-footnotes","text":"The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label _fn_. to get: Footnotes 1 have a label 2 and the footnote's content. This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"15. Footnotes"},{"location":"blog/setup_blog/mkdocs_plugins/","text":"1. Awesome Pages \u2693\ufe0e MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable the extension: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A ... entry to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. e.g. nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path. Optionally specify a title for the navigation entry Add additional links to the navigation entry. e.g. nav : - ... - First page : page1.md - Link Title : https://lukasgeiter.com Hide directory by setting the hide attribute to true . Set directory title using the title attribute. Collapse single nested pages by setting collapse_single_pages to true . 2. Macros \u2693\ufe0e MkDocs macro plugin is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transforming the markdown pages into Jinja2 templates that use variables, calls to macros and custom filters. Replacing MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable the extension: plugins : - search # built-in search must be always activated - macros incomplete data The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data. 3. Mermaid \u2693\ufe0e MkDocs Mermaid2 plugin is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable the extension: plugins : - search # built-in search must be always activated - mermaid2 And configure the codeblock parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ``` mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"MkDocs plugins"},{"location":"blog/setup_blog/mkdocs_plugins/#1-awesome-pages","text":"MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable the extension: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A ... entry to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. e.g. nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path. Optionally specify a title for the navigation entry Add additional links to the navigation entry. e.g. nav : - ... - First page : page1.md - Link Title : https://lukasgeiter.com Hide directory by setting the hide attribute to true . Set directory title using the title attribute. Collapse single nested pages by setting collapse_single_pages to true .","title":"1. Awesome Pages"},{"location":"blog/setup_blog/mkdocs_plugins/#2-macros","text":"MkDocs macro plugin is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transforming the markdown pages into Jinja2 templates that use variables, calls to macros and custom filters. Replacing MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable the extension: plugins : - search # built-in search must be always activated - macros incomplete data The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data.","title":"2. Macros"},{"location":"blog/setup_blog/mkdocs_plugins/#3-mermaid","text":"MkDocs Mermaid2 plugin is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable the extension: plugins : - search # built-in search must be always activated - mermaid2 And configure the codeblock parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ``` mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"3. Mermaid"},{"location":"blog/setup_blog/print_to_pdf/","text":"1. Print plugin \u2693\ufe0e The MkDocs PDF with JS Plugin 1 exports documentation as PDF with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the documentation. For executing the JavaScript code ChromeDriver is used. So it is nesseccary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user's PATH Install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install original plugin with pip install mkdocs-pdf-with-js-plugin if don't need a customized version Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the pdfs get generated. They are stored in site_dir/pdfs . This is a modification in the plugin MkDocs PDF with JS Plugin , if it's installed, it is ready to use without any further changes showing in below sections 2. Add download button \u2693\ufe0e Create an element to contain the download button at the beginning of the document content in the base.html template: <div class=\"md-content\" data-md-component=\"content\"> <article class=\"md-content__inner md-typeset\"> {% block content %} {% if not page.is_homepage %} <div class=\"btn-actions\"></div> {% endif %} {{ page.content }} ... {% endblock %} </article> </div> The plugin will find the < div class = \"btn-actions\" > element to insert a button: .venv\\Lib\\site-packages\\pdf_with_js\\printer.py def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' div = soup . new_tag ( \"div\" ) div [ 'id' ] = 'btn-download' div . append ( btn ) bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . insert ( 0 , div ) return soup 3. Add header and footer \u2693\ufe0e The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol - printToPDF . Some important params: landscape : boolean Paper orientation. Defaults to false . displayHeaderFooter : boolean Display header and footer. Defaults to false . headerTemplate : : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate span containing the title. footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate. Initialize default value for those params: def __init__ ( self ): self . pages = [] self . filenameUseFullTitle = False self . displayHeaderFooter = True self . headerTemplate = '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span>' \\ '</div>' then create print options in json format: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } and use it when calling the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options ()) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ]) 4. Add plugin config option \u2693\ufe0e To allow user to change the print option in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'filename_use_full_title' , config_options . Type ( bool , default = False )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) when the MkDocs engine calls to on_config() function in this plugin, save the user's configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'filename_use_full_title' ], self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config 5. Printing styles \u2693\ufe0e When printing, many elements should not show or have different style to fit the paper size or match with overall style on paper. Change the look of elements by adding styles in the additional stylesheet assets\\extra.css . extra.css 5.1. Cover page \u2693\ufe0e The first page should show the topic and a short description of the post. Create an element named page-cover in the base.html template: {% block content %} <div class=\"page-cover\"> {% if not \"\\x3ch1\" in page.content %} {% if page and page.meta and page.meta.title_full %} <h1 class=\"page-title\"> {{ page.meta.title_full | d ( config.site_name , true ) }} </h1> {% elif page and page.meta and page.meta.title %} <h1 class=\"page-title\"> {{ page.meta.title | d ( config.site_name , true ) }} </h1> {% else %} <h1 class=\"page-title\"> {{ config.site_name }} </h1> {% endif %} {% if page and page.meta and page.meta.description %} <p class=\"page-description\"> {{ page.meta.description }} </p> {% endif %} {% if page and page.meta and page.meta.tags %} <p> {% for tag in page.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% endif %} </div> {% if not page.is_homepage %} <div class=\"btn-actions screen-only\"></div> <div class=\"toc print-only\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {% endif %} {{ page.content }} The page cover will use 100% height of the paper and align its content vertically: @ media print { . md-typeset . page-cover { height : 100 vh ; display : flex ; flex-direction : column ; justify-content : center ; } } originally developed by smaxtec \u21a9","title":"Print to PDF"},{"location":"blog/setup_blog/print_to_pdf/#1-print-plugin","text":"The MkDocs PDF with JS Plugin 1 exports documentation as PDF with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the documentation. For executing the JavaScript code ChromeDriver is used. So it is nesseccary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user's PATH Install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install original plugin with pip install mkdocs-pdf-with-js-plugin if don't need a customized version Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the pdfs get generated. They are stored in site_dir/pdfs . This is a modification in the plugin MkDocs PDF with JS Plugin , if it's installed, it is ready to use without any further changes showing in below sections","title":"1. Print plugin"},{"location":"blog/setup_blog/print_to_pdf/#2-add-download-button","text":"Create an element to contain the download button at the beginning of the document content in the base.html template: <div class=\"md-content\" data-md-component=\"content\"> <article class=\"md-content__inner md-typeset\"> {% block content %} {% if not page.is_homepage %} <div class=\"btn-actions\"></div> {% endif %} {{ page.content }} ... {% endblock %} </article> </div> The plugin will find the < div class = \"btn-actions\" > element to insert a button: .venv\\Lib\\site-packages\\pdf_with_js\\printer.py def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' div = soup . new_tag ( \"div\" ) div [ 'id' ] = 'btn-download' div . append ( btn ) bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . insert ( 0 , div ) return soup","title":"2. Add download button"},{"location":"blog/setup_blog/print_to_pdf/#3-add-header-and-footer","text":"The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol - printToPDF . Some important params: landscape : boolean Paper orientation. Defaults to false . displayHeaderFooter : boolean Display header and footer. Defaults to false . headerTemplate : : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate span containing the title. footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate. Initialize default value for those params: def __init__ ( self ): self . pages = [] self . filenameUseFullTitle = False self . displayHeaderFooter = True self . headerTemplate = '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span>' \\ '</div>' then create print options in json format: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } and use it when calling the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options ()) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ])","title":"3. Add header and footer"},{"location":"blog/setup_blog/print_to_pdf/#4-add-plugin-config-option","text":"To allow user to change the print option in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'filename_use_full_title' , config_options . Type ( bool , default = False )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) when the MkDocs engine calls to on_config() function in this plugin, save the user's configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'filename_use_full_title' ], self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config","title":"4. Add plugin config option"},{"location":"blog/setup_blog/print_to_pdf/#5-printing-styles","text":"When printing, many elements should not show or have different style to fit the paper size or match with overall style on paper. Change the look of elements by adding styles in the additional stylesheet assets\\extra.css . extra.css","title":"5. Printing styles"},{"location":"blog/setup_blog/print_to_pdf/#51-cover-page","text":"The first page should show the topic and a short description of the post. Create an element named page-cover in the base.html template: {% block content %} <div class=\"page-cover\"> {% if not \"\\x3ch1\" in page.content %} {% if page and page.meta and page.meta.title_full %} <h1 class=\"page-title\"> {{ page.meta.title_full | d ( config.site_name , true ) }} </h1> {% elif page and page.meta and page.meta.title %} <h1 class=\"page-title\"> {{ page.meta.title | d ( config.site_name , true ) }} </h1> {% else %} <h1 class=\"page-title\"> {{ config.site_name }} </h1> {% endif %} {% if page and page.meta and page.meta.description %} <p class=\"page-description\"> {{ page.meta.description }} </p> {% endif %} {% if page and page.meta and page.meta.tags %} <p> {% for tag in page.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% endif %} </div> {% if not page.is_homepage %} <div class=\"btn-actions screen-only\"></div> <div class=\"toc print-only\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {% endif %} {{ page.content }} The page cover will use 100% height of the paper and align its content vertically: @ media print { . md-typeset . page-cover { height : 100 vh ; display : flex ; flex-direction : column ; justify-content : center ; } } originally developed by smaxtec \u21a9","title":"5.1. Cover page"},{"location":"blog/stm32/clock/","text":"1. Clock source \u2693\ufe0e Almost every digital circuit needs a way to synchronize its internal circuitry or to synchronize itself with other circuits. A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle. A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator ( High Speed Internal (HSI)) or an external dedicated crystal oscillator ( High Speed External (HSE)). There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25\u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal ( Low Speed External (LSE)) or the internal dedicated RC oscillator ( Low Speed Internal (LSI)). The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency 2. Clock tree \u2693\ufe0e The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC), and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK - that is the one that feeds the core, DMAs and AHB bus),and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses. SysTick The System Tick Time SysTick generates interrupt requests on a regular basis. This allows an OS to carry out context switching to support multiple tasking. For applications that do not require an OS, the SysTick can be used for time keeping, time measurement, or as an interrupt source for tasks that need to be executed regularly. Example of a clock tree 3. Get Clock Frequency \u2693\ufe0e Sometimes it is important to know how fast the CPU core is running. The CubeHAL provides a function that can be used to compute the SYSCLK frequency: the HAL_RCC_GetSysClockFreq() . However, this function must be handled with special care. The HAL_RCC_GetSysClockFreq() does not return the real SYSCLK frequency (it could never do this in a reliable way without having a known and precise external reference), but it bases the result on the following algorithm: if SYSCLK source is the HSI oscillator, then returns the value based on the HSI_VALUE macro; if SYSCLK source is the HSE oscillator, then returns the value based on the HSE_VALUE macro; if SYSCLK source is the PLLCLK , then returns a value based on HSI_VALUE or HSE_VALUE multiplied by the PLL factor, according the specific STM32 MCU implementation. HSI_VALUE and HSE_VALUE macros are defined inside the stm32xxx_hal_conf.h file, and they are hardcoded values. The HSI_VALUE is defined by ST during chip design, with 1% of accuracy. HSE_VALUE macro is defined by programmer, so it could be wrong. 4. Configure clock \u2693\ufe0e The clock path starts from the internal 8MHz oscillator. If the microcontroller relies on an external HSE/LSE crystal, then clock source has to be enabled in the RCC peripheral before it can be used as the main clock source. Clock tree of STM32F0 4.1. External clock source \u2693\ufe0e For both HSE and LSE oscillators, CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. In almost all development board from ST (included the Nucleo ones) the Master Clock Output (MCO) pin of the ST-LINK interface is used as external clock source for the target STM32 MCU. Enabling this option allows to use the ST-LINK MCO as HSE. Enable external clock source 4.2. Master Clock Output \u2693\ufe0e The RCC peripheral also allows to enable the Master Clock Output (MCO), which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view. Select clock source to be output 5. HAL Software \u2693\ufe0e Reset and Clock Control (RCC) peripheral is responsible of the configuration for the whole clock tree of an STM32 MCU. The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . CubeMX is designed to generate the right code initialization for the clock tree of our MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c . To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Enable MCO ouput Above config should give a generated code as below: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); } 6. Clock Security System \u2693\ufe0e The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception, a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initializations inside the NMI exception handler. HAL_RCC_EnableCSS() function will enable the CSS feature, and define a handling callback: void HAL_RCC_CSSCallback ( void ) { //Catch the HSE failure and take proper actions } which is called from the NMI interrupt handler: void NMI_Handler ( void ) { HAL_RCC_NMI_IRQHandler (); }","title":"Clock"},{"location":"blog/stm32/clock/#1-clock-source","text":"Almost every digital circuit needs a way to synchronize its internal circuitry or to synchronize itself with other circuits. A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle. A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator ( High Speed Internal (HSI)) or an external dedicated crystal oscillator ( High Speed External (HSE)). There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25\u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal ( Low Speed External (LSE)) or the internal dedicated RC oscillator ( Low Speed Internal (LSI)). The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency","title":"1. Clock source"},{"location":"blog/stm32/clock/#2-clock-tree","text":"The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC), and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK - that is the one that feeds the core, DMAs and AHB bus),and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses. SysTick The System Tick Time SysTick generates interrupt requests on a regular basis. This allows an OS to carry out context switching to support multiple tasking. For applications that do not require an OS, the SysTick can be used for time keeping, time measurement, or as an interrupt source for tasks that need to be executed regularly. Example of a clock tree","title":"2. Clock tree"},{"location":"blog/stm32/clock/#3-get-clock-frequency","text":"Sometimes it is important to know how fast the CPU core is running. The CubeHAL provides a function that can be used to compute the SYSCLK frequency: the HAL_RCC_GetSysClockFreq() . However, this function must be handled with special care. The HAL_RCC_GetSysClockFreq() does not return the real SYSCLK frequency (it could never do this in a reliable way without having a known and precise external reference), but it bases the result on the following algorithm: if SYSCLK source is the HSI oscillator, then returns the value based on the HSI_VALUE macro; if SYSCLK source is the HSE oscillator, then returns the value based on the HSE_VALUE macro; if SYSCLK source is the PLLCLK , then returns a value based on HSI_VALUE or HSE_VALUE multiplied by the PLL factor, according the specific STM32 MCU implementation. HSI_VALUE and HSE_VALUE macros are defined inside the stm32xxx_hal_conf.h file, and they are hardcoded values. The HSI_VALUE is defined by ST during chip design, with 1% of accuracy. HSE_VALUE macro is defined by programmer, so it could be wrong.","title":"3. Get Clock Frequency"},{"location":"blog/stm32/clock/#4-configure-clock","text":"The clock path starts from the internal 8MHz oscillator. If the microcontroller relies on an external HSE/LSE crystal, then clock source has to be enabled in the RCC peripheral before it can be used as the main clock source. Clock tree of STM32F0","title":"4. Configure clock"},{"location":"blog/stm32/clock/#41-external-clock-source","text":"For both HSE and LSE oscillators, CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. In almost all development board from ST (included the Nucleo ones) the Master Clock Output (MCO) pin of the ST-LINK interface is used as external clock source for the target STM32 MCU. Enabling this option allows to use the ST-LINK MCO as HSE. Enable external clock source","title":"4.1. External clock source"},{"location":"blog/stm32/clock/#42-master-clock-output","text":"The RCC peripheral also allows to enable the Master Clock Output (MCO), which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view. Select clock source to be output","title":"4.2. Master Clock Output"},{"location":"blog/stm32/clock/#5-hal-software","text":"Reset and Clock Control (RCC) peripheral is responsible of the configuration for the whole clock tree of an STM32 MCU. The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . CubeMX is designed to generate the right code initialization for the clock tree of our MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c . To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Enable MCO ouput Above config should give a generated code as below: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); }","title":"5. HAL Software"},{"location":"blog/stm32/clock/#6-clock-security-system","text":"The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception, a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initializations inside the NMI exception handler. HAL_RCC_EnableCSS() function will enable the CSS feature, and define a handling callback: void HAL_RCC_CSSCallback ( void ) { //Catch the HSE failure and take proper actions } which is called from the NMI interrupt handler: void NMI_Handler ( void ) { HAL_RCC_NMI_IRQHandler (); }","title":"6. Clock Security System"},{"location":"blog/stm32/distance_us-100/","text":"US-100 Ultrasonic Sensor 1. US-100 Ultrasonic sensor \u2693\ufe0e The US-100 Ultrasonic sensor is very similar to the popular HC-SR04, and even looks the same, but has a few extra tricks: Can run from 3V to 5V, so don't need any logic level shifters or dividers. Can use in \"Pulse\" mode (like on HC-SR04) or in \"Serial UART\" mode. Range is about 2cm to 450cm away, but 10cm-250cm will get the best results Ultrasonic sensor US-100 When the jumper is in place, use an 9600 baud UART to communicate with the sensor: send 0x55 and read back two bytes (16 bit value) that is mm distance send 0x50 to read the temperature in degrees C, in offset of -45 When the jumper on the back is removed, it acts like an HC-SR04 with a trigger and echo pin The width of echo pulse is the time it takes for the ultrasonic sound to travel from the sensor to the object and back. Debug on UART1 using Redirection For more convenient, this project use UART Redirection technique to use the UART1 as the debug terminal, and use standard printf() function to output messages. 2. UART mode \u2693\ufe0e Use UART2 to communicate with US-100. MCU Pin US-100 Pin PA2 (UART2TX) Trigger/TX PA3 (UART2RX) Echo/RX State The system will go around 5 states: stateDiagram-v2 idle --> wait_dist: request distance wait_dist --> calc_dist : receive distance calc_dist --> wait_temp : request temperature wait_temp --> calc_temp : receive temperature calc_temp --> idle Code Create variable to hold the state, trial counter, commands, and returned value: enum { IDLE , WAIT_DIST , CALC_DIST , WAIT_TEMP , CALC_TEMP }; char state = IDLE ; char try = 0 ; uint16_t value = 0 ; uint8_t cmd_dist [] = { 0x55 }; uint8_t cmd_temp [] = { 0x50 }; uint8_t buffer [ 2 ] = { 0 }; Then, in the main loop, process each state, note to use interrupt mode to receive data: int main ( void ) { Set_Redirect_UART_Port ( TERMINAL ); ... other setup ... while ( 1 ) { if ( state == IDLE ) { // send request to measure distance printf ( \"D? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_dist , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 2 ); // change state state = WAIT_DIST ; try = 0 ; } else if ( state == CALC_DIST ) { // calculate distance value = ( buffer [ 0 ] << 8 ) + buffer [ 1 ]; printf ( \"D = %d mm \\n\\r \" , value ); // send request to get temperature printf ( \"T? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_temp , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 1 ); // change state state = WAIT_TEMP ; try = 0 ; } else if ( state == CALC_TEMP ){ // calculate temperature value = buffer [ 0 ] - 45 ; printf ( \"T = %d \\n\\r \" , value ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 500 ); // retry after 5 seconds if ( ++ try >= 10 ) { printf ( \"Re-try \\n\\r \" ); state = IDLE ; } } } Finally, handle the interrupt callback by checking the state and set new state for the main loop: void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == US_100 ) { if ( state == WAIT_DIST ) { state = CALC_DIST ; } else if ( state == WAIT_TEMP ) { state = CALC_TEMP ; } } } Compile and run on the board, use an logic analyser to check how fast the US-100 can response for each command: Distance response time: < 10 ms Temperature response time: < 5 ms Output of US-100 And on the debug terminal, the distance and temperature are printed in decimal value: Print output on terminal 3. Pulse mode \u2693\ufe0e update soon","title":"US-100"},{"location":"blog/stm32/distance_us-100/#1-us-100-ultrasonic-sensor","text":"The US-100 Ultrasonic sensor is very similar to the popular HC-SR04, and even looks the same, but has a few extra tricks: Can run from 3V to 5V, so don't need any logic level shifters or dividers. Can use in \"Pulse\" mode (like on HC-SR04) or in \"Serial UART\" mode. Range is about 2cm to 450cm away, but 10cm-250cm will get the best results Ultrasonic sensor US-100 When the jumper is in place, use an 9600 baud UART to communicate with the sensor: send 0x55 and read back two bytes (16 bit value) that is mm distance send 0x50 to read the temperature in degrees C, in offset of -45 When the jumper on the back is removed, it acts like an HC-SR04 with a trigger and echo pin The width of echo pulse is the time it takes for the ultrasonic sound to travel from the sensor to the object and back. Debug on UART1 using Redirection For more convenient, this project use UART Redirection technique to use the UART1 as the debug terminal, and use standard printf() function to output messages.","title":"1. US-100 Ultrasonic sensor"},{"location":"blog/stm32/distance_us-100/#2-uart-mode","text":"Use UART2 to communicate with US-100. MCU Pin US-100 Pin PA2 (UART2TX) Trigger/TX PA3 (UART2RX) Echo/RX State The system will go around 5 states: stateDiagram-v2 idle --> wait_dist: request distance wait_dist --> calc_dist : receive distance calc_dist --> wait_temp : request temperature wait_temp --> calc_temp : receive temperature calc_temp --> idle Code Create variable to hold the state, trial counter, commands, and returned value: enum { IDLE , WAIT_DIST , CALC_DIST , WAIT_TEMP , CALC_TEMP }; char state = IDLE ; char try = 0 ; uint16_t value = 0 ; uint8_t cmd_dist [] = { 0x55 }; uint8_t cmd_temp [] = { 0x50 }; uint8_t buffer [ 2 ] = { 0 }; Then, in the main loop, process each state, note to use interrupt mode to receive data: int main ( void ) { Set_Redirect_UART_Port ( TERMINAL ); ... other setup ... while ( 1 ) { if ( state == IDLE ) { // send request to measure distance printf ( \"D? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_dist , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 2 ); // change state state = WAIT_DIST ; try = 0 ; } else if ( state == CALC_DIST ) { // calculate distance value = ( buffer [ 0 ] << 8 ) + buffer [ 1 ]; printf ( \"D = %d mm \\n\\r \" , value ); // send request to get temperature printf ( \"T? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_temp , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 1 ); // change state state = WAIT_TEMP ; try = 0 ; } else if ( state == CALC_TEMP ){ // calculate temperature value = buffer [ 0 ] - 45 ; printf ( \"T = %d \\n\\r \" , value ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 500 ); // retry after 5 seconds if ( ++ try >= 10 ) { printf ( \"Re-try \\n\\r \" ); state = IDLE ; } } } Finally, handle the interrupt callback by checking the state and set new state for the main loop: void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == US_100 ) { if ( state == WAIT_DIST ) { state = CALC_DIST ; } else if ( state == WAIT_TEMP ) { state = CALC_TEMP ; } } } Compile and run on the board, use an logic analyser to check how fast the US-100 can response for each command: Distance response time: < 10 ms Temperature response time: < 5 ms Output of US-100 And on the debug terminal, the distance and temperature are printed in decimal value: Print output on terminal","title":"2. UART mode"},{"location":"blog/stm32/distance_us-100/#3-pulse-mode","text":"update soon","title":"3. Pulse mode"},{"location":"blog/stm32/dma/","text":"DMA Mem2Mem DMA Mem2UartTx 1. DMA Controller \u2693\ufe0e The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports, named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port, connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows to assign different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory DMA Controller 2. DMA Channels \u2693\ufe0e Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC and MINC bits in the _DMA_CCRx _register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size. 3. DMA Circular Mode \u2693\ufe0e The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served. 4. DMA Interrupts \u2693\ufe0e An interrupt can be produced on a Half-transfer, Transfer complete, or Transfer error for each DMA channel. Separate interrupt enable bits are available for flexibility. 5. HAL Software \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own function by customization of function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure). 6. Lab: DMA Memory to Memory \u2693\ufe0e To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer. Application target: - Create a 4KB data block in flash memory (slow peripheral) - Create a 4KB buffer in SRAM memory (fast peripheral) - Run CPU memcpy() function to copy from flash to sram - Run DMA Mem2Mem transfer to copy from flash to sram - Each operation's duration will be measure by a pulse on GPIO to visual view on a logic analyser Start a new project, the follow below guide. 6.1. Enable DMA \u2693\ufe0e Goto System Core > DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core 6.2. Generated code \u2693\ufe0e An instance of DMA_HandleTypeDef hdma_memtomem_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_memtomem_dma1_channel1 on DMA1_Channel1 */ hdma_memtomem_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_memtomem_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_memtomem_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_memtomem_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_memtomem_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_memtomem_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_memtomem_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_memtomem_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_memtomem_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } } 6.3. User code \u2693\ufe0e Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. Using const modifier to put variable in to the Flash Memory by Linker. Read more here . #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Measure execution time To measure the execution time in a logic analyser, just use any GPIO in to indicate it by raising it to HIGH logic level. For example, on the STM32F0 Disco board, LD3 on PC9 is used. Test the CPU memcpy() function: HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer, note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_memtomem_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1192 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem 6.4. Inspect interrupts \u2693\ufe0e Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \"DMA1 channel 1 interrupt\" : Enable DMA Interrupt in IDE Then generate modified code which is newly added into the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_memtomem_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, those callback are not set, therefore, write 2 functions to handle DMA interrupts: void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( LD4_GPIO_Port , LD4_Pin , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( LD4_GPIO_Port , LD4_Pin , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_memtomem_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_memtomem_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else HAL_DMA_Start ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_memtomem_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer 7. Lab: DMA Memory to UART TX \u2693\ufe0e This project demonstrates how DMA co-works with CPU to do parallel tasks: CPU will have a main task to blink the LD3 led every 100 ms. DMA will transfer a 4KB block of data on UART at 9600 bps. 7.1. Enable DMA on UART TX \u2693\ufe0e Start a new project and enable USART1 with following settings: Mode: Asynchronous Mode: 9600 bps, 8-bit data, None parity, 1-bit Stop In DMA Settings , add DMA Request for USART1_TX on DMA1 Channel 2 When enable DMA on a peripheral, DMA interrupt is automatically enabled under NVIC settings, and it is also locked by the option Force DMA Channels Interrupt . 7.2. Generated code \u2693\ufe0e The function MX_DMA_Init() is generated but just to enable DMA Peripheral's clock and DMA Interrupt lines. The setting for DMA on peripheral is moved to the corresponding peripheral's setup functions in this case, they are MX_USART1_UART_Init() \u2192 HAL_UART_Init() \u2192 HAL_UART_MspInit() (override in stm32xxxx_hal_msp.c ): void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); /* USART1 DMA Init */ /* USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); } } Notice the HAL macro __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx) that is used to link the DMA handler to the peripheral. In fact, it sets the field huart.hdmatx = hdma_usart1_tx , and assign hdma_usart1_tx.Parent = huart . That linking function helps to link the peripheral's callbacks to the DMA callbacks of Half data transfer hdma->XferHalfCpltCallback() and Full data transfer hdma->XferCpltCallback() . 7.3. User code \u2693\ufe0e For testing, start with the case that CPU should toggle the LD3 pin and then transfer 4KB data on UART1. while ( 1 ) { HAL_GPIO_TogglePin ( LD3_GPIO_Port , LD3_Pin ); HAL_Delay ( 100 ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE , HAL_MAX_DELAY ); } Apparently, the LD3 cannot be toggled every 100ms. The transmission on UART takes a long time (~ 4.3s), which causes the execution time of one loop to 4.5 seconds, so it slows down the led blink too much: LED blinking rate is affected by UART transmission However, when use DMA, the toggling time of the LED is remained at 100 ms. While DMA is executing, new DMA start will be ignored. while ( 1 ) { HAL_GPIO_TogglePin ( LD3_GPIO_Port , LD3_Pin ); HAL_Delay ( 100 ); #if defined(USE_DMA_FOR_UART_TX) HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE ); #else HAL_UART_Transmit ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE , HAL_MAX_DELAY ); #endif } Here is the result of using DMA, the LD3 is toggled every 100 ms while UART is transmitting data. LED blinking is running at desired speed, while UART transmission is handled by DMA 8. Lab: DMA Peripheral to Memory \u2693\ufe0e update soon","title":"DMA"},{"location":"blog/stm32/dma/#1-dma-controller","text":"The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports, named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port, connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows to assign different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory DMA Controller","title":"1. DMA Controller"},{"location":"blog/stm32/dma/#2-dma-channels","text":"Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC and MINC bits in the _DMA_CCRx _register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size.","title":"2. DMA Channels"},{"location":"blog/stm32/dma/#3-dma-circular-mode","text":"The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served.","title":"3. DMA Circular Mode"},{"location":"blog/stm32/dma/#4-dma-interrupts","text":"An interrupt can be produced on a Half-transfer, Transfer complete, or Transfer error for each DMA channel. Separate interrupt enable bits are available for flexibility.","title":"4. DMA Interrupts"},{"location":"blog/stm32/dma/#5-hal-software","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own function by customization of function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure).","title":"5. HAL Software"},{"location":"blog/stm32/dma/#6-lab-dma-memory-to-memory","text":"To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer. Application target: - Create a 4KB data block in flash memory (slow peripheral) - Create a 4KB buffer in SRAM memory (fast peripheral) - Run CPU memcpy() function to copy from flash to sram - Run DMA Mem2Mem transfer to copy from flash to sram - Each operation's duration will be measure by a pulse on GPIO to visual view on a logic analyser Start a new project, the follow below guide.","title":"6. Lab: DMA Memory to Memory"},{"location":"blog/stm32/dma/#61-enable-dma","text":"Goto System Core > DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core","title":"6.1. Enable DMA"},{"location":"blog/stm32/dma/#62-generated-code","text":"An instance of DMA_HandleTypeDef hdma_memtomem_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_memtomem_dma1_channel1 on DMA1_Channel1 */ hdma_memtomem_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_memtomem_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_memtomem_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_memtomem_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_memtomem_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_memtomem_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_memtomem_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_memtomem_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_memtomem_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } }","title":"6.2. Generated code"},{"location":"blog/stm32/dma/#63-user-code","text":"Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. Using const modifier to put variable in to the Flash Memory by Linker. Read more here . #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Measure execution time To measure the execution time in a logic analyser, just use any GPIO in to indicate it by raising it to HIGH logic level. For example, on the STM32F0 Disco board, LD3 on PC9 is used. Test the CPU memcpy() function: HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer, note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_memtomem_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1192 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem","title":"6.3. User code"},{"location":"blog/stm32/dma/#64-inspect-interrupts","text":"Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \"DMA1 channel 1 interrupt\" : Enable DMA Interrupt in IDE Then generate modified code which is newly added into the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_memtomem_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, those callback are not set, therefore, write 2 functions to handle DMA interrupts: void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( LD4_GPIO_Port , LD4_Pin , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( LD4_GPIO_Port , LD4_Pin , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_memtomem_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_memtomem_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else HAL_DMA_Start ( & hdma_memtomem_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_memtomem_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( LD3_GPIO_Port , LD3_Pin , GPIO_PIN_RESET ); #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer","title":"6.4. Inspect interrupts"},{"location":"blog/stm32/dma/#7-lab-dma-memory-to-uart-tx","text":"This project demonstrates how DMA co-works with CPU to do parallel tasks: CPU will have a main task to blink the LD3 led every 100 ms. DMA will transfer a 4KB block of data on UART at 9600 bps.","title":"7. Lab: DMA Memory to UART TX"},{"location":"blog/stm32/dma/#71-enable-dma-on-uart-tx","text":"Start a new project and enable USART1 with following settings: Mode: Asynchronous Mode: 9600 bps, 8-bit data, None parity, 1-bit Stop In DMA Settings , add DMA Request for USART1_TX on DMA1 Channel 2 When enable DMA on a peripheral, DMA interrupt is automatically enabled under NVIC settings, and it is also locked by the option Force DMA Channels Interrupt .","title":"7.1. Enable DMA on UART TX"},{"location":"blog/stm32/dma/#72-generated-code","text":"The function MX_DMA_Init() is generated but just to enable DMA Peripheral's clock and DMA Interrupt lines. The setting for DMA on peripheral is moved to the corresponding peripheral's setup functions in this case, they are MX_USART1_UART_Init() \u2192 HAL_UART_Init() \u2192 HAL_UART_MspInit() (override in stm32xxxx_hal_msp.c ): void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); /* USART1 DMA Init */ /* USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); } } Notice the HAL macro __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx) that is used to link the DMA handler to the peripheral. In fact, it sets the field huart.hdmatx = hdma_usart1_tx , and assign hdma_usart1_tx.Parent = huart . That linking function helps to link the peripheral's callbacks to the DMA callbacks of Half data transfer hdma->XferHalfCpltCallback() and Full data transfer hdma->XferCpltCallback() .","title":"7.2. Generated code"},{"location":"blog/stm32/dma/#73-user-code","text":"For testing, start with the case that CPU should toggle the LD3 pin and then transfer 4KB data on UART1. while ( 1 ) { HAL_GPIO_TogglePin ( LD3_GPIO_Port , LD3_Pin ); HAL_Delay ( 100 ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE , HAL_MAX_DELAY ); } Apparently, the LD3 cannot be toggled every 100ms. The transmission on UART takes a long time (~ 4.3s), which causes the execution time of one loop to 4.5 seconds, so it slows down the led blink too much: LED blinking rate is affected by UART transmission However, when use DMA, the toggling time of the LED is remained at 100 ms. While DMA is executing, new DMA start will be ignored. while ( 1 ) { HAL_GPIO_TogglePin ( LD3_GPIO_Port , LD3_Pin ); HAL_Delay ( 100 ); #if defined(USE_DMA_FOR_UART_TX) HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE ); #else HAL_UART_Transmit ( & huart1 , ( uint8_t * ) & data , TRANSFER_SIZE , HAL_MAX_DELAY ); #endif } Here is the result of using DMA, the LD3 is toggled every 100 ms while UART is transmitting data. LED blinking is running at desired speed, while UART transmission is handled by DMA","title":"7.3. User code"},{"location":"blog/stm32/dma/#8-lab-dma-peripheral-to-memory","text":"update soon","title":"8. Lab: DMA Peripheral to Memory"},{"location":"blog/stm32/gpio/","text":"Toggle LEDs GPIO notes Enable clock source on GPIO port when use it APB2 bus speed determines the sampling rate of all GPIO inputs Can select mode, speed, alternative function on a GPIO pin Can have external interruption Can lock a GPIO after initializing Disconnect a GPIO pin by setting it into input floating mode Save power by setting GPIO pins to Analog mode ( Schmitt trigger is disabled) 1. Hardware \u2693\ufe0e Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt trigger to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure 1.1. Voltage and Current \u2693\ufe0e Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet. 1.2. Input mode \u2693\ufe0e Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins. 1.3. Output mode \u2693\ufe0e Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions. 1.4. Output Speed \u2693\ufe0e GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes 1.5. Bit atomic operation \u2693\ufe0e There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register (BSRR) to select individual bit operation. 1.6. Input interrupt \u2693\ufe0e When in input mode, all ports have external interrupt capability. Read more about Interrupt . 1.7. Alternate function \u2693\ufe0e Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF). 1.8. Analog input/output \u2693\ufe0e In analog mode, pin is directly wired to a analog module (ADC, DAC) 1.9. Locking pin \u2693\ufe0e The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset. 2. Memory Map \u2693\ufe0e Program memory, data memory, registers and I/O ports are organized within the same linear 4GB address space. The bytes are coded in memory in Little Endian format . Refer to the document RM0091 for STM32F0xto see the memory map for GPIO ports: Boundary Address Size Peripheral ---------------------------------------------- 0x4800 1400 - 0x4800 17FF 1KB GPIOF 0x4800 1000 - 0x4800 13FF 1KB GPIOE 0x4800 0C00 - 0x4800 0FFF 1KB GPIOD 0x4800 0800 - 0x4800 0BFF 1KB GPIOC 0x4800 0400 - 0x4800 07FF 1KB GPIOB 0x4800 0000 - 0x4800 03FF 1KB GPIOA 3. Register Map \u2693\ufe0e Register Offset Description ----------------------------------- GPIOx_MODER 0x00 I/O mode: 00: Input mode (reset state) 01: General purpose output mode 10: Alternate function mode 11: Analog mode GPIOx_OTYPER 0x04 Output type: 0: Output push-pull (reset state) 1: Output open-drain GPIOx_OSPEEDR 0x08 Output speed: x0: Low speed 01: Medium speed 11: High speed GPIOx_PUPDR 0x0C Pull-up/ pull-down 00: No pull-up, pull-down 01: Pull-up 10: Pull-down 11: Reserved GPIOx_IDR 0x10 Input data GPIOx_ODR 0x14 Output data GPIOx_BSRR 0x18 Bit Set/Reset 0: No action on the corresponding ODRx bit 1: Set/Reset the corresponding ODRx bit GPIOx_LCKR 0x1C Configuration lock GPIOx_AFRL 0x20 Alternate Function low register GPIOx_AFRH 0x24 Alternate Function high register 0000: AF0 0001: AF1 0010: AF2 0011: AF3 0100: AF4 0101: AF5 0110: AF6 0111: AF7 GPIOx_BRR 0x28 Bit Reset 0: No action on the corresponding ODx bit 1: Reset the corresponding ODx bit 4. HAL Software \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows to set register values to their reset value. It's also recommended to use it to unconfigure pin which was used as an external interrupt or in event mode. That's the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function. 5. Lab: Toggle LEDs \u2693\ufe0e This project aims to learn how to configure GPIO via STM32CubeIDE and STM32CubeMX. Target board: STM32F0 Discovery Application requirements: Turn on Green LED and Blue LED at startup In main loop, toggle Green LED every 500ms If user press User button, toggle the Blue LED 5.1. Create project \u2693\ufe0e Create new project via CubeMX and setup GPIO for LEDs and button. Green Led is on PC9, select GPIO_Output Blue Led is on PC8, select GPIO_Output Button is on PA0, select GPIO_EXTI0 do not select GPIO_Input to detect interruption 5.2. Setup button's interrupt \u2693\ufe0e Check the board schematic to know how the button is wired. As seen below, the button is pulled to GND by default, and then connected to VDD when pressed. Therefore, to capture the action of pressing down the button, rising edge will be used to detect the transition. Select GPIO in Pinout and Configuration tab, then click on PA0 pin config: GPIO Mode: External Interrupt Mode with Rising Edge trigger GPIO PU/PD: No Move to NVIC tab: Check on EXTI line 0 and 1 interrupts Schematic of User button on pin PA0 Assign GPIO to Leds and button Enable interrupt on button 5.3. Generated code \u2693\ufe0e Generate code with alt + k . Custom defines Any custom name for a pin will be defined in main.h : main.h #define B1_Pin GPIO_PIN_0 #define B1_GPIO_Port GPIOA #define LD4_Pin GPIO_PIN_8 #define LD4_GPIO_Port GPIOC #define LD3_Pin GPIO_PIN_9 #define LD3_GPIO_Port GPIOC Init functions In the main.c , IDE generates SystemClock_Config() to setup system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( GPIOC , LD4_Pin | LD3_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : B1_Pin */ GPIO_InitStruct . Pin = B1_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( B1_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pins : LD4_Pin LD3_Pin */ GPIO_InitStruct . Pin = LD4_Pin | LD3_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( GPIOC , & GPIO_InitStruct ); /* EXTI interrupt init*/ HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } Interrupt handlers The the override function of the EXTI0 interrupt handler is implemented in _it.c file: stm32f0xx_it.c void EXTI0_1_IRQHandler ( void ) { HAL_GPIO_EXTI_IRQHandler ( GPIO_PIN_0 ); } When tracing the code of the function HAL_GPIO_EXTI_IRQHandler() , it will call to the callback function HAL_GPIO_EXTI_Callback() which should be overridden in main.c . 5.4. User code \u2693\ufe0e Add some lines of code to implement the application requirements: Turn on all leds at startup Before main while loop: HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 | GPIO_PIN_9 , GPIO_PIN_SET ); Toggle the green led every 500ms Inside the main while loop: while ( 1 ) { HAL_GPIO_TogglePin ( GPIOC , GPIO_PIN_9 ); HAL_Delay ( 500 ); } Toggle the blue led when press on button Override HAL_GPIO_EXTI_Callback and call to HAL function to toggle the pin state: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { if ( GPIO_PIN_0 == GPIO_Pin ) { HAL_GPIO_TogglePin ( GPIOC , GPIO_PIN_8 ); } } 5.5. Build and Run \u2693\ufe0e Press ctrl + b to build the project and run on the target board. If having multiple boards connected, select the target board by selecting its ST-LINK Serial Number Select target board Bouncing input Sometimes, the blue led does not toggle correctly. It toggles more than once. This happens because of input bouncing: the logic level is unstable during the transition. Bouncing input on button To eliminate it, debounce the input by additional hardware or internal timer. 6. Appendix \u2693\ufe0e 6.1. Bare-metal \u2693\ufe0e Bare-metal means accessing to the registers directly to read or write value. Here is an example to turn on PC9 pin GPIO C, pin 9 : #define GPIOC_BASE (0x48000800UL) #define GPIOx_ODR 0x14 volatile uint32_t * GPIOC_ODR = ( uint32_t * )( GPIOC_BASE + GPIOx_ODR ); * GPIOC_ODR |= ( 1 << 9 ); However, it should be better to use struct to manage a GPIO port. ST HAL library has defined GPIO_TypeDef struct as below: typedef struct { volatile uint32_t MODER ; volatile uint32_t OTYPER ; volatile uint32_t OSPEEDR ; volatile uint32_t PUPDR ; volatile uint32_t IDR ; volatile uint32_t ODR ; volatile uint32_t BSRR ; volatile uint32_t LCKR ; volatile uint32_t AFR [ 2 ]; volatile uint32_t BRR ; } GPIO_TypeDef ; Then, define a struct pointer pointing to the base address of the target GPIO port, and use it as a GPIO object: #define GPIOC_BASE (0x48000800UL) #define GPIOC ((GPIO_TypeDef *) GPIOC_BASE) GPIOC -> ODR |= ( 1 << 9 );","title":"GPIO"},{"location":"blog/stm32/gpio/#1-hardware","text":"Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt trigger to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure","title":"1. Hardware"},{"location":"blog/stm32/gpio/#11-voltage-and-current","text":"Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet.","title":"1.1. Voltage and Current"},{"location":"blog/stm32/gpio/#12-input-mode","text":"Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins.","title":"1.2. Input mode"},{"location":"blog/stm32/gpio/#13-output-mode","text":"Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions.","title":"1.3. Output mode"},{"location":"blog/stm32/gpio/#14-output-speed","text":"GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes","title":"1.4. Output Speed"},{"location":"blog/stm32/gpio/#15-bit-atomic-operation","text":"There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register (BSRR) to select individual bit operation.","title":"1.5. Bit atomic operation"},{"location":"blog/stm32/gpio/#16-input-interrupt","text":"When in input mode, all ports have external interrupt capability. Read more about Interrupt .","title":"1.6. Input interrupt"},{"location":"blog/stm32/gpio/#17-alternate-function","text":"Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF).","title":"1.7. Alternate function"},{"location":"blog/stm32/gpio/#18-analog-inputoutput","text":"In analog mode, pin is directly wired to a analog module (ADC, DAC)","title":"1.8. Analog input/output"},{"location":"blog/stm32/gpio/#19-locking-pin","text":"The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset.","title":"1.9. Locking pin"},{"location":"blog/stm32/gpio/#2-memory-map","text":"Program memory, data memory, registers and I/O ports are organized within the same linear 4GB address space. The bytes are coded in memory in Little Endian format . Refer to the document RM0091 for STM32F0xto see the memory map for GPIO ports: Boundary Address Size Peripheral ---------------------------------------------- 0x4800 1400 - 0x4800 17FF 1KB GPIOF 0x4800 1000 - 0x4800 13FF 1KB GPIOE 0x4800 0C00 - 0x4800 0FFF 1KB GPIOD 0x4800 0800 - 0x4800 0BFF 1KB GPIOC 0x4800 0400 - 0x4800 07FF 1KB GPIOB 0x4800 0000 - 0x4800 03FF 1KB GPIOA","title":"2. Memory Map"},{"location":"blog/stm32/gpio/#3-register-map","text":"Register Offset Description ----------------------------------- GPIOx_MODER 0x00 I/O mode: 00: Input mode (reset state) 01: General purpose output mode 10: Alternate function mode 11: Analog mode GPIOx_OTYPER 0x04 Output type: 0: Output push-pull (reset state) 1: Output open-drain GPIOx_OSPEEDR 0x08 Output speed: x0: Low speed 01: Medium speed 11: High speed GPIOx_PUPDR 0x0C Pull-up/ pull-down 00: No pull-up, pull-down 01: Pull-up 10: Pull-down 11: Reserved GPIOx_IDR 0x10 Input data GPIOx_ODR 0x14 Output data GPIOx_BSRR 0x18 Bit Set/Reset 0: No action on the corresponding ODRx bit 1: Set/Reset the corresponding ODRx bit GPIOx_LCKR 0x1C Configuration lock GPIOx_AFRL 0x20 Alternate Function low register GPIOx_AFRH 0x24 Alternate Function high register 0000: AF0 0001: AF1 0010: AF2 0011: AF3 0100: AF4 0101: AF5 0110: AF6 0111: AF7 GPIOx_BRR 0x28 Bit Reset 0: No action on the corresponding ODx bit 1: Reset the corresponding ODx bit","title":"3. Register Map"},{"location":"blog/stm32/gpio/#4-hal-software","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows to set register values to their reset value. It's also recommended to use it to unconfigure pin which was used as an external interrupt or in event mode. That's the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.","title":"4. HAL Software"},{"location":"blog/stm32/gpio/#5-lab-toggle-leds","text":"This project aims to learn how to configure GPIO via STM32CubeIDE and STM32CubeMX. Target board: STM32F0 Discovery Application requirements: Turn on Green LED and Blue LED at startup In main loop, toggle Green LED every 500ms If user press User button, toggle the Blue LED","title":"5. Lab: Toggle LEDs"},{"location":"blog/stm32/gpio/#51-create-project","text":"Create new project via CubeMX and setup GPIO for LEDs and button. Green Led is on PC9, select GPIO_Output Blue Led is on PC8, select GPIO_Output Button is on PA0, select GPIO_EXTI0 do not select GPIO_Input to detect interruption","title":"5.1. Create project"},{"location":"blog/stm32/gpio/#52-setup-buttons-interrupt","text":"Check the board schematic to know how the button is wired. As seen below, the button is pulled to GND by default, and then connected to VDD when pressed. Therefore, to capture the action of pressing down the button, rising edge will be used to detect the transition. Select GPIO in Pinout and Configuration tab, then click on PA0 pin config: GPIO Mode: External Interrupt Mode with Rising Edge trigger GPIO PU/PD: No Move to NVIC tab: Check on EXTI line 0 and 1 interrupts Schematic of User button on pin PA0 Assign GPIO to Leds and button Enable interrupt on button","title":"5.2. Setup button's interrupt"},{"location":"blog/stm32/gpio/#53-generated-code","text":"Generate code with alt + k . Custom defines Any custom name for a pin will be defined in main.h : main.h #define B1_Pin GPIO_PIN_0 #define B1_GPIO_Port GPIOA #define LD4_Pin GPIO_PIN_8 #define LD4_GPIO_Port GPIOC #define LD3_Pin GPIO_PIN_9 #define LD3_GPIO_Port GPIOC Init functions In the main.c , IDE generates SystemClock_Config() to setup system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( GPIOC , LD4_Pin | LD3_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : B1_Pin */ GPIO_InitStruct . Pin = B1_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( B1_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pins : LD4_Pin LD3_Pin */ GPIO_InitStruct . Pin = LD4_Pin | LD3_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( GPIOC , & GPIO_InitStruct ); /* EXTI interrupt init*/ HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } Interrupt handlers The the override function of the EXTI0 interrupt handler is implemented in _it.c file: stm32f0xx_it.c void EXTI0_1_IRQHandler ( void ) { HAL_GPIO_EXTI_IRQHandler ( GPIO_PIN_0 ); } When tracing the code of the function HAL_GPIO_EXTI_IRQHandler() , it will call to the callback function HAL_GPIO_EXTI_Callback() which should be overridden in main.c .","title":"5.3. Generated code"},{"location":"blog/stm32/gpio/#54-user-code","text":"Add some lines of code to implement the application requirements: Turn on all leds at startup Before main while loop: HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 | GPIO_PIN_9 , GPIO_PIN_SET ); Toggle the green led every 500ms Inside the main while loop: while ( 1 ) { HAL_GPIO_TogglePin ( GPIOC , GPIO_PIN_9 ); HAL_Delay ( 500 ); } Toggle the blue led when press on button Override HAL_GPIO_EXTI_Callback and call to HAL function to toggle the pin state: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { if ( GPIO_PIN_0 == GPIO_Pin ) { HAL_GPIO_TogglePin ( GPIOC , GPIO_PIN_8 ); } }","title":"5.4. User code"},{"location":"blog/stm32/gpio/#55-build-and-run","text":"Press ctrl + b to build the project and run on the target board. If having multiple boards connected, select the target board by selecting its ST-LINK Serial Number Select target board Bouncing input Sometimes, the blue led does not toggle correctly. It toggles more than once. This happens because of input bouncing: the logic level is unstable during the transition. Bouncing input on button To eliminate it, debounce the input by additional hardware or internal timer.","title":"5.5. Build and Run"},{"location":"blog/stm32/gpio/#6-appendix","text":"","title":"6. Appendix"},{"location":"blog/stm32/gpio/#61-bare-metal","text":"Bare-metal means accessing to the registers directly to read or write value. Here is an example to turn on PC9 pin GPIO C, pin 9 : #define GPIOC_BASE (0x48000800UL) #define GPIOx_ODR 0x14 volatile uint32_t * GPIOC_ODR = ( uint32_t * )( GPIOC_BASE + GPIOx_ODR ); * GPIOC_ODR |= ( 1 << 9 ); However, it should be better to use struct to manage a GPIO port. ST HAL library has defined GPIO_TypeDef struct as below: typedef struct { volatile uint32_t MODER ; volatile uint32_t OTYPER ; volatile uint32_t OSPEEDR ; volatile uint32_t PUPDR ; volatile uint32_t IDR ; volatile uint32_t ODR ; volatile uint32_t BSRR ; volatile uint32_t LCKR ; volatile uint32_t AFR [ 2 ]; volatile uint32_t BRR ; } GPIO_TypeDef ; Then, define a struct pointer pointing to the base address of the target GPIO port, and use it as a GPIO object: #define GPIOC_BASE (0x48000800UL) #define GPIOC ((GPIO_TypeDef *) GPIOC_BASE) GPIOC -> ODR |= ( 1 << 9 );","title":"6.1. Bare-metal"},{"location":"blog/stm32/interrupt/","text":"1. NVIC Controller \u2693\ufe0e Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC). Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU, for example startup_stm32f051r8tx.s : g_pfnVectors: .word _estack .word Reset_Handler .word NMI_Handler .word HardFault_Handler .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word SVC_Handler .word 0 .word 0 .word PendSV_Handler .word SysTick_Handler .word WWDG_IRQHandler /* Window WatchDog */ .word PVD_IRQHandler /* PVD through EXTI Line detect */ .word RTC_IRQHandler /* RTC through the EXTI line */ .word FLASH_IRQHandler /* FLASH */ .word RCC_CRS_IRQHandler /* RCC and CRS */ .word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ .word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ .word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ .word TSC_IRQHandler /* TSC */ .word DMA1_Channel1_IRQHandler /* DMA1 Ch annel 1 */ .word DMA1_Channel2_3_IRQHandler /* DMA1 Ch annel 2 and Ch annel 3 */ .word DMA1_Channel4_5_IRQHandler /* DMA1 Ch annel 4 and Ch annel 5 */ .word ADC1_COMP_IRQHandler /* ADC1 , COMP1 and COMP2 */ .word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break / Update / Trigger / Commutation */ .word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ .word TIM2_IRQHandler /* TIM2 */ .word TIM3_IRQHandler /* TIM3 */ .word TIM6_DAC_IRQHandler /* TIM6 and DAC */ .word 0 /* Reserved */ .word TIM14_IRQHandler /* TIM14 */ .word TIM15_IRQHandler /* TIM15 */ .word TIM16_IRQHandler /* TIM16 */ .word TIM17_IRQHandler /* TIM17 */ .word I2C1_IRQHandler /* I2C1 */ .word I2C2_IRQHandler /* I2C2 */ .word SP I1_IRQHandler /* SP I1 */ .word SP I2_IRQHandler /* SP I2 */ .word USART1_IRQHandler /* USART1 */ .word USART2_IRQHandler /* USART2 */ .word 0 /* Reserved */ .word CEC_CAN_IRQHandler /* CEC and CAN */ .word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x0000 0000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x0800 0000 address, it is placed starting from the 0x0800 0000 address, which is aliased to 0x0000 0000 when the CPU boots up. Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores 2. Processor Mode \u2693\ufe0e The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode: Which is entered on reset, and application run on this mode. Handler Mode: Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context Allows late determination of highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining) 3. Exception States \u2693\ufe0e Each exception can be in one of the following states: Inactive : Not pending nor active. Pending : Exception event has been fired but the handler is not executed yet. Active : The exception handler has started execution but it\u2019s not over yet Interrupt nesting allows an exception to interrupt the execution of another exception\u2019s handler. In this case, both exceptions are in the active state. Active And Pending : The exception is being serviced by the processor and there is a pending exception from the same source. 4. Interrupts Tail-Chaining \u2693\ufe0e When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing 5. Interrupt Late Arrival \u2693\ufe0e The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception. 6. Pre-Emption \u2693\ufe0e The pre-emption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be pre-empted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can pre-empt it. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 pre-empted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 pre-empted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Pre-emption allow IRQ1 to be executed 7. Reset Behavior \u2693\ufe0e When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00 which contains the end address of RAM _estack The reset handler address is loaded from address 0x04 . The reset handler gets executed in thread mode. The reset handler branches to the main program. 8. Exception Behavior \u2693\ufe0e When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns back to main (assuming no further nesting). Here is more details: .md-typeset ol { list-style-type: decimal !important; } Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers Return From ISR (Context Restoration) Detect tail-chaining interrupt, if have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles 9. Exception Priorities \u2693\ufe0e Lower priority level has higher priority of execution. If two or more exceptions/interrupts are of the same priority level value, the priority order is therefore determined based on the exception number itself Lower exception number has a higher priority. 10. Enable Interrupts \u2693\ufe0e When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ) void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ) enable or disable an interrupt request number. If using a peripheral in interrupt mode, it has to enable the corresponding interrupt at NVIC 10.1. External Interrupts \u2693\ufe0e External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIO, an EXTI line is shared by multiple pins.In one line (group), only one pin can be set to generate interrupt External Interrupt lines 10.2. Peripheral Interrupt \u2693\ufe0e When enable any user ISR, declare the ISR in the file xxx_it.c . In this file, declare a function with the name which is used in the startup file of MCU. For example: Enable interrupt on PA0 by setting EXTI0 Startup file has function pointer EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Add EXTI0_1_IRQHandler function in stm32f0xx_it.c Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed 11. Global Interrupt \u2693\ufe0e The CMSIS-Core package provides several macros that can be used to perform these operation: __disable_irq() and __enable_irq() automatically set and clear the PRIMASK . Any critical task can be placed between these two macros, as shown below: __disable_irq (); /* All exceptions with configurable priority are temporarily disabled. place critical code here */ ... __enable_irq (); However, take in mind that, as general rule, interrupt must be masked only for really short time, otherwise it could lose important interrupts. Remember that interrupts are not queued.","title":"Interrupt"},{"location":"blog/stm32/interrupt/#1-nvic-controller","text":"Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC). Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU, for example startup_stm32f051r8tx.s : g_pfnVectors: .word _estack .word Reset_Handler .word NMI_Handler .word HardFault_Handler .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word SVC_Handler .word 0 .word 0 .word PendSV_Handler .word SysTick_Handler .word WWDG_IRQHandler /* Window WatchDog */ .word PVD_IRQHandler /* PVD through EXTI Line detect */ .word RTC_IRQHandler /* RTC through the EXTI line */ .word FLASH_IRQHandler /* FLASH */ .word RCC_CRS_IRQHandler /* RCC and CRS */ .word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ .word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ .word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ .word TSC_IRQHandler /* TSC */ .word DMA1_Channel1_IRQHandler /* DMA1 Ch annel 1 */ .word DMA1_Channel2_3_IRQHandler /* DMA1 Ch annel 2 and Ch annel 3 */ .word DMA1_Channel4_5_IRQHandler /* DMA1 Ch annel 4 and Ch annel 5 */ .word ADC1_COMP_IRQHandler /* ADC1 , COMP1 and COMP2 */ .word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break / Update / Trigger / Commutation */ .word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ .word TIM2_IRQHandler /* TIM2 */ .word TIM3_IRQHandler /* TIM3 */ .word TIM6_DAC_IRQHandler /* TIM6 and DAC */ .word 0 /* Reserved */ .word TIM14_IRQHandler /* TIM14 */ .word TIM15_IRQHandler /* TIM15 */ .word TIM16_IRQHandler /* TIM16 */ .word TIM17_IRQHandler /* TIM17 */ .word I2C1_IRQHandler /* I2C1 */ .word I2C2_IRQHandler /* I2C2 */ .word SP I1_IRQHandler /* SP I1 */ .word SP I2_IRQHandler /* SP I2 */ .word USART1_IRQHandler /* USART1 */ .word USART2_IRQHandler /* USART2 */ .word 0 /* Reserved */ .word CEC_CAN_IRQHandler /* CEC and CAN */ .word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x0000 0000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x0800 0000 address, it is placed starting from the 0x0800 0000 address, which is aliased to 0x0000 0000 when the CPU boots up. Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores","title":"1. NVIC Controller"},{"location":"blog/stm32/interrupt/#2-processor-mode","text":"The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode: Which is entered on reset, and application run on this mode. Handler Mode: Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context Allows late determination of highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining)","title":"2. Processor Mode"},{"location":"blog/stm32/interrupt/#3-exception-states","text":"Each exception can be in one of the following states: Inactive : Not pending nor active. Pending : Exception event has been fired but the handler is not executed yet. Active : The exception handler has started execution but it\u2019s not over yet Interrupt nesting allows an exception to interrupt the execution of another exception\u2019s handler. In this case, both exceptions are in the active state. Active And Pending : The exception is being serviced by the processor and there is a pending exception from the same source.","title":"3. Exception States"},{"location":"blog/stm32/interrupt/#4-interrupts-tail-chaining","text":"When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing","title":"4. Interrupts Tail-Chaining"},{"location":"blog/stm32/interrupt/#5-interrupt-late-arrival","text":"The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception.","title":"5. Interrupt Late Arrival"},{"location":"blog/stm32/interrupt/#6-pre-emption","text":"The pre-emption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be pre-empted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can pre-empt it. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 pre-empted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 pre-empted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Pre-emption allow IRQ1 to be executed","title":"6. Pre-Emption"},{"location":"blog/stm32/interrupt/#7-reset-behavior","text":"When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00 which contains the end address of RAM _estack The reset handler address is loaded from address 0x04 . The reset handler gets executed in thread mode. The reset handler branches to the main program.","title":"7. Reset Behavior"},{"location":"blog/stm32/interrupt/#8-exception-behavior","text":"When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns back to main (assuming no further nesting). Here is more details: .md-typeset ol { list-style-type: decimal !important; } Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers Return From ISR (Context Restoration) Detect tail-chaining interrupt, if have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles","title":"8. Exception Behavior"},{"location":"blog/stm32/interrupt/#9-exception-priorities","text":"Lower priority level has higher priority of execution. If two or more exceptions/interrupts are of the same priority level value, the priority order is therefore determined based on the exception number itself Lower exception number has a higher priority.","title":"9. Exception Priorities"},{"location":"blog/stm32/interrupt/#10-enable-interrupts","text":"When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ) void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ) enable or disable an interrupt request number. If using a peripheral in interrupt mode, it has to enable the corresponding interrupt at NVIC","title":"10. Enable Interrupts"},{"location":"blog/stm32/interrupt/#101-external-interrupts","text":"External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIO, an EXTI line is shared by multiple pins.In one line (group), only one pin can be set to generate interrupt External Interrupt lines","title":"10.1. External Interrupts"},{"location":"blog/stm32/interrupt/#102-peripheral-interrupt","text":"When enable any user ISR, declare the ISR in the file xxx_it.c . In this file, declare a function with the name which is used in the startup file of MCU. For example: Enable interrupt on PA0 by setting EXTI0 Startup file has function pointer EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Add EXTI0_1_IRQHandler function in stm32f0xx_it.c Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed","title":"10.2. Peripheral Interrupt"},{"location":"blog/stm32/interrupt/#11-global-interrupt","text":"The CMSIS-Core package provides several macros that can be used to perform these operation: __disable_irq() and __enable_irq() automatically set and clear the PRIMASK . Any critical task can be placed between these two macros, as shown below: __disable_irq (); /* All exceptions with configurable priority are temporarily disabled. place critical code here */ ... __enable_irq (); However, take in mind that, as general rule, interrupt must be masked only for really short time, otherwise it could lose important interrupts. Remember that interrupts are not queued.","title":"11. Global Interrupt"},{"location":"blog/stm32/intro/","text":"1. ARM Cortex microcontrollers \u2693\ufe0e ARM processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM means Advanced RISC Machines . ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revision. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: .red { color: red; } Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded 1.1. Core Registers \u2693\ufe0e Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations ARM Cortex-M registers R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register. 1.2. Memory Map \u2693\ufe0e ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4GB wide, and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x0000 0000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x0800 0000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x0000 0000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x0800 0000 and 0x0000 0000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512MB is mapped to Internal SRAM: It starts at address 0x2000 0000 and can potentially extend to 0x3FFF FFFF . This area also can be aliased to the start up address at 0x0000 0000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different STM32 variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area 1.3. Bit-Banding \u2693\ufe0e In embedded applications, it is quite common to work with a single bit of a word using bit masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x2000 0000 and ends at 0x200F FFFF , and it is aliased from 0x2200 0000 to 0x23FF FFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x4000 0000 and ends at 0x400F FFFF , which is dedicated to the memory mapping of peripherals, from 0x4200 0000 to 0x43FF FFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area 1.4. Thumb Instruction Set \u2693\ufe0e ARM Cortext-M processors provide a 32-bit instructions set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state. 1.5. Instruction pipeline \u2693\ufe0e Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded. 1.6. Memory alignment \u2693\ufe0e Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations. 1.7. Interrupts and Exceptions \u2693\ufe0e Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request 1.8. System Timer \u2693\ufe0e Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen the be Interrupt Table above. 1.9. Clock source and power mode \u2693\ufe0e Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR). Run mode: full clock speed, all using peripherals are activated Sleep mode: reduced clock speed, some peripherals are suspended Deep sleep mode: clock is stopped, need external event to wake-up 1.10. CMSIS for SW development \u2693\ufe0e Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE: API for the Cortex-M processor core and peripherals CMSIS-Driver: defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP: API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack: a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD: System View Description for Peripherals CMSIS-DAP: Debug Access Port 2. STM32 Microcontrollers \u2693\ufe0e STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs with large community, free tool-chain, and many shared knowledge articles Pin-to-Pin compatibility for most of STM32 MCUs, which helps to change the MCU while keeping pin assignments 5V tolerant means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated boot loader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards 2.1. Cortex-M comparison \u2693\ufe0e A table from ARM. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes 2.2. STM32 MCUs comparison \u2693\ufe0e Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 - Corte -M4 480 MHz - 240 MHz 1 to 2 Mbytes STM32F7 Cortex-M7 216 MHz 256 Kbytes to 2 Mbytes STM32F4 Cortex-M4 180 MHz 64 Kbytes to 2 Mbytes STM32F2 Cortex-M3 120 MHz 128 Kbytes to 1 Mbyte Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 Kbytes STM32F3 Cortex-M4 72 MHz 16 to 512 Kbytes STM32F1 Cortex-M3 72 MHz 16 Kbytes to 1 Mbyte STM32G0 Cortex-M0+ 64 MHz 16 to 512 Kbytes STM32F0 Cortex-M0 48 MHz 16 to 256 Kbytes Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 Kbytes STM32L4+ Cortex-M4 120 MHz 512 Kbytes to 2 Mbytes STM32L4 Cortex-M4 80 MHz 64 Kbytes to 1 Mbyte STM32L1 Cortex-M3 32 MHz 32 to 512 Kbytes STM32L0 Cortex-M0+ 32 MHz 8 to 192 Kbytes Wireless STM32WB Cortex-M4 - Cortex-M0+ 64 MHz - 32 MHz 256 Kbytes to 1 Mbyte STM32WL Cortex-M4 48 MHz 64 Kbytes to 256 Kbytes","title":"Introduction"},{"location":"blog/stm32/intro/#1-arm-cortex-microcontrollers","text":"ARM processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM means Advanced RISC Machines . ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revision. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: .red { color: red; } Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded","title":"1. ARM Cortex microcontrollers"},{"location":"blog/stm32/intro/#11-core-registers","text":"Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations ARM Cortex-M registers R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register.","title":"1.1. Core Registers"},{"location":"blog/stm32/intro/#12-memory-map","text":"ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4GB wide, and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x0000 0000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x0800 0000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x0000 0000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x0800 0000 and 0x0000 0000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512MB is mapped to Internal SRAM: It starts at address 0x2000 0000 and can potentially extend to 0x3FFF FFFF . This area also can be aliased to the start up address at 0x0000 0000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different STM32 variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area","title":"1.2. Memory Map"},{"location":"blog/stm32/intro/#13-bit-banding","text":"In embedded applications, it is quite common to work with a single bit of a word using bit masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x2000 0000 and ends at 0x200F FFFF , and it is aliased from 0x2200 0000 to 0x23FF FFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x4000 0000 and ends at 0x400F FFFF , which is dedicated to the memory mapping of peripherals, from 0x4200 0000 to 0x43FF FFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area","title":"1.3. Bit-Banding"},{"location":"blog/stm32/intro/#14-thumb-instruction-set","text":"ARM Cortext-M processors provide a 32-bit instructions set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state.","title":"1.4. Thumb Instruction Set"},{"location":"blog/stm32/intro/#15-instruction-pipeline","text":"Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded.","title":"1.5. Instruction pipeline"},{"location":"blog/stm32/intro/#16-memory-alignment","text":"Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations.","title":"1.6. Memory alignment"},{"location":"blog/stm32/intro/#17-interrupts-and-exceptions","text":"Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request","title":"1.7. Interrupts and Exceptions"},{"location":"blog/stm32/intro/#18-system-timer","text":"Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen the be Interrupt Table above.","title":"1.8. System Timer"},{"location":"blog/stm32/intro/#19-clock-source-and-power-mode","text":"Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR). Run mode: full clock speed, all using peripherals are activated Sleep mode: reduced clock speed, some peripherals are suspended Deep sleep mode: clock is stopped, need external event to wake-up","title":"1.9. Clock source and power mode"},{"location":"blog/stm32/intro/#110-cmsis-for-sw-development","text":"Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE: API for the Cortex-M processor core and peripherals CMSIS-Driver: defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP: API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack: a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD: System View Description for Peripherals CMSIS-DAP: Debug Access Port","title":"1.10. CMSIS for SW development"},{"location":"blog/stm32/intro/#2-stm32-microcontrollers","text":"STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs with large community, free tool-chain, and many shared knowledge articles Pin-to-Pin compatibility for most of STM32 MCUs, which helps to change the MCU while keeping pin assignments 5V tolerant means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated boot loader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards","title":"2. STM32 Microcontrollers"},{"location":"blog/stm32/intro/#21-cortex-m-comparison","text":"A table from ARM. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes","title":"2.1. Cortex-M comparison"},{"location":"blog/stm32/intro/#22-stm32-mcus-comparison","text":"Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 - Corte -M4 480 MHz - 240 MHz 1 to 2 Mbytes STM32F7 Cortex-M7 216 MHz 256 Kbytes to 2 Mbytes STM32F4 Cortex-M4 180 MHz 64 Kbytes to 2 Mbytes STM32F2 Cortex-M3 120 MHz 128 Kbytes to 1 Mbyte Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 Kbytes STM32F3 Cortex-M4 72 MHz 16 to 512 Kbytes STM32F1 Cortex-M3 72 MHz 16 Kbytes to 1 Mbyte STM32G0 Cortex-M0+ 64 MHz 16 to 512 Kbytes STM32F0 Cortex-M0 48 MHz 16 to 256 Kbytes Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 Kbytes STM32L4+ Cortex-M4 120 MHz 512 Kbytes to 2 Mbytes STM32L4 Cortex-M4 80 MHz 64 Kbytes to 1 Mbyte STM32L1 Cortex-M3 32 MHz 32 to 512 Kbytes STM32L0 Cortex-M0+ 32 MHz 8 to 192 Kbytes Wireless STM32WB Cortex-M4 - Cortex-M0+ 64 MHz - 32 MHz 256 Kbytes to 1 Mbyte STM32WL Cortex-M4 48 MHz 64 Kbytes to 256 Kbytes","title":"2.2. STM32 MCUs comparison"},{"location":"blog/stm32/notes/","text":"Terminal application \u2693\ufe0e Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm Use float with printf and scanf \u2693\ufe0e newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project > Properties menu, then go to C/C++ Build > Settings > Cross ARM C++ Linker > Miscellaneous and check Use float with nano printf/scanf . DMA Polling \u2693\ufe0e The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clean the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK . DMA callbacks \u2693\ufe0e UART HAL_UART_TxCpltCallback() is not called when DMA is in Normal mode, and UART Interrupt is disabled. In UART_DMATransmitCplt() , if DMA mode is Normal mode, it will enable UART Transmit Complete Interrupt, and transfer that interrupt handling right to the UART interrupt routines Debug interrupt routine \u2693\ufe0e Even the CPU is stopped by a breakpoint in a Interrupt service routine, the other hardwares on MCU are still running, such as DMA, ADC continuous mode; This makes debugging ISR more difficult because of changed registers affected by the running peripherals. Delay in Interrupt handler \u2693\ufe0e By default, peripheral interrupts have the same priority with System Tick interrupt (0), therefore, if there is any HAL_Delay() function used in a peripheral interrupt, it will block the System tick from being called, causing tick counter won't be increased, then the delay will be an infinite loop. Fix git-revision-date-localized \u2693\ufe0e util.py/ def get_git_commit_timestamp : ... try : ret = int ( commit_timestamp ) except : ts = commit_timestamp . split ( ' \\n ' ) try : ret = ts [ len ( ts ) - 1 ] except : ret = int ( time . time ()) return ret","title":"Notes"},{"location":"blog/stm32/notes/#terminal-application","text":"Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm","title":"Terminal application"},{"location":"blog/stm32/notes/#use-float-with-printf-and-scanf","text":"newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project > Properties menu, then go to C/C++ Build > Settings > Cross ARM C++ Linker > Miscellaneous and check Use float with nano printf/scanf .","title":"Use float with printf and scanf"},{"location":"blog/stm32/notes/#dma-polling","text":"The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clean the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK .","title":"DMA Polling"},{"location":"blog/stm32/notes/#dma-callbacks","text":"UART HAL_UART_TxCpltCallback() is not called when DMA is in Normal mode, and UART Interrupt is disabled. In UART_DMATransmitCplt() , if DMA mode is Normal mode, it will enable UART Transmit Complete Interrupt, and transfer that interrupt handling right to the UART interrupt routines","title":"DMA callbacks"},{"location":"blog/stm32/notes/#debug-interrupt-routine","text":"Even the CPU is stopped by a breakpoint in a Interrupt service routine, the other hardwares on MCU are still running, such as DMA, ADC continuous mode; This makes debugging ISR more difficult because of changed registers affected by the running peripherals.","title":"Debug interrupt routine"},{"location":"blog/stm32/notes/#delay-in-interrupt-handler","text":"By default, peripheral interrupts have the same priority with System Tick interrupt (0), therefore, if there is any HAL_Delay() function used in a peripheral interrupt, it will block the System tick from being called, causing tick counter won't be increased, then the delay will be an infinite loop.","title":"Delay in Interrupt handler"},{"location":"blog/stm32/notes/#fix-git-revision-date-localized","text":"util.py/ def get_git_commit_timestamp : ... try : ret = int ( commit_timestamp ) except : ts = commit_timestamp . split ( ' \\n ' ) try : ret = ts [ len ( ts ) - 1 ] except : ret = int ( time . time ()) return ret","title":"Fix git-revision-date-localized"},{"location":"blog/stm32/redirection/","text":"UART Redirecting uart_redirecting.h uart_redirecting.c UART Redirecting setup Enable and setup an UART port Disable standard system calls Implement new system calls which communicate on the UART port Register redirected system calls on application UART Redirecting system calls Some modified system calls may not properly work with standard IO functions as custom code may not cover all cases, such as for file operations. 1. UART Redirection \u2693\ufe0e 1.1. Enable UART port \u2693\ufe0e Start a new project and follow the guide in USART - Enable UART port to enable an UART port. 1.2. System calls \u2693\ufe0e When using Semihosting , the user system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirecting also needs to disable user system calls too. Go to the file systamcall.c and select Properties > C/C++ Build >> Exclude this resources from build . Exclude systemcall.c from build 1.3. Override system calls \u2693\ufe0e Start replacing the system calls by adding in Core/Inc/uart_redirecting.h : uart_redirecting.h #ifndef INC_UART_REDIRECTING_H_ #define INC_UART_REDIRECTING_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_Redirect_UART_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTING_H_ */ then implement those functions in Core/Src/uart_redirecting.c . Here are some notes: Save the UART handler to use in internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _read() should return char by char uart_redirecting.c #include <stdio.h> #include <errno.h> #include \"uart_redirecting.h\" /* a gloable UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_Redirect_UART_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* * Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return EIO ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return EIO ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return EIO ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return EIO ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; } 1.4. Enable redirection \u2693\ufe0e In main.c , call to the register function Set_Redirect_UART_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirecting.h\" int main ( void ) { char counter = 0 ; int max = 255 ; Set_Redirect_UART_Port ( & huart1 ); ... other init functions ... printf ( \"Set max counter: \" ); scanf ( \"%d\" , & max ); printf ( \" \\n\\r Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"R:counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interact with board using UART redirecting 2. VCP Redirection \u2693\ufe0e update soon","title":"Redirection"},{"location":"blog/stm32/redirection/#1-uart-redirection","text":"","title":"1. UART Redirection"},{"location":"blog/stm32/redirection/#11-enable-uart-port","text":"Start a new project and follow the guide in USART - Enable UART port to enable an UART port.","title":"1.1. Enable UART port"},{"location":"blog/stm32/redirection/#12-system-calls","text":"When using Semihosting , the user system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirecting also needs to disable user system calls too. Go to the file systamcall.c and select Properties > C/C++ Build >> Exclude this resources from build . Exclude systemcall.c from build","title":"1.2. System calls"},{"location":"blog/stm32/redirection/#13-override-system-calls","text":"Start replacing the system calls by adding in Core/Inc/uart_redirecting.h : uart_redirecting.h #ifndef INC_UART_REDIRECTING_H_ #define INC_UART_REDIRECTING_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_Redirect_UART_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTING_H_ */ then implement those functions in Core/Src/uart_redirecting.c . Here are some notes: Save the UART handler to use in internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _read() should return char by char uart_redirecting.c #include <stdio.h> #include <errno.h> #include \"uart_redirecting.h\" /* a gloable UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_Redirect_UART_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* * Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return EIO ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return EIO ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return EIO ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return EIO ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; }","title":"1.3. Override system calls"},{"location":"blog/stm32/redirection/#14-enable-redirection","text":"In main.c , call to the register function Set_Redirect_UART_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirecting.h\" int main ( void ) { char counter = 0 ; int max = 255 ; Set_Redirect_UART_Port ( & huart1 ); ... other init functions ... printf ( \"Set max counter: \" ); scanf ( \"%d\" , & max ); printf ( \" \\n\\r Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"R:counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interact with board using UART redirecting","title":"1.4. Enable redirection"},{"location":"blog/stm32/redirection/#2-vcp-redirection","text":"update soon","title":"2. VCP Redirection"},{"location":"blog/stm32/semihosting/","text":"Semihosting Semihosting setup Connect debugger Include semihost lib in GCC linker -l rdimon --specs=rdimon.specs Exlcude syscall.c implementation Initialize in application initialise_monitor_handles(); Run OpenOCD with command monitor arm semihosting enable Semihosting notes Semihosting implementation in OpenOCD is designed so that every string must be terminated with the newline character ( \\n ) before the string appears on the OpenOCD console. Semihosting only works during a deubug session, and it's slow and affects the system performance. CPU is halt when semihosting is executing in host machine, therefore semihosting is not suitable for realtime application. 1. Debugging \u2693\ufe0e There are some debug techniques used to inspect the firmware running on ARM-based MCUs: Semihosting : build-in to every ARM chips, need adding additional library and running in debug mode Redirection: forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need USB peripheral Instrumentation Trace Macrocell (ITM): fast output over dedicated SWO pin, but it\u2019s only available on Cortex-M3+ Ways to print debug 2. Semihosting \u2693\ufe0e ARM semihosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . Semihosting is implemented by a set of defined software instructions, for example, SVCs , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting overview 2.1. Hardware setup \u2693\ufe0e Semihosting need to be run under a debug session to communicate with semihosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO . On STM32F051 Discovery board, ST-LINK module is connected to MCU on pin PA13 and PA14 . 2.2. Software setup \u2693\ufe0e To use semihosting, it has to be set in linker options, and initialized in the main program. 2.2.1. Linker options \u2693\ufe0e GNU ARM libs use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options. There is a rdimon library that implements interrupt for some special system calls, which pause the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the the newlib-nano specs. Remove nosys.specs when use rdimon . The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using command line: arm-none-eabi-gcc src.c --specs = nano.specs --specs = nosys.specs --specs = rdimon.specs Example of using GUI config: Open Project Properties >> C/C++ Build >> Settings >> Tool Settings tab >> MCU GCC Linker : Libraries: add rdimon Miscellaneous: add --specs=rdimon.specs 2.2.2. Exclude user system calls \u2693\ufe0e In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . must exclude syscalls.c from build to avoid compilation error of multiple definition . Add semihosting in GCC Linker Exclude syscalls.c 2.2.3. Initialize semihosting \u2693\ufe0e rdimon has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { /* USER CODE BEGIN 1 */ initialise_monitor_handles (); /* USER CODE END 1 */ } After that, the application can use printf() , scanf() , or gets() . 2.3. Debugger option \u2693\ufe0e The final thing is to enable semihosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. Use ST-LINK over OpenOCD with the start up command monitor arm semihosting enable . In some cases, it has to use Software Reset! Enable semihosting in debugger 3. Debug with Semihosting \u2693\ufe0e Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> extern void initialise_monitor_handles ( void ); int main ( void ) { uint8_t counter = 0 ; char buffer [ 255 ]; initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out or D:\\test.out , if not, the target file will be created in the folder containing openocd.exe . Interact with semihosting","title":"Semihosting"},{"location":"blog/stm32/semihosting/#1-debugging","text":"There are some debug techniques used to inspect the firmware running on ARM-based MCUs: Semihosting : build-in to every ARM chips, need adding additional library and running in debug mode Redirection: forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need USB peripheral Instrumentation Trace Macrocell (ITM): fast output over dedicated SWO pin, but it\u2019s only available on Cortex-M3+ Ways to print debug","title":"1. Debugging"},{"location":"blog/stm32/semihosting/#2-semihosting","text":"ARM semihosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . Semihosting is implemented by a set of defined software instructions, for example, SVCs , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting overview","title":"2. Semihosting"},{"location":"blog/stm32/semihosting/#21-hardware-setup","text":"Semihosting need to be run under a debug session to communicate with semihosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO . On STM32F051 Discovery board, ST-LINK module is connected to MCU on pin PA13 and PA14 .","title":"2.1. Hardware setup"},{"location":"blog/stm32/semihosting/#22-software-setup","text":"To use semihosting, it has to be set in linker options, and initialized in the main program.","title":"2.2. Software setup"},{"location":"blog/stm32/semihosting/#221-linker-options","text":"GNU ARM libs use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options. There is a rdimon library that implements interrupt for some special system calls, which pause the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the the newlib-nano specs. Remove nosys.specs when use rdimon . The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using command line: arm-none-eabi-gcc src.c --specs = nano.specs --specs = nosys.specs --specs = rdimon.specs Example of using GUI config: Open Project Properties >> C/C++ Build >> Settings >> Tool Settings tab >> MCU GCC Linker : Libraries: add rdimon Miscellaneous: add --specs=rdimon.specs","title":"2.2.1. Linker options"},{"location":"blog/stm32/semihosting/#222-exclude-user-system-calls","text":"In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . must exclude syscalls.c from build to avoid compilation error of multiple definition . Add semihosting in GCC Linker Exclude syscalls.c","title":"2.2.2. Exclude user system calls"},{"location":"blog/stm32/semihosting/#223-initialize-semihosting","text":"rdimon has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { /* USER CODE BEGIN 1 */ initialise_monitor_handles (); /* USER CODE END 1 */ } After that, the application can use printf() , scanf() , or gets() .","title":"2.2.3. Initialize semihosting"},{"location":"blog/stm32/semihosting/#23-debugger-option","text":"The final thing is to enable semihosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. Use ST-LINK over OpenOCD with the start up command monitor arm semihosting enable . In some cases, it has to use Software Reset! Enable semihosting in debugger","title":"2.3. Debugger option"},{"location":"blog/stm32/semihosting/#3-debug-with-semihosting","text":"Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> extern void initialise_monitor_handles ( void ); int main ( void ) { uint8_t counter = 0 ; char buffer [ 255 ]; initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out or D:\\test.out , if not, the target file will be created in the folder containing openocd.exe . Interact with semihosting","title":"3. Debug with Semihosting"},{"location":"blog/stm32/timers/","text":"1. Timer overview \u2693\ufe0e A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as \"master\". The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. Let's see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1:1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, or vice-versa. When driven by an external input, such as external pulse or button, timer can be used to count the number of events happened, and measure the frequency. update soon","title":"Timer"},{"location":"blog/stm32/timers/#1-timer-overview","text":"A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as \"master\". The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. Let's see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1:1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, or vice-versa. When driven by an external input, such as external pulse or button, timer can be used to count the number of events happened, and measure the frequency. update soon","title":"1. Timer overview"},{"location":"blog/stm32/toolchain/","text":"1. Toolchain \u2693\ufe0e A tool-chain is a set of programs, compilers, and tools that allows developers to: Write code and navigate inside source files of the project Navigate inside the application code, allowing developers to inspect variables, function definitions / declarations, and so on Compile the source code using a cross-platform compiler Upload the executable application on the target board Monitor, inspect and debug the application on the board Example of a toolchain STMicroelectronics offers a complete tool-chain for STM32 MCUs as below: STM32 Toolchain STM32CubeMX is used for Device Configuration and Code Generation STM32CubeIDE is fully integrated IDE which includes: Eclipse IDE - an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build scripts GNU ARM Cross-compiler with ST patch for STM32 MCUs - a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex) GDB for inspecting, debugging the running application STM32CubeProg is a programmer that downloads the .elf or .bin file to the target MCU's flash. It has drivers to communicate with the MCUs: ST-LINK GDB or ST-LINK openOCD debugger to probe the target MCUs STM32 helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time Cross-compiler A compiler is just a language translator from a given programming language (e.g. C/C++) to a low-level machine language, also known as assembly . A cross-platform compiler is a compiler that is able to generate machine code for a hardware machine different from the one which is being used to develop the applications . In this case, the GCC ARM Embedded compiler generates machine code for Cortex-M processors while compiling on an x86 machine with a given OS (e.g. Windows or Mac OSX). Example of Cross-Compiler for MIPS on Linux 2. Target board \u2693\ufe0e Example Target board This post uses STM32F0 Discovery kit as an example board to practice. There are many Discovery, Evaluation or Nucleo boards sharing the same knowledge to work on them. Please pay attention to check the pin names, the pin assignments on the target processor. The STM32F0 Discovery board is a low-cost and easy-to-use development kit to quickly evaluate and start development with an STM32 F0 series microcontroller. It offers the following features: STM32F051R8T6 Cortex\u00ae-M0 microcontroller featuring 64 KB Flash memory, 8 KB RAM in an LQFP64 package On-board ST-LINK/V2 with selection mode switch to use the kit as a standalone ST-LINK/V2 (with SWD connector for programming and debugging) Board power supply: through USB bus or from an external 5V supply voltage Four LEDs: LD1 (red) for 3.3 V power on LD2 (red/green) for USB communication LD3 (green) for PC9 output LD4 (blue) for PC8 output Two push buttons (user and reset) STM32F0 Discovery Board The Cortex-M0 processor implements the ARMv6-M architecture, which is based on the 16-bit Thumb\u00ae instruction set and includes Thumb-2 technology. Read about ARM . STM32F051 has 32-bit low- and medium-density advanced ARM\u2122 MCU with a high-performance ARM Cortex\u2122-M0 32-bit RISC core which has 64 Kbytes Flash, 8 Kbytes RAM, RTC, timers, ADC, DAC, comparators and communication interfaces: Core and operating conditions ARM\u00ae Cortex\u2122-M0 0.9 DMIPS/MHz up to 48 MHz 1.8/2.0 to 3.6 V supply range High-performance connectivity 6 Mbit/s USART 18 Mbit/s SPI with 4- to 16-bit data frame 1 Mbit/s I\u00b2C fast-mode plus HDMI CEC Enhanced control 1x 16-bit 3-phase PWM motor control timer 5x 16-bit PWM timers 1x 16-bit basic timer 1x 32-bit PWM timer 12 MHz I/O toggling Integrated debugger The ST-LINK/V2 programming and debugging tool is integrated on the STM32F0 Discovery board. Do not need any external ST-LINK debugger. Make sure the CN2 jumpers are connected to debug the on-board processor. 3. STM32CubeIDE \u2693\ufe0e Based on Eclipse\u00ae/CDT, with support for Eclipse\u00ae add-ons, GNU C/C++ for Arm\u00ae toolchain and GDB debugger Integration of services from STM32CubeMX: STM32 microcontroller, microprocessor, development platform and example project selection Pinout, clock, peripheral, and middleware configuration Project creation and generation of the initialization code Software and middleware completed with enhanced STM32Cube Expansion Packages Additional advanced debug features including: CPU core, peripheral register, and memory views Live variable watch view System analysis and real-time tracing (SWV) CPU fault analysis tool RTOS-aware debug support including Azure\u00ae RTOS ThreadX and FreeRTOS\u2122 Kernel Support for ST-LINK (STMicroelectronics) and J-Link (SEGGER) debug probes IDEs that support ARM Cortex: ST\u00ae, STM32CubeIDE\u00ae: free, native support, highly integrate with MX tools ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license 3.1. Installation \u2693\ufe0e Download STM32CubeIDE Need to register a free account to download from ST website. Just need email to verify. During the installation, please check to install ST-LINK and SEGGER J-Link drivers. 3.2. Create a workspace \u2693\ufe0e When start the program, it will ask to select a directory as workspace - the location to save projects. Consider to make new workspace for different big projects. 3.3. Create a project \u2693\ufe0e It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. STM32CubeIDE includes STM32CubeMX which can generate code from Device Configuration settings. The output C code project is compliant with IAR\u2122, Keil\u00ae and STM32CubeIDE (GCC compilers) for Arm\u00aeCortex\u00ae-M core. UM1718 STM32CubeMX User Manual 3.3.1. Select target MCU \u2693\ufe0e When start a new STM32 project, IDE shows up the Target Selection screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. Select STM32F0 Discovery board IDE will run a screen named Device Configuration Tool , in there, it's easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board - usually including ST-Link pins, on-board buttons, LEDs, USB connect. Device Configuration Tool screen 3.3.2. Pinout Config \u2693\ufe0e Using tab Pinout & Configuration to enable supported features on the target processor. Configure peripheral and pin assignment Quick pin assignment Do a Left click on a pin and select the pin function Do a Right click to assign a custom name for that pin. 3.3.3. Clock Config \u2693\ufe0e Next tab is Clock Configuration where to adjust the clock frequency, clock paths in the processor. Notice the PLL and System Clock Mux which control SYSCLK , Bus clocks, and peripheral clock (Timers, I2C, USART, etc.). There are some registers to fill in pre-scaler values which will change the clock frequency of the Bus and peripherals. 3.3.4. Project settings \u2693\ufe0e In the tab Project Manager , there are settings for specific features: Linker settings for Heap Firmware version Code generator Driver function type Configure clock paths and frequency Configure settings for project 3.3.5. Power Tools \u2693\ufe0e There is a tool called Power Consumption Calculator (PCC) to help defining power modes by selecting which peripheral is enabled or disabled, clock frequency, and clock path for each mode. Configure power modes 3.4. Generate Code \u2693\ufe0e After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing alt + k or choosing menu Project >> Generate Code . When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor's registers. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library).This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR.The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 have assert_failed() implementation \u2022 set system clock configuration \u2022 declare peripheral HAL initialization \u2022 user application code. 3.5. Add user code \u2693\ufe0e User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. /* Private includes */ /* USER CODE BEGIN Includes */ < code goes here > /* USER CODE END Includes */ /* Private define */ /* USER CODE BEGIN PD */ < code goes here > /* USER CODE END PD */ STM32CubeIDE based on Eclipse\u00ae/CDT 3.6. Build project \u2693\ufe0e Build the application by pressing ctrl + b , or in menu Project >> Build All . There are some reports about the resource usage to check after compilation. The first thing to check is the memory usage, in term of RAM and FLASH free space. Memory usage in Build report 3.7. Run on board \u2693\ufe0e If code is compiled successfully, hit menu Run >> Run to setup a run configuration and download executable file to board. Leave every settings as default at this time, then check the debugging probe is set to ST-LINK by default. 3.8. Debug on board \u2693\ufe0e The IDE has debugging function and can be invoked by F11 key. It will set a break point at the main() function by default. There are some views to help debugging easier. Edit run config on target board Debugging screen 4. Documents \u2693\ufe0e In embedded programming, documents have a very important role as they are the main reference source for developers to know how the processor works and how to configure it. Those documents mainly come from the processor manufacture. STM32CubeIDE has a better way to list all related documents of selected processor, and it can download documents too. Find the documents in menu Help >> Target device docs and resources . Access to the list of documents The most important documents Below sections are the documents that must be read in order to understand about the processor and its peripherals. 4.1. Processor Datasheet \u2693\ufe0e DSxxxx - ARM-based MCU Datasheet E.g: DS8668 ARM-based 32-bit MCU, 16 to 64 KB Flash, 11 timers, ADC, DAC and communication interfaces, 2.0-3.6 V (version 7) This document shows below information: Functional features Memory Mapping, Boot Mode Pinouts and altenative functions Core and Peripherals' diagrams, protocols RMxxxx - Reference Manual E.g: RM0091 - Reference manual for STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM-based 32-bit MCUs This is a very important document as it defines all register structure, bit-fields to control core and peripherals. This document includes: System Architecture, Register-Level designs Memory Mapping and Boot configuration Register name and bit-fields for all accessible registers PMxxxx\" Programming Manual E.g: PM0215 - STM32F0xxx Cortex-M0 programming manual The main content is: Processor modes: in application and interruption routine Stacks: manage context's data Core Registers: contain instruction's data and result, system status Memory Model: fixed memory map with address ranges Vector Table: start address, stack pointer, and interruption handlers Sleep mode: condition about clock, data rate, regiter mode Instruction set: assembly mnemonic for instructions Core registers: Address and Name of registers used in core and peripherals. This is the based for programming the processor. It also have API function name for accessing the registers using CMSIS. ANxxxx - Application Note E.g: AN2548 Using the STM32F0/F1/F3/Gx/Lx Series DMA controller (version 7) This type of document show: How to implement a specific problem in application Related configuration and library 4.2. Board schematic \u2693\ufe0e MBxxxx - Mainboard schematic E.g: MB1034 RevB.0 - STM32F0-DISCOVERY Schematic Check the version of hardware on the board, such as MB1034B . Go to ST website and download the corresponding schematic, or find it in User Manual document. This document includes: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors) Working conditions (Power level, Votage Level torelance) UMxxxx - User Manual E.g. UM1525 - Discovery kit for STM32F0 microcontrollers Main content includes: Hardware components and their locations and markers Pinouts and jumpers for connections or configurations Solder Bridges for enabling/disabling features or hardware connections Mainboard schematic 4.3. Library Manual \u2693\ufe0e UMxxxx - Description of HAL and Low-Layer driver E.g. UM1785 - Description of STM32F0 HAL and low-layer drivers This document describes HAL and LL APIs for programming. Those functions wrap all internal registers and settings, and create a friendly function names and data structure for developer. The HAL drivers include a set of driver modules, each module being linked to a standalone peripheral. The HAL main features are the following: Cross-family portable set of APIs covering the common peripheral features as well as extension APIs in case of specific peripheral features. Three API programming models: polling, interrupt and DMA. APIs are RTOS compliant: Fully reentrant APIs Systematic usage of timeouts in polling mode Support of peripheral multi-instance allowing concurrent API calls for multiple instances of a given peripheral (USART1, USART2, etc.) All HAL APIs implement user-callback functions mechanism: Peripheral Init/DeInit HAL APIs can call user-callback functions to perform peripheral system level. Initialization/De-Initialization (clock, GPIOs, interrupt, DMA) Peripherals interrupt events Error events Object locking mechanism: safe hardware access to prevent multiple spurious accesses to shared resources Timeout used for all blocking processes: the timeout can be a simple counter or a time base UMxxxx - Developing applications with RTOS E.g. UM1722 - Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard Refer to https://developer.arm.com/tools-and-software/embedded/cmsis or the package https://developer.arm.com/embedded/cmsis/cmsis-packs/devices/STMicroelectronics/STM32F051R8 ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process. 4.4. Source code \u2693\ufe0e HAL and CMSIS packages provide open source code with detailed comments. They are very useful when navigating between source files and function declarations within an IDE. In each HAL file, there is a comment section that describes the usage of that HAL driver. Usage is written in the source code 4.5. Websites \u2693\ufe0e There are plenty open resource to learn on the internet. Here are some websites that have something new to learn every times visit by. STM32 Education : official courses from ST STM32-base : Templates and settings for starting new STM32 projects","title":"Tools and Docs"},{"location":"blog/stm32/toolchain/#1-toolchain","text":"A tool-chain is a set of programs, compilers, and tools that allows developers to: Write code and navigate inside source files of the project Navigate inside the application code, allowing developers to inspect variables, function definitions / declarations, and so on Compile the source code using a cross-platform compiler Upload the executable application on the target board Monitor, inspect and debug the application on the board Example of a toolchain STMicroelectronics offers a complete tool-chain for STM32 MCUs as below: STM32 Toolchain STM32CubeMX is used for Device Configuration and Code Generation STM32CubeIDE is fully integrated IDE which includes: Eclipse IDE - an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build scripts GNU ARM Cross-compiler with ST patch for STM32 MCUs - a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex) GDB for inspecting, debugging the running application STM32CubeProg is a programmer that downloads the .elf or .bin file to the target MCU's flash. It has drivers to communicate with the MCUs: ST-LINK GDB or ST-LINK openOCD debugger to probe the target MCUs STM32 helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time Cross-compiler A compiler is just a language translator from a given programming language (e.g. C/C++) to a low-level machine language, also known as assembly . A cross-platform compiler is a compiler that is able to generate machine code for a hardware machine different from the one which is being used to develop the applications . In this case, the GCC ARM Embedded compiler generates machine code for Cortex-M processors while compiling on an x86 machine with a given OS (e.g. Windows or Mac OSX). Example of Cross-Compiler for MIPS on Linux","title":"1. Toolchain"},{"location":"blog/stm32/toolchain/#2-target-board","text":"Example Target board This post uses STM32F0 Discovery kit as an example board to practice. There are many Discovery, Evaluation or Nucleo boards sharing the same knowledge to work on them. Please pay attention to check the pin names, the pin assignments on the target processor. The STM32F0 Discovery board is a low-cost and easy-to-use development kit to quickly evaluate and start development with an STM32 F0 series microcontroller. It offers the following features: STM32F051R8T6 Cortex\u00ae-M0 microcontroller featuring 64 KB Flash memory, 8 KB RAM in an LQFP64 package On-board ST-LINK/V2 with selection mode switch to use the kit as a standalone ST-LINK/V2 (with SWD connector for programming and debugging) Board power supply: through USB bus or from an external 5V supply voltage Four LEDs: LD1 (red) for 3.3 V power on LD2 (red/green) for USB communication LD3 (green) for PC9 output LD4 (blue) for PC8 output Two push buttons (user and reset) STM32F0 Discovery Board The Cortex-M0 processor implements the ARMv6-M architecture, which is based on the 16-bit Thumb\u00ae instruction set and includes Thumb-2 technology. Read about ARM . STM32F051 has 32-bit low- and medium-density advanced ARM\u2122 MCU with a high-performance ARM Cortex\u2122-M0 32-bit RISC core which has 64 Kbytes Flash, 8 Kbytes RAM, RTC, timers, ADC, DAC, comparators and communication interfaces: Core and operating conditions ARM\u00ae Cortex\u2122-M0 0.9 DMIPS/MHz up to 48 MHz 1.8/2.0 to 3.6 V supply range High-performance connectivity 6 Mbit/s USART 18 Mbit/s SPI with 4- to 16-bit data frame 1 Mbit/s I\u00b2C fast-mode plus HDMI CEC Enhanced control 1x 16-bit 3-phase PWM motor control timer 5x 16-bit PWM timers 1x 16-bit basic timer 1x 32-bit PWM timer 12 MHz I/O toggling Integrated debugger The ST-LINK/V2 programming and debugging tool is integrated on the STM32F0 Discovery board. Do not need any external ST-LINK debugger. Make sure the CN2 jumpers are connected to debug the on-board processor.","title":"2. Target board"},{"location":"blog/stm32/toolchain/#3-stm32cubeide","text":"Based on Eclipse\u00ae/CDT, with support for Eclipse\u00ae add-ons, GNU C/C++ for Arm\u00ae toolchain and GDB debugger Integration of services from STM32CubeMX: STM32 microcontroller, microprocessor, development platform and example project selection Pinout, clock, peripheral, and middleware configuration Project creation and generation of the initialization code Software and middleware completed with enhanced STM32Cube Expansion Packages Additional advanced debug features including: CPU core, peripheral register, and memory views Live variable watch view System analysis and real-time tracing (SWV) CPU fault analysis tool RTOS-aware debug support including Azure\u00ae RTOS ThreadX and FreeRTOS\u2122 Kernel Support for ST-LINK (STMicroelectronics) and J-Link (SEGGER) debug probes IDEs that support ARM Cortex: ST\u00ae, STM32CubeIDE\u00ae: free, native support, highly integrate with MX tools ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license","title":"3. STM32CubeIDE"},{"location":"blog/stm32/toolchain/#31-installation","text":"Download STM32CubeIDE Need to register a free account to download from ST website. Just need email to verify. During the installation, please check to install ST-LINK and SEGGER J-Link drivers.","title":"3.1. Installation"},{"location":"blog/stm32/toolchain/#32-create-a-workspace","text":"When start the program, it will ask to select a directory as workspace - the location to save projects. Consider to make new workspace for different big projects.","title":"3.2. Create a workspace"},{"location":"blog/stm32/toolchain/#33-create-a-project","text":"It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. STM32CubeIDE includes STM32CubeMX which can generate code from Device Configuration settings. The output C code project is compliant with IAR\u2122, Keil\u00ae and STM32CubeIDE (GCC compilers) for Arm\u00aeCortex\u00ae-M core. UM1718 STM32CubeMX User Manual","title":"3.3. Create a project"},{"location":"blog/stm32/toolchain/#331-select-target-mcu","text":"When start a new STM32 project, IDE shows up the Target Selection screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. Select STM32F0 Discovery board IDE will run a screen named Device Configuration Tool , in there, it's easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board - usually including ST-Link pins, on-board buttons, LEDs, USB connect. Device Configuration Tool screen","title":"3.3.1. Select target MCU"},{"location":"blog/stm32/toolchain/#332-pinout-config","text":"Using tab Pinout & Configuration to enable supported features on the target processor. Configure peripheral and pin assignment Quick pin assignment Do a Left click on a pin and select the pin function Do a Right click to assign a custom name for that pin.","title":"3.3.2. Pinout Config"},{"location":"blog/stm32/toolchain/#333-clock-config","text":"Next tab is Clock Configuration where to adjust the clock frequency, clock paths in the processor. Notice the PLL and System Clock Mux which control SYSCLK , Bus clocks, and peripheral clock (Timers, I2C, USART, etc.). There are some registers to fill in pre-scaler values which will change the clock frequency of the Bus and peripherals.","title":"3.3.3. Clock Config"},{"location":"blog/stm32/toolchain/#334-project-settings","text":"In the tab Project Manager , there are settings for specific features: Linker settings for Heap Firmware version Code generator Driver function type Configure clock paths and frequency Configure settings for project","title":"3.3.4. Project settings"},{"location":"blog/stm32/toolchain/#335-power-tools","text":"There is a tool called Power Consumption Calculator (PCC) to help defining power modes by selecting which peripheral is enabled or disabled, clock frequency, and clock path for each mode. Configure power modes","title":"3.3.5. Power Tools"},{"location":"blog/stm32/toolchain/#34-generate-code","text":"After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing alt + k or choosing menu Project >> Generate Code . When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor's registers. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library).This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR.The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 have assert_failed() implementation \u2022 set system clock configuration \u2022 declare peripheral HAL initialization \u2022 user application code.","title":"3.4. Generate Code"},{"location":"blog/stm32/toolchain/#35-add-user-code","text":"User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. /* Private includes */ /* USER CODE BEGIN Includes */ < code goes here > /* USER CODE END Includes */ /* Private define */ /* USER CODE BEGIN PD */ < code goes here > /* USER CODE END PD */ STM32CubeIDE based on Eclipse\u00ae/CDT","title":"3.5. Add user code"},{"location":"blog/stm32/toolchain/#36-build-project","text":"Build the application by pressing ctrl + b , or in menu Project >> Build All . There are some reports about the resource usage to check after compilation. The first thing to check is the memory usage, in term of RAM and FLASH free space. Memory usage in Build report","title":"3.6. Build project"},{"location":"blog/stm32/toolchain/#37-run-on-board","text":"If code is compiled successfully, hit menu Run >> Run to setup a run configuration and download executable file to board. Leave every settings as default at this time, then check the debugging probe is set to ST-LINK by default.","title":"3.7. Run on board"},{"location":"blog/stm32/toolchain/#38-debug-on-board","text":"The IDE has debugging function and can be invoked by F11 key. It will set a break point at the main() function by default. There are some views to help debugging easier. Edit run config on target board Debugging screen","title":"3.8. Debug on board"},{"location":"blog/stm32/toolchain/#4-documents","text":"In embedded programming, documents have a very important role as they are the main reference source for developers to know how the processor works and how to configure it. Those documents mainly come from the processor manufacture. STM32CubeIDE has a better way to list all related documents of selected processor, and it can download documents too. Find the documents in menu Help >> Target device docs and resources . Access to the list of documents The most important documents Below sections are the documents that must be read in order to understand about the processor and its peripherals.","title":"4. Documents"},{"location":"blog/stm32/toolchain/#41-processor-datasheet","text":"DSxxxx - ARM-based MCU Datasheet E.g: DS8668 ARM-based 32-bit MCU, 16 to 64 KB Flash, 11 timers, ADC, DAC and communication interfaces, 2.0-3.6 V (version 7) This document shows below information: Functional features Memory Mapping, Boot Mode Pinouts and altenative functions Core and Peripherals' diagrams, protocols RMxxxx - Reference Manual E.g: RM0091 - Reference manual for STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM-based 32-bit MCUs This is a very important document as it defines all register structure, bit-fields to control core and peripherals. This document includes: System Architecture, Register-Level designs Memory Mapping and Boot configuration Register name and bit-fields for all accessible registers PMxxxx\" Programming Manual E.g: PM0215 - STM32F0xxx Cortex-M0 programming manual The main content is: Processor modes: in application and interruption routine Stacks: manage context's data Core Registers: contain instruction's data and result, system status Memory Model: fixed memory map with address ranges Vector Table: start address, stack pointer, and interruption handlers Sleep mode: condition about clock, data rate, regiter mode Instruction set: assembly mnemonic for instructions Core registers: Address and Name of registers used in core and peripherals. This is the based for programming the processor. It also have API function name for accessing the registers using CMSIS. ANxxxx - Application Note E.g: AN2548 Using the STM32F0/F1/F3/Gx/Lx Series DMA controller (version 7) This type of document show: How to implement a specific problem in application Related configuration and library","title":"4.1. Processor Datasheet"},{"location":"blog/stm32/toolchain/#42-board-schematic","text":"MBxxxx - Mainboard schematic E.g: MB1034 RevB.0 - STM32F0-DISCOVERY Schematic Check the version of hardware on the board, such as MB1034B . Go to ST website and download the corresponding schematic, or find it in User Manual document. This document includes: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors) Working conditions (Power level, Votage Level torelance) UMxxxx - User Manual E.g. UM1525 - Discovery kit for STM32F0 microcontrollers Main content includes: Hardware components and their locations and markers Pinouts and jumpers for connections or configurations Solder Bridges for enabling/disabling features or hardware connections Mainboard schematic","title":"4.2. Board schematic"},{"location":"blog/stm32/toolchain/#43-library-manual","text":"UMxxxx - Description of HAL and Low-Layer driver E.g. UM1785 - Description of STM32F0 HAL and low-layer drivers This document describes HAL and LL APIs for programming. Those functions wrap all internal registers and settings, and create a friendly function names and data structure for developer. The HAL drivers include a set of driver modules, each module being linked to a standalone peripheral. The HAL main features are the following: Cross-family portable set of APIs covering the common peripheral features as well as extension APIs in case of specific peripheral features. Three API programming models: polling, interrupt and DMA. APIs are RTOS compliant: Fully reentrant APIs Systematic usage of timeouts in polling mode Support of peripheral multi-instance allowing concurrent API calls for multiple instances of a given peripheral (USART1, USART2, etc.) All HAL APIs implement user-callback functions mechanism: Peripheral Init/DeInit HAL APIs can call user-callback functions to perform peripheral system level. Initialization/De-Initialization (clock, GPIOs, interrupt, DMA) Peripherals interrupt events Error events Object locking mechanism: safe hardware access to prevent multiple spurious accesses to shared resources Timeout used for all blocking processes: the timeout can be a simple counter or a time base UMxxxx - Developing applications with RTOS E.g. UM1722 - Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard Refer to https://developer.arm.com/tools-and-software/embedded/cmsis or the package https://developer.arm.com/embedded/cmsis/cmsis-packs/devices/STMicroelectronics/STM32F051R8 ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process.","title":"4.3. Library Manual"},{"location":"blog/stm32/toolchain/#44-source-code","text":"HAL and CMSIS packages provide open source code with detailed comments. They are very useful when navigating between source files and function declarations within an IDE. In each HAL file, there is a comment section that describes the usage of that HAL driver. Usage is written in the source code","title":"4.4. Source code"},{"location":"blog/stm32/toolchain/#45-websites","text":"There are plenty open resource to learn on the internet. Here are some websites that have something new to learn every times visit by. STM32 Education : official courses from ST STM32-base : Templates and settings for starting new STM32 projects","title":"4.5. Websites"},{"location":"blog/stm32/usart/","text":"Polling Interrupt 1. Hardware \u2693\ufe0e Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire. 1.1. Wires \u2693\ufe0e When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pairs of lines for Transmitter (TX) and Receiver (RX): USART vs UART 1.2. Flow control \u2693\ufe0e The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485 , provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send(RTS) and Clear To Send(CTS): the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line. 1.3. Data frame \u2693\ufe0e The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) least significant bit first 0.5, 1, 1.5, 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART 1.4. Clock \u2693\ufe0e The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC))). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling 1.5. Baud rate \u2693\ufe0e Baud rate determines the speed of transmitting and receiving, as the speed is depend on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV. When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with fCK = 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value. 1.6. Multiprocessor \u2693\ufe0e In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL, IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master. 2. Memory Map \u2693\ufe0e Refer to Datasheet document of the target MCU. For example, DS8668 for STM32F051x. 3. Register Map \u2693\ufe0e Refer to Reference Manual document of the target MCU. For example, RM0091 for STM32F051x. 4. HAL Software \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. ST HAL define a handler for USART ports like below: typedef struct { USART_TypeDef * Instance ; /* UART registers base address */ UART_InitTypeDef Init ; /* UART communication parameters */ UART_AdvFeatureInitTypeDef AdvancedInit ; /* UART Advanced Features initialization parameters */ uint8_t * pTxBuffPtr ; /* Pointer to UART Tx transfer Buffer */ uint16_t TxXferSize ; /* UART Tx Transfer size */ uint16_t TxXferCount ; /* UART Tx Transfer Counter */ uint8_t * pRxBuffPtr ; /* Pointer to UART Rx transfer Buffer */ uint16_t RxXferSize ; /* UART Rx Transfer size */ uint16_t RxXferCount ; /* UART Rx Transfer Counter */ DMA_HandleTypeDef * hdmatx ; /* UART Tx DMA Handle parameters */ DMA_HandleTypeDef * hdmarx ; /* UART Rx DMA Handle parameters */ HAL_LockTypeDef Lock ; /* Locking object */ __IO HAL_UART_StateTypeDef State ; /* UART communication state */ __IO HAL_UART_ErrorTypeDef ErrorCode ; /* UART Error code */ } UART_HandleTypeDef ; excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle Init structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,...) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API. 5. Lab: Polling mode \u2693\ufe0e This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the most simple form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Target board: STM32F0 Discovery Application requirements: Enable USART1 on board Transmit a log with increasing counter every 1 second 5.1. Enable USART1 \u2693\ufe0e Create new project via CubeMX and use default settings for the discovery board. Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 b (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout. 5.2. Generated code \u2693\ufe0e When generate code from Pin configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Init functions The function SystemClock_Config() is included to setup the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() inits the USART1 instance with the values put into the init struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the init params and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will setup the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } } 5.3. Send data \u2693\ufe0e With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let's make a buffer, a counter, and a message every 1 second. #include <stdio.h> // sprintf #include <string.h> // strlen int main ( void ) { char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r while ( 1 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } } 5.4. Connect UART to PC \u2693\ufe0e Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter. Then connect pins PA9 and PA10 to UART terminal on PC. It's recommend to check the voltage because board is running at 3.3V while PC USB or COM port is running at 5V. Another option is that an Arduino Uno can be used as a COM bridge if put the MCU into inactive state by connecting RESET pin to GND, and directly use both TX, RX pins which are connected to Arduino Virtual COM port. 5.5. Build and Run \u2693\ufe0e Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyser to see raw bits transferred in RX and TX pins. UART output on digital logic analyser 5.6. Receive data \u2693\ufe0e Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Target board: STM32F0 Discovery Application requirements: Read data from UART If data is \"stop\", then do not print counter value If data is \"resume\", then resuming printing counter value Use this function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 6, 2000) , which means: All received data is written into buffer (re-use it ^^) Function will exit if one of the below condition meets: 6 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let's see the modified code, with return result is checked to print the debug information. const char msg_ok [] = \" \\t OK \\n\\r \" ; const char msg_busy [] = \" \\t BUSY \\n\\r \" ; const char msg_error [] = \" \\t ERROR \\n\\r \" ; const char msg_timeout [] = \" \\t TIME OUT \\n\\r \" ; int main ( void ) { char pause = 0 ; char counter = 0 ; char buffer [ 16 ] = { 0 }; HAL_StatusTypeDef ret ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , 6 , 2000 ); // try to use HAL_MAX_DELAY to see the effect if ( ret == HAL_OK ) { HAL_UART_Transmit ( & huart1 , msg_ok , strlen ( msg_ok ), HAL_MAX_DELAY ); } else if ( ret == HAL_BUSY ) { HAL_UART_Transmit ( & huart1 , msg_busy , strlen ( msg_busy ), HAL_MAX_DELAY ); } else if ( ret == HAL_ERROR ) { HAL_UART_Transmit ( & huart1 , msg_error , strlen ( msg_error ), HAL_MAX_DELAY ); } else if ( ret == HAL_TIMEOUT ) { HAL_UART_Transmit ( & huart1 , msg_timeout , strlen ( msg_timeout ), HAL_MAX_DELAY ); } if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; } else if ( strncmp ( buffer , \"resume\" , 6 ) == 0 ) { pause = 0 ; } Debug to see the received status Bug: Uncontrollable input It's hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR). 6. Lab: Interrupt Mode \u2693\ufe0e 6.1. Interruptions \u2693\ufe0e Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The CubeHAL is designed to automatically do this job for us. Then user is warned about the interrupt generation thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() , which must be called inside the ISR. From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is not asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the function HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() are designed so that they do not wait for data transmission completion, but the dirty job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated. 6.2. Enable interrupt \u2693\ufe0e Go to USART1 module, select NVIC Settings and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); } 6.3. Use interrupt \u2693\ufe0e Send data Finally, use HAL_UART_Transmit_IT() function to send data. while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } HAL_Delay ( 1000 ); } When all data in the buffer are sent, HAL library will call a HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transfered Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , COUNTOF ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , COUNTOF ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , COUNTOF ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , ) strings [ i ], COUNTOF () strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } Receive data Next step is to read data using interrupt. Because it's unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in sprinf() , therefore, should use a new buffer to store received data, e.g. cmd[] . When the receiver get enough characters, it will fire an interrupt to run a the HAL_UART_RxCpltCallback() function. That function can be overriden to handle received data: char rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { rx_int = 1 ; } } In the main function, process received data only when the flag is on: Add delay after calling HAL_UART_Transmit_IT() to make sure the transmittion will be complete. const char msg_rx_int [] = \" \\t RX INT \\n\\r \" ; int main ( void ) { char cmd [ 6 ] = { 0 }; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"I:counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } HAL_Delay ( 50 ); // Must have delay for transmition to complete /* use buffer may not work, because sprintf in main loop may be filling the buffer */ ret = HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) cmd , 6 ); if ( ret == HAL_OK ) { HAL_UART_Transmit ( & huart1 , msg_ok , strlen ( msg_ok ), HAL_MAX_DELAY ); } else if ( ret == HAL_BUSY ) { HAL_UART_Transmit ( & huart1 , msg_busy , strlen ( msg_busy ), HAL_MAX_DELAY ); } else if ( ret == HAL_ERROR ) { HAL_UART_Transmit ( & huart1 , msg_error , strlen ( msg_error ), HAL_MAX_DELAY ); } else if ( ret == HAL_TIMEOUT ) { HAL_UART_Transmit ( & huart1 , msg_timeout , strlen ( msg_timeout ), HAL_MAX_DELAY ); } if ( rx_int == 1 ) { rx_int = 0 ; HAL_UART_Transmit ( & huart1 , msg_rx_int , strlen ( msg_rx_int ), HAL_MAX_DELAY ); HAL_UART_Transmit ( & huart1 , cmd , strlen ( cmd ), HAL_MAX_DELAY ); if ( strncmp ( cmd , \"stop\" , 4 ) == 0 ) { pause = 1 ; } else if ( strncmp ( cmd , \"resume\" , 6 ) == 0 ) { pause = 0 ; } } HAL_Delay ( 500 ); } } Build and run applocation code, it should work much better than the Polling version, because whenver a character is sent to the board, it will be received correclty. Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the newline \\n or carriage return \\r character to to determine input sectences. However, this will lead to run the interrupt handler many times. 7. Lab: DMA mode \u2693\ufe0e Refer to DMA Memory to UART TX 8. Appendix \u2693\ufe0e Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips.","title":"USART"},{"location":"blog/stm32/usart/#1-hardware","text":"Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire.","title":"1. Hardware"},{"location":"blog/stm32/usart/#11-wires","text":"When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pairs of lines for Transmitter (TX) and Receiver (RX): USART vs UART","title":"1.1. Wires"},{"location":"blog/stm32/usart/#12-flow-control","text":"The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485 , provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send(RTS) and Clear To Send(CTS): the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line.","title":"1.2. Flow control"},{"location":"blog/stm32/usart/#13-data-frame","text":"The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) least significant bit first 0.5, 1, 1.5, 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART","title":"1.3. Data frame"},{"location":"blog/stm32/usart/#14-clock","text":"The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC))). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling","title":"1.4. Clock"},{"location":"blog/stm32/usart/#15-baud-rate","text":"Baud rate determines the speed of transmitting and receiving, as the speed is depend on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV. When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with fCK = 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value.","title":"1.5. Baud rate"},{"location":"blog/stm32/usart/#16-multiprocessor","text":"In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL, IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master.","title":"1.6. Multiprocessor"},{"location":"blog/stm32/usart/#2-memory-map","text":"Refer to Datasheet document of the target MCU. For example, DS8668 for STM32F051x.","title":"2. Memory Map"},{"location":"blog/stm32/usart/#3-register-map","text":"Refer to Reference Manual document of the target MCU. For example, RM0091 for STM32F051x.","title":"3. Register Map"},{"location":"blog/stm32/usart/#4-hal-software","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. ST HAL define a handler for USART ports like below: typedef struct { USART_TypeDef * Instance ; /* UART registers base address */ UART_InitTypeDef Init ; /* UART communication parameters */ UART_AdvFeatureInitTypeDef AdvancedInit ; /* UART Advanced Features initialization parameters */ uint8_t * pTxBuffPtr ; /* Pointer to UART Tx transfer Buffer */ uint16_t TxXferSize ; /* UART Tx Transfer size */ uint16_t TxXferCount ; /* UART Tx Transfer Counter */ uint8_t * pRxBuffPtr ; /* Pointer to UART Rx transfer Buffer */ uint16_t RxXferSize ; /* UART Rx Transfer size */ uint16_t RxXferCount ; /* UART Rx Transfer Counter */ DMA_HandleTypeDef * hdmatx ; /* UART Tx DMA Handle parameters */ DMA_HandleTypeDef * hdmarx ; /* UART Rx DMA Handle parameters */ HAL_LockTypeDef Lock ; /* Locking object */ __IO HAL_UART_StateTypeDef State ; /* UART communication state */ __IO HAL_UART_ErrorTypeDef ErrorCode ; /* UART Error code */ } UART_HandleTypeDef ; excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle Init structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,...) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API.","title":"4. HAL Software"},{"location":"blog/stm32/usart/#5-lab-polling-mode","text":"This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the most simple form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Target board: STM32F0 Discovery Application requirements: Enable USART1 on board Transmit a log with increasing counter every 1 second","title":"5. Lab: Polling mode"},{"location":"blog/stm32/usart/#51-enable-usart1","text":"Create new project via CubeMX and use default settings for the discovery board. Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 b (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout.","title":"5.1. Enable USART1"},{"location":"blog/stm32/usart/#52-generated-code","text":"When generate code from Pin configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Init functions The function SystemClock_Config() is included to setup the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() inits the USART1 instance with the values put into the init struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the init params and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will setup the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } }","title":"5.2. Generated code"},{"location":"blog/stm32/usart/#53-send-data","text":"With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let's make a buffer, a counter, and a message every 1 second. #include <stdio.h> // sprintf #include <string.h> // strlen int main ( void ) { char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r while ( 1 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } }","title":"5.3. Send data"},{"location":"blog/stm32/usart/#54-connect-uart-to-pc","text":"Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter. Then connect pins PA9 and PA10 to UART terminal on PC. It's recommend to check the voltage because board is running at 3.3V while PC USB or COM port is running at 5V. Another option is that an Arduino Uno can be used as a COM bridge if put the MCU into inactive state by connecting RESET pin to GND, and directly use both TX, RX pins which are connected to Arduino Virtual COM port.","title":"5.4. Connect UART to PC"},{"location":"blog/stm32/usart/#55-build-and-run","text":"Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyser to see raw bits transferred in RX and TX pins. UART output on digital logic analyser","title":"5.5. Build and Run"},{"location":"blog/stm32/usart/#56-receive-data","text":"Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Target board: STM32F0 Discovery Application requirements: Read data from UART If data is \"stop\", then do not print counter value If data is \"resume\", then resuming printing counter value Use this function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 6, 2000) , which means: All received data is written into buffer (re-use it ^^) Function will exit if one of the below condition meets: 6 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let's see the modified code, with return result is checked to print the debug information. const char msg_ok [] = \" \\t OK \\n\\r \" ; const char msg_busy [] = \" \\t BUSY \\n\\r \" ; const char msg_error [] = \" \\t ERROR \\n\\r \" ; const char msg_timeout [] = \" \\t TIME OUT \\n\\r \" ; int main ( void ) { char pause = 0 ; char counter = 0 ; char buffer [ 16 ] = { 0 }; HAL_StatusTypeDef ret ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , 6 , 2000 ); // try to use HAL_MAX_DELAY to see the effect if ( ret == HAL_OK ) { HAL_UART_Transmit ( & huart1 , msg_ok , strlen ( msg_ok ), HAL_MAX_DELAY ); } else if ( ret == HAL_BUSY ) { HAL_UART_Transmit ( & huart1 , msg_busy , strlen ( msg_busy ), HAL_MAX_DELAY ); } else if ( ret == HAL_ERROR ) { HAL_UART_Transmit ( & huart1 , msg_error , strlen ( msg_error ), HAL_MAX_DELAY ); } else if ( ret == HAL_TIMEOUT ) { HAL_UART_Transmit ( & huart1 , msg_timeout , strlen ( msg_timeout ), HAL_MAX_DELAY ); } if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; } else if ( strncmp ( buffer , \"resume\" , 6 ) == 0 ) { pause = 0 ; } Debug to see the received status Bug: Uncontrollable input It's hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR).","title":"5.6. Receive data"},{"location":"blog/stm32/usart/#6-lab-interrupt-mode","text":"","title":"6. Lab: Interrupt Mode"},{"location":"blog/stm32/usart/#61-interruptions","text":"Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The CubeHAL is designed to automatically do this job for us. Then user is warned about the interrupt generation thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() , which must be called inside the ISR. From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is not asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the function HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() are designed so that they do not wait for data transmission completion, but the dirty job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated.","title":"6.1. Interruptions"},{"location":"blog/stm32/usart/#62-enable-interrupt","text":"Go to USART1 module, select NVIC Settings and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); }","title":"6.2. Enable interrupt"},{"location":"blog/stm32/usart/#63-use-interrupt","text":"Send data Finally, use HAL_UART_Transmit_IT() function to send data. while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } HAL_Delay ( 1000 ); } When all data in the buffer are sent, HAL library will call a HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transfered Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , COUNTOF ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , COUNTOF ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , COUNTOF ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , ) strings [ i ], COUNTOF () strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } Receive data Next step is to read data using interrupt. Because it's unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in sprinf() , therefore, should use a new buffer to store received data, e.g. cmd[] . When the receiver get enough characters, it will fire an interrupt to run a the HAL_UART_RxCpltCallback() function. That function can be overriden to handle received data: char rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { rx_int = 1 ; } } In the main function, process received data only when the flag is on: Add delay after calling HAL_UART_Transmit_IT() to make sure the transmittion will be complete. const char msg_rx_int [] = \" \\t RX INT \\n\\r \" ; int main ( void ) { char cmd [ 6 ] = { 0 }; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"I:counter=%03d \\n\\r \" , counter ++ ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } HAL_Delay ( 50 ); // Must have delay for transmition to complete /* use buffer may not work, because sprintf in main loop may be filling the buffer */ ret = HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) cmd , 6 ); if ( ret == HAL_OK ) { HAL_UART_Transmit ( & huart1 , msg_ok , strlen ( msg_ok ), HAL_MAX_DELAY ); } else if ( ret == HAL_BUSY ) { HAL_UART_Transmit ( & huart1 , msg_busy , strlen ( msg_busy ), HAL_MAX_DELAY ); } else if ( ret == HAL_ERROR ) { HAL_UART_Transmit ( & huart1 , msg_error , strlen ( msg_error ), HAL_MAX_DELAY ); } else if ( ret == HAL_TIMEOUT ) { HAL_UART_Transmit ( & huart1 , msg_timeout , strlen ( msg_timeout ), HAL_MAX_DELAY ); } if ( rx_int == 1 ) { rx_int = 0 ; HAL_UART_Transmit ( & huart1 , msg_rx_int , strlen ( msg_rx_int ), HAL_MAX_DELAY ); HAL_UART_Transmit ( & huart1 , cmd , strlen ( cmd ), HAL_MAX_DELAY ); if ( strncmp ( cmd , \"stop\" , 4 ) == 0 ) { pause = 1 ; } else if ( strncmp ( cmd , \"resume\" , 6 ) == 0 ) { pause = 0 ; } } HAL_Delay ( 500 ); } } Build and run applocation code, it should work much better than the Polling version, because whenver a character is sent to the board, it will be received correclty. Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the newline \\n or carriage return \\r character to to determine input sectences. However, this will lead to run the interrupt handler many times.","title":"6.3. Use interrupt"},{"location":"blog/stm32/usart/#7-lab-dma-mode","text":"Refer to DMA Memory to UART TX","title":"7. Lab: DMA mode"},{"location":"blog/stm32/usart/#8-appendix","text":"Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips.","title":"8. Appendix"},{"location":"projects/","text":"I have published some of my projects on my github at vuquangtrong . If you are interested, feel free to ask me for more details. Here are some featured ones: STM32 Tutorials I made this series of tutorials for a training course in my company, then I'd like to share it here to help others who also start learning about ARM Cortex-M boards. MkDocs Material Blog theme Based on Material for MkDocs , I added some modifications to restyle it to have a blog-like theme, for example, homepage, tags, featured posts. Simplify Pelican Theme I used Pelican static site generator before I moved to MkDocs. I also made a theme for this blog when it was generated by Pelican. VAcamera This is a small project that uses Accord framework and FFMPEG engine to record video streams from 2 cameras and write combined videos with sone overlay text to mp4 files. Tiva C TM4C123G LaunchPad I practiced on ARM Cortext-M4F, contain Bring Up, Sensors, LCD, BootLoader and Firmware Update labs. SMS WebHub This project uses a mobile phone to process commands from a VPS via websocket, include sending SMS, checking Balance, calling a number, forwarding messages. Other Proof of Concept (PoC) projects This repo has prototypes for freelance projects I have done, as their source code are not allowed to be published by contracts. Show ToC sidebar \u2693\ufe0e .md-nav.md-nav--secondary { display: none; } .tag-cloud-nav br, .tag-cloud-toc br { display: none; }","title":"Projects"},{"location":"projects/#show-toc-sidebar","text":".md-nav.md-nav--secondary { display: none; } .tag-cloud-nav br, .tag-cloud-toc br { display: none; }","title":"Show ToC sidebar"},{"location":"tags/","text":"Tags \u2693\ufe0e","title":"Tags"},{"location":"tags/#tags","text":"","title":"Tags"}]}