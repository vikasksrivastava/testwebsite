{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Code Inside Out \u2693\ufe0e Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89*:\u30fb\uff9f \u2727 There is a huge amount of information on the internet and it will take time to search and find out which is usable. This blog comes to host what I\u2019ve read and marked as useful to faster look them up again. I also discovered that I learn better when I write about the things that I am learning, and of course, sharing is always better than holding. I hope you can find something interesting here, and feel free to leave a comment or feedback to help me improve this blog. Happy coding!","title":"Home"},{"location":"#code-inside-out","text":"Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89*:\u30fb\uff9f \u2727 There is a huge amount of information on the internet and it will take time to search and find out which is usable. This blog comes to host what I\u2019ve read and marked as useful to faster look them up again. I also discovered that I learn better when I write about the things that I am learning, and of course, sharing is always better than holding. I hope you can find something interesting here, and feel free to leave a comment or feedback to help me improve this blog. Happy coding!","title":"Code Inside Out"},{"location":"blog/","text":"Blog \u2693\ufe0e","title":"Blog"},{"location":"blog/#blog","text":"","title":"Blog"},{"location":"blog/c-cpp/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Size of datatypes \u2693\ufe0e Size of datatypes The size of a type is determined by the compiler, which doesn\u2019t have anything to do with the actual hardware. The returned value of sizeof(char) is always 1 by definition, and sizeof(int) always returns 4. Starting at C99, bool is present as an 1-byte datatype. Note that, size of a pointer should be 4 bytes on any 32-bit C/C++ compiler, and be 8 bytes on any 64-bit C/C++ compiler. Use int instead of char or uint8_t ? It depends on the target machine: if it is incapable to access unaligned memory (e.g. Cortex-M0 processors), then using int is much faster. Do not use sizeof for array parameters \u2693\ufe0e Do not use sizeof for array parameters The function fun() below receives an array parameter arr[] and tries to find out the number of elements in the array arr[] using the sizeof operator. In main, there is also a statement calculating the number of elements in the array arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) {} // ??? } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which finally is evaluated as sizeof(arr) = sizeof(int *) which is 4 or 8 depending on the compiler. Use goto if it can reduce the complexity \u2693\ufe0e Use goto if it can reduce the complexity Using goto is considered as bad and harmful, but if it is used with care, it can be helpful to reduce the complexity. For example: void func (...) { byte * buf1 = malloc (...); byte * buf2 = malloc (...); FILE * f = fopen (...); if ( f == NULL ) goto func_cleanup_and_exit ; ... if ( something_goes_wrong_1 ) goto func_close_file_cleanup_and_exit ; ... func_close_file_cleanup_and_exit : fclose ( f ); func_cleanup_and_exit : free ( buf1 ); free ( buf2 ); func_exit : return ; }; Array[index] is actually pointer accessing \u2693\ufe0e Array[index] is actually pointer accessing The expression a[i] is translated to *(a+i) . That\u2019s why this weird code printf ( \"%c\" , 3 [ \"abcdef\" ]); still runs. C/C++ does not check the index range, therefore it is easy to access a memory block which is out of range of the array: int a [] = { 1 , 2 }; int b [] = { 3 , 4 , 5 }; // if a and b are allocated next to each other, b[-1] will be a[1] printf ( \"%d\" , b [ -1 ]); There are Buffer overflow exploiting techniques based on this problem of accessing memory block outsides of the array. Short-circuit evaluation \u2693\ufe0e Short-circuit evaluation At runtime, in the expression with AND operator if ( a && b && c ) , the part (b) will be calculated only if (a) is true, and (c) will be calculated only if (a) and (b) are both true. The same story about OR operator: in the expression if ( a || b || c ) , if the sub-expression (a) is true, others will not be computed. This helps in case the next condition depends on the previous condition, such as accessing to pointer: if ( pointer != NULL && pointer -> member == 3 ) {} or, checking for a higher priority condition first: if ( flag_a || flag_b ) {} However, as the consequence, do not expect the 2 nd or later conditions are executed in all cases. Cached data \u2693\ufe0e Cached data Modern CPUs have L1, L2, and L3 caches. When fetching data from memory, it usually read a whole line of L1 cache. For example, L1 cache has 64-bytes lines, it will fetch 64 bytes from memory at once when it accesses to a memory. So if a data structure is larger than 64 bytes, it is very important to divide it by 2 parts: the most demanded fields and the less ones. It is desirable to place the most demanded fields in the first 64 bytes. C++ classes are also concerned. Compiler warnings \u2693\ufe0e Compiler warnings Is it worth to turn on -Wall to see all possible problems which usually are small error and hard to get noticed. In GCC, it is also possible to turn all warnings to errors with -Werror . If enabled, any problem marked as error will halt the compiler, and it must be fixed. Example 1: int f1 ( int a , int b , int c ) { int ret = a + b + c ; printf ( \"%d\" , ret ); } int main () { printf ( \"%d\" , f1 ( 1 , 2 , 3 )); } The main() function still runs but prints out wrong value due to non-returned function. A random value will be seen because compiler still use the return register which is not set the desired value. Example 2: bool f1 () { return cond ? true : false ; } bool is 1-byte datatype Compiler will generate a code to set the low byte of the AL register to 0x01 or 0x00 , because the return size of 1 byte. Other higher bytes of the AL register won\u2019t change. However, in a different file, f1() is assumed to return int , not bool , therefore compiler generates code to compare 4 bytes of an int which is only updated its lowest byte after f1() returns. There maybe some random value in higher bytes of that int memory block, and it will cause a wrong comparison: void main () { if ( f1 ()) } Buffered stdout but unbuffered stderr \u2693\ufe0e Buffered stdout but unbuffered stderr The stdout or cout is a buffered output , so a user, usually not aware of this, sees the output by portions. Sometimes, the program outputs something and then crashes, and if buffer did not have time to flush into the console, a user will not see anything. This is sometimes inconvenient. Thus, for dumping more important information, including debugging, it is better to use the un-buffered stderr or cerr . Negative error code \u2693\ufe0e Negative error code The simplest way to indicate to caller about its children\u2019s success is to return a boolean value: false \u2014 in case of error, and true in case of success. However, to indicate more status than just 2 states, a number can be returned. And it can be extended more to indicate different status of failure or success using signed numbers: /** * func() - A function that does something * input: * none * output: * -2: error on buffer * -1: error on transmission * 0: success but no response * 1: success with a response = NACK * 2: success with a response = ACK */ Bit fields \u2693\ufe0e Bit fields A very popular thing in C, and also in programming generally is working with bits. For flags specifying, in order to not make a typo and mess, they can be defined using bit shifting: #define FLAG1 (1<<0) #define FLAG2 (1<<1) #define FLAG3 (1<<2) #define FLAG4 (1<<3) #define FLAG5 (1<<4) and some macros can be use to work on bits: #define IS_SET(flag, bit) (((flag) & (bit)) ? true : false) #define SET_BIT(var, bit) ((var) |= (bit)) #define REMOVE_BIT(var, bit) ((var) &= ~(bit)) For better performance, use bool for each bit, but it will cost memory.","title":"C/C++"},{"location":"blog/c-cpp/notes/#size-of-datatypes","text":"Size of datatypes The size of a type is determined by the compiler, which doesn\u2019t have anything to do with the actual hardware. The returned value of sizeof(char) is always 1 by definition, and sizeof(int) always returns 4. Starting at C99, bool is present as an 1-byte datatype. Note that, size of a pointer should be 4 bytes on any 32-bit C/C++ compiler, and be 8 bytes on any 64-bit C/C++ compiler. Use int instead of char or uint8_t ? It depends on the target machine: if it is incapable to access unaligned memory (e.g. Cortex-M0 processors), then using int is much faster.","title":"Size of datatypes"},{"location":"blog/c-cpp/notes/#do-not-use-sizeof-for-array-parameters","text":"Do not use sizeof for array parameters The function fun() below receives an array parameter arr[] and tries to find out the number of elements in the array arr[] using the sizeof operator. In main, there is also a statement calculating the number of elements in the array arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) {} // ??? } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which finally is evaluated as sizeof(arr) = sizeof(int *) which is 4 or 8 depending on the compiler.","title":"Do not use sizeof for array parameters"},{"location":"blog/c-cpp/notes/#use-goto-if-it-can-reduce-the-complexity","text":"Use goto if it can reduce the complexity Using goto is considered as bad and harmful, but if it is used with care, it can be helpful to reduce the complexity. For example: void func (...) { byte * buf1 = malloc (...); byte * buf2 = malloc (...); FILE * f = fopen (...); if ( f == NULL ) goto func_cleanup_and_exit ; ... if ( something_goes_wrong_1 ) goto func_close_file_cleanup_and_exit ; ... func_close_file_cleanup_and_exit : fclose ( f ); func_cleanup_and_exit : free ( buf1 ); free ( buf2 ); func_exit : return ; };","title":"Use goto if it can reduce the complexity"},{"location":"blog/c-cpp/notes/#arrayindex-is-actually-pointer-accessing","text":"Array[index] is actually pointer accessing The expression a[i] is translated to *(a+i) . That\u2019s why this weird code printf ( \"%c\" , 3 [ \"abcdef\" ]); still runs. C/C++ does not check the index range, therefore it is easy to access a memory block which is out of range of the array: int a [] = { 1 , 2 }; int b [] = { 3 , 4 , 5 }; // if a and b are allocated next to each other, b[-1] will be a[1] printf ( \"%d\" , b [ -1 ]); There are Buffer overflow exploiting techniques based on this problem of accessing memory block outsides of the array.","title":"Array[index] is actually pointer accessing"},{"location":"blog/c-cpp/notes/#short-circuit-evaluation","text":"Short-circuit evaluation At runtime, in the expression with AND operator if ( a && b && c ) , the part (b) will be calculated only if (a) is true, and (c) will be calculated only if (a) and (b) are both true. The same story about OR operator: in the expression if ( a || b || c ) , if the sub-expression (a) is true, others will not be computed. This helps in case the next condition depends on the previous condition, such as accessing to pointer: if ( pointer != NULL && pointer -> member == 3 ) {} or, checking for a higher priority condition first: if ( flag_a || flag_b ) {} However, as the consequence, do not expect the 2 nd or later conditions are executed in all cases.","title":"Short-circuit evaluation"},{"location":"blog/c-cpp/notes/#cached-data","text":"Cached data Modern CPUs have L1, L2, and L3 caches. When fetching data from memory, it usually read a whole line of L1 cache. For example, L1 cache has 64-bytes lines, it will fetch 64 bytes from memory at once when it accesses to a memory. So if a data structure is larger than 64 bytes, it is very important to divide it by 2 parts: the most demanded fields and the less ones. It is desirable to place the most demanded fields in the first 64 bytes. C++ classes are also concerned.","title":"Cached data"},{"location":"blog/c-cpp/notes/#compiler-warnings","text":"Compiler warnings Is it worth to turn on -Wall to see all possible problems which usually are small error and hard to get noticed. In GCC, it is also possible to turn all warnings to errors with -Werror . If enabled, any problem marked as error will halt the compiler, and it must be fixed. Example 1: int f1 ( int a , int b , int c ) { int ret = a + b + c ; printf ( \"%d\" , ret ); } int main () { printf ( \"%d\" , f1 ( 1 , 2 , 3 )); } The main() function still runs but prints out wrong value due to non-returned function. A random value will be seen because compiler still use the return register which is not set the desired value. Example 2: bool f1 () { return cond ? true : false ; } bool is 1-byte datatype Compiler will generate a code to set the low byte of the AL register to 0x01 or 0x00 , because the return size of 1 byte. Other higher bytes of the AL register won\u2019t change. However, in a different file, f1() is assumed to return int , not bool , therefore compiler generates code to compare 4 bytes of an int which is only updated its lowest byte after f1() returns. There maybe some random value in higher bytes of that int memory block, and it will cause a wrong comparison: void main () { if ( f1 ()) }","title":"Compiler warnings"},{"location":"blog/c-cpp/notes/#buffered-stdout-but-unbuffered-stderr","text":"Buffered stdout but unbuffered stderr The stdout or cout is a buffered output , so a user, usually not aware of this, sees the output by portions. Sometimes, the program outputs something and then crashes, and if buffer did not have time to flush into the console, a user will not see anything. This is sometimes inconvenient. Thus, for dumping more important information, including debugging, it is better to use the un-buffered stderr or cerr .","title":"Buffered stdout but unbuffered stderr"},{"location":"blog/c-cpp/notes/#negative-error-code","text":"Negative error code The simplest way to indicate to caller about its children\u2019s success is to return a boolean value: false \u2014 in case of error, and true in case of success. However, to indicate more status than just 2 states, a number can be returned. And it can be extended more to indicate different status of failure or success using signed numbers: /** * func() - A function that does something * input: * none * output: * -2: error on buffer * -1: error on transmission * 0: success but no response * 1: success with a response = NACK * 2: success with a response = ACK */","title":"Negative error code"},{"location":"blog/c-cpp/notes/#bit-fields","text":"Bit fields A very popular thing in C, and also in programming generally is working with bits. For flags specifying, in order to not make a typo and mess, they can be defined using bit shifting: #define FLAG1 (1<<0) #define FLAG2 (1<<1) #define FLAG3 (1<<2) #define FLAG4 (1<<3) #define FLAG5 (1<<4) and some macros can be use to work on bits: #define IS_SET(flag, bit) (((flag) & (bit)) ? true : false) #define SET_BIT(var, bit) ((var) |= (bit)) #define REMOVE_BIT(var, bit) ((var) &= ~(bit)) For better performance, use bool for each bit, but it will cost memory.","title":"Bit fields"},{"location":"blog/pi/","text":"A Raspberry Pi 4 model B Topics \u2693\ufe0e There are thousands of topics on the internet discussing about Raspberry Pi. In here, I post some short-and-consistent posts written as guides and notes for a quick reference when learning and doing projects on Raspberry Pi boards. Because Raspberry Pi OS (previously called Raspbian ) is based on the Debian Linux-based OS, a lot of technical knowledge in Linux-OS can be applied to. Communities \u2693\ufe0e Official Homepage: https://www.raspberrypi.org News: https://magpi.raspberrypi.org Sharing: https://projects.raspberrypi.org/en https://www.hackster.io/raspberry-pi/projects https://www.instructables.com/Raspberry-Pi-Projects https://pimylifeup.com/category/projects Forums: https://www.raspberrypi.org/forums","title":"Raspberry Pi"},{"location":"blog/pi/#topics","text":"There are thousands of topics on the internet discussing about Raspberry Pi. In here, I post some short-and-consistent posts written as guides and notes for a quick reference when learning and doing projects on Raspberry Pi boards. Because Raspberry Pi OS (previously called Raspbian ) is based on the Debian Linux-based OS, a lot of technical knowledge in Linux-OS can be applied to.","title":"Topics"},{"location":"blog/pi/#communities","text":"Official Homepage: https://www.raspberrypi.org News: https://magpi.raspberrypi.org Sharing: https://projects.raspberrypi.org/en https://www.hackster.io/raspberry-pi/projects https://www.instructables.com/Raspberry-Pi-Projects https://pimylifeup.com/category/projects Forums: https://www.raspberrypi.org/forums","title":"Communities"},{"location":"blog/pi/backup-sdcard/","text":"1. Win32 Disk Imager \u2693\ufe0e Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. It means the size of the backup file is equal to the device\u2019s total size. This method will take a long time to complete, depending on the size of the storage device. Download it from win32diskimager and run it as administrative right. 1.1. Backup \u2693\ufe0e Select the Image File to save the SDCard content Select the source Device Click on Read Win32 Disk Imager: save device to image 1.2. Restore \u2693\ufe0e Select the Image File of the SDCard content Select the target Device Click on Write Win32 Disk Imager: restore from image to device 2. Acronis True Image \u2693\ufe0e Acronis True Image is an application that provides data protection for personal users including, backup, archive, access and recovery for Windows, macOS, iOS, and Android operating systems. This application is a commercial product, try it for free before purchasing a copy. 2.1. Backup and Restore \u2693\ufe0e Acronis will not backup empty space on the SDCard, it only saves the useful data, therefore the backup progress is much faster than dumping all bits and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. The restore process is as simple as the backup. There are buttons and guide to help doing those actions: Acronis True Image: backup/restore disk","title":"Backup SDCard"},{"location":"blog/pi/backup-sdcard/#1-win32-disk-imager","text":"Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. It means the size of the backup file is equal to the device\u2019s total size. This method will take a long time to complete, depending on the size of the storage device. Download it from win32diskimager and run it as administrative right.","title":"1. Win32 Disk Imager"},{"location":"blog/pi/backup-sdcard/#11-backup","text":"Select the Image File to save the SDCard content Select the source Device Click on Read Win32 Disk Imager: save device to image","title":"1.1. Backup"},{"location":"blog/pi/backup-sdcard/#12-restore","text":"Select the Image File of the SDCard content Select the target Device Click on Write Win32 Disk Imager: restore from image to device","title":"1.2. Restore"},{"location":"blog/pi/backup-sdcard/#2-acronis-true-image","text":"Acronis True Image is an application that provides data protection for personal users including, backup, archive, access and recovery for Windows, macOS, iOS, and Android operating systems. This application is a commercial product, try it for free before purchasing a copy.","title":"2. Acronis True Image"},{"location":"blog/pi/backup-sdcard/#21-backup-and-restore","text":"Acronis will not backup empty space on the SDCard, it only saves the useful data, therefore the backup progress is much faster than dumping all bits and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. The restore process is as simple as the backup. There are buttons and guide to help doing those actions: Acronis True Image: backup/restore disk","title":"2.1. Backup and Restore"},{"location":"blog/pi/check-camera-i2c/","text":"Camera I2C Address responses Scan on the I2C Bus 0, the camera module will response on two addresses 0x10 (camera sensor) and 0x64 (camera board). Missing one of two above addresses means that there is an hardware issue happened. 1. Hardware check \u2693\ufe0e Run the command: vcgencmd get_camera which should print out supported=1 detected=1 with a normal working camera. If the output shows detected=0 , check the ribbon cable first. If other camera module still works after swapping with the problem one, then do a hardware check from software interface as described below. 2. Software check \u2693\ufe0e An interesting topic: Camera not detected despite being plugged in on the official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on an I2C interface. 2.1. Install I2C tools \u2693\ufe0e Install i2c-tools : sudo apt-get install i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect # detect I2C chips i2cdump # examine I2C registers i2cget # read from I2C/SMBus chip registers i2cset # set I2C registers i2ctransfer # send user-defined I2C messages in one transfer 2.2. Load I2C driver \u2693\ufe0e It is able to permanently enable the I2C interface by running sudo raspi-config and enable I2C setting, or by adding i2c-dev declaration in the file /etc/modules . Enable I2C Interface via raspi-config However, for a quick check, just need to load driver temporarily: sudo modprobe i2c-dev 2.3. Config GPIOs \u2693\ufe0e GPIO pin number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on the Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh 2.4. Scan I2C bus \u2693\ufe0e Run i2cdetect on I2C BUS 0 at /dev/i2c-0 : i2cdetect 0 press Y to continue and it should print out some numbers, for example: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera\u2019s I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and main connectors on Pi board and camera board. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection (a small cable between camera board and camera sensor).","title":"Diagnostic Camera"},{"location":"blog/pi/check-camera-i2c/#1-hardware-check","text":"Run the command: vcgencmd get_camera which should print out supported=1 detected=1 with a normal working camera. If the output shows detected=0 , check the ribbon cable first. If other camera module still works after swapping with the problem one, then do a hardware check from software interface as described below.","title":"1. Hardware check"},{"location":"blog/pi/check-camera-i2c/#2-software-check","text":"An interesting topic: Camera not detected despite being plugged in on the official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on an I2C interface.","title":"2. Software check"},{"location":"blog/pi/check-camera-i2c/#21-install-i2c-tools","text":"Install i2c-tools : sudo apt-get install i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect # detect I2C chips i2cdump # examine I2C registers i2cget # read from I2C/SMBus chip registers i2cset # set I2C registers i2ctransfer # send user-defined I2C messages in one transfer","title":"2.1. Install I2C tools"},{"location":"blog/pi/check-camera-i2c/#22-load-i2c-driver","text":"It is able to permanently enable the I2C interface by running sudo raspi-config and enable I2C setting, or by adding i2c-dev declaration in the file /etc/modules . Enable I2C Interface via raspi-config However, for a quick check, just need to load driver temporarily: sudo modprobe i2c-dev","title":"2.2. Load I2C driver"},{"location":"blog/pi/check-camera-i2c/#23-config-gpios","text":"GPIO pin number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on the Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh","title":"2.3. Config GPIOs"},{"location":"blog/pi/check-camera-i2c/#24-scan-i2c-bus","text":"Run i2cdetect on I2C BUS 0 at /dev/i2c-0 : i2cdetect 0 press Y to continue and it should print out some numbers, for example: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera\u2019s I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and main connectors on Pi board and camera board. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection (a small cable between camera board and camera sensor).","title":"2.4. Scan I2C bus"},{"location":"blog/pi/compile-ffmpeg/","text":"Pre-built FFmpeg in Raspberry Pi OS The FFmpeg package in Raspberry Pi OS is built with H264 Hardware Acceleration already, just need to download it from the package manager: sudo apt install ffmpeg -y The below guide helps to compile FFmpeg from the latest source code to get new features or bug fixes. 1. Manual compilation \u2693\ufe0e Autobuild script There is a simpler method to compile FFmpeg with an auto-build script . This manual build section is to understand what are needed to be able to compile FFmpeg. It is recommended to use script. 1.1. Update the system \u2693\ufe0e Before starting to build, update system packages to the latest version may help to solve some issues which could happen due to the requirements from the latest source code of FFmpeg. sudo apt update sudo apt upgrade 1.2. Install build package \u2693\ufe0e To compile a source code, system needs to install build tools, including config parsers, compilers, dependent libraries. Here is the command to install necessary packages: sudo apt -y install autoconf automake build-essential cmake doxygen git graphviz imagemagick libasound2-dev libass-dev libavcodec-dev libavdevice-dev libavfilter-dev libavformat-dev libavutil-dev libfreetype6-dev libgmp-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libopus-dev librtmp-dev libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-net-dev libsdl2-ttf-dev libsnappy-dev libsoxr-dev libssh-dev libssl-dev libtool libv4l-dev libva-dev libvdpau-dev libvo-amrwbenc-dev libvorbis-dev libwebp-dev libx264-dev libx265-dev libxcb-shape0-dev libxcb-shm0-dev libxcb-xfixes0-dev libxcb1-dev libxml2-dev lzma-dev meson nasm pkg-config python3-dev python3-pip texinfo wget yasm zlib1g-dev libdrm-dev 1.3. Compile additional libraries \u2693\ufe0e There are some additional libraries required by FFmpeg, which are not pre-built and distributed in OS package manager. Create a folder to get started: mkdir ~/ffmpeg-libraries AAC sound format (fdk-aac) git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git ~/ffmpeg-libraries/fdk-aac \\ && cd ~/ffmpeg-libraries/fdk-aac \\ && autoreconf -fiv \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install AV1 video format (dav1d) git clone --depth 1 https://code.videolan.org/videolan/dav1d.git ~/ffmpeg-libraries/dav1d \\ && mkdir ~/ffmpeg-libraries/dav1d/build \\ && cd ~/ffmpeg-libraries/dav1d/build \\ && meson .. \\ && ninja \\ && sudo ninja install HEVC encoder (kvazaar) git clone --depth 1 https://github.com/ultravideo/kvazaar.git ~/ffmpeg-libraries/kvazaar \\ && cd ~/ffmpeg-libraries/kvazaar \\ && ./autogen.sh \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install VP8 and VP9 video codecs (LibVPX) git clone --depth 1 https://chromium.googlesource.com/webm/libvpx ~/ffmpeg-libraries/libvpx \\ && cd ~/ffmpeg-libraries/libvpx \\ && ./configure --disable-examples --disable-tools --disable-unit_tests --disable-docs \\ && make -j $( nproc ) \\ && sudo make install AP1 video codec (aom) git clone --depth 1 https://aomedia.googlesource.com/aom ~/ffmpeg-libraries/aom \\ && mkdir ~/ffmpeg-libraries/aom/aom_build \\ && cd ~/ffmpeg-libraries/aom/aom_build \\ && cmake -G \"Unix Makefiles\" AOM_SRC -DENABLE_NASM = on -DPYTHON_EXECUTABLE = \" $( which python3 ) \" -DCMAKE_C_FLAGS = \"-mfpu=vfp -mfloat-abi=hard\" .. \\ && sed -i 's/ENABLE_NEON:BOOL=ON/ENABLE_NEON:BOOL=OFF/' CMakeCache.txt \\ && make -j $( nproc ) \\ && sudo make install Image processing (zimg) git clone -b release-2.9.3 https://github.com/sekrit-twc/zimg.git ~/ffmpeg-libraries/zimg \\ && cd ~/ffmpeg-libraries/zimg \\ && sh autogen.sh \\ && ./configure \\ && make \\ && sudo make install 1.4. Link compiled libraries \u2693\ufe0e After installing new libraries, system needs to refresh link cache for new packages. This command ensures system won\u2019t run into linking issues because the compiler can\u2019t find a library. sudo ldconfig 1.5. Compile FFmpeg \u2693\ufe0e Finally, FFmpeg can be compiled with settings to include additional libraries, and the feature omx-rpi . The command is quite large as it has a lot of options: git clone --depth 1 https://github.com/FFmpeg/FFmpeg.git ~/FFmpeg \\ && cd ~/FFmpeg \\ && ./configure \\ --extra-cflags = \"-I/usr/local/include\" \\ --extra-ldflags = \"-L/usr/local/lib\" \\ --extra-libs = \"-lpthread -lm -latomic\" \\ --arch = armel \\ --enable-gmp \\ --enable-gpl \\ --enable-libaom \\ --enable-libass \\ --enable-libdav1d \\ --enable-libdrm \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libkvazaar \\ --enable-libmp3lame \\ --enable-libopencore-amrnb \\ --enable-libopencore-amrwb \\ --enable-libopus \\ --enable-librtmp \\ --enable-libsnappy \\ --enable-libsoxr \\ --enable-libssh \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libzimg \\ --enable-libwebp \\ --enable-libx264 \\ --enable-libx265 \\ --enable-libxml2 \\ --enable-mmal \\ --enable-nonfree \\ --enable-omx \\ --enable-omx-rpi \\ --enable-version3 \\ --target-os = linux \\ --enable-pthreads \\ --enable-openssl \\ --enable-hardcoded-tables \\ && make -j $( nproc ) \\ && sudo make install The compilation time is quite long, usually 5 hours on Raspberry Pi WiFi Zero, so be patient. Restart the system when the compilation ends, and check for the supported Hardware Acceleration codec: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) 2. Autobuild script \u2693\ufe0e Thank cdgriffith for the below awesome pi_streaming_setup script. 2.1. The pi_streaming_setup script \u2693\ufe0e There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a Paspberry Pi with a compatible camera into a MPEG-DASH / HLS streaming server . The steps it will attempt to do: Install FFmpeg (or compile it before install) with H264 hardware acceleration and free libraries Install NGINX for DASH / HLS or install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create a systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile FFmpeg, just need 2 options: --compile-ffmpeg --compile-only 2.2. Compile FFmpeg \u2693\ufe0e Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from github: cd ~ git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script\u2019s folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow Raspberry Pi, such as a Pi Zero. 2.3. Test compiled FFmpeg \u2693\ufe0e After the compilation finishes, reboot the Pi, and when it\u2019s booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#1-manual-compilation","text":"Autobuild script There is a simpler method to compile FFmpeg with an auto-build script . This manual build section is to understand what are needed to be able to compile FFmpeg. It is recommended to use script.","title":"1. Manual compilation"},{"location":"blog/pi/compile-ffmpeg/#11-update-the-system","text":"Before starting to build, update system packages to the latest version may help to solve some issues which could happen due to the requirements from the latest source code of FFmpeg. sudo apt update sudo apt upgrade","title":"1.1. Update the system"},{"location":"blog/pi/compile-ffmpeg/#12-install-build-package","text":"To compile a source code, system needs to install build tools, including config parsers, compilers, dependent libraries. Here is the command to install necessary packages: sudo apt -y install autoconf automake build-essential cmake doxygen git graphviz imagemagick libasound2-dev libass-dev libavcodec-dev libavdevice-dev libavfilter-dev libavformat-dev libavutil-dev libfreetype6-dev libgmp-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libopus-dev librtmp-dev libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-net-dev libsdl2-ttf-dev libsnappy-dev libsoxr-dev libssh-dev libssl-dev libtool libv4l-dev libva-dev libvdpau-dev libvo-amrwbenc-dev libvorbis-dev libwebp-dev libx264-dev libx265-dev libxcb-shape0-dev libxcb-shm0-dev libxcb-xfixes0-dev libxcb1-dev libxml2-dev lzma-dev meson nasm pkg-config python3-dev python3-pip texinfo wget yasm zlib1g-dev libdrm-dev","title":"1.2. Install build package"},{"location":"blog/pi/compile-ffmpeg/#13-compile-additional-libraries","text":"There are some additional libraries required by FFmpeg, which are not pre-built and distributed in OS package manager. Create a folder to get started: mkdir ~/ffmpeg-libraries AAC sound format (fdk-aac) git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git ~/ffmpeg-libraries/fdk-aac \\ && cd ~/ffmpeg-libraries/fdk-aac \\ && autoreconf -fiv \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install AV1 video format (dav1d) git clone --depth 1 https://code.videolan.org/videolan/dav1d.git ~/ffmpeg-libraries/dav1d \\ && mkdir ~/ffmpeg-libraries/dav1d/build \\ && cd ~/ffmpeg-libraries/dav1d/build \\ && meson .. \\ && ninja \\ && sudo ninja install HEVC encoder (kvazaar) git clone --depth 1 https://github.com/ultravideo/kvazaar.git ~/ffmpeg-libraries/kvazaar \\ && cd ~/ffmpeg-libraries/kvazaar \\ && ./autogen.sh \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install VP8 and VP9 video codecs (LibVPX) git clone --depth 1 https://chromium.googlesource.com/webm/libvpx ~/ffmpeg-libraries/libvpx \\ && cd ~/ffmpeg-libraries/libvpx \\ && ./configure --disable-examples --disable-tools --disable-unit_tests --disable-docs \\ && make -j $( nproc ) \\ && sudo make install AP1 video codec (aom) git clone --depth 1 https://aomedia.googlesource.com/aom ~/ffmpeg-libraries/aom \\ && mkdir ~/ffmpeg-libraries/aom/aom_build \\ && cd ~/ffmpeg-libraries/aom/aom_build \\ && cmake -G \"Unix Makefiles\" AOM_SRC -DENABLE_NASM = on -DPYTHON_EXECUTABLE = \" $( which python3 ) \" -DCMAKE_C_FLAGS = \"-mfpu=vfp -mfloat-abi=hard\" .. \\ && sed -i 's/ENABLE_NEON:BOOL=ON/ENABLE_NEON:BOOL=OFF/' CMakeCache.txt \\ && make -j $( nproc ) \\ && sudo make install Image processing (zimg) git clone -b release-2.9.3 https://github.com/sekrit-twc/zimg.git ~/ffmpeg-libraries/zimg \\ && cd ~/ffmpeg-libraries/zimg \\ && sh autogen.sh \\ && ./configure \\ && make \\ && sudo make install","title":"1.3. Compile additional libraries"},{"location":"blog/pi/compile-ffmpeg/#14-link-compiled-libraries","text":"After installing new libraries, system needs to refresh link cache for new packages. This command ensures system won\u2019t run into linking issues because the compiler can\u2019t find a library. sudo ldconfig","title":"1.4. Link compiled libraries"},{"location":"blog/pi/compile-ffmpeg/#15-compile-ffmpeg","text":"Finally, FFmpeg can be compiled with settings to include additional libraries, and the feature omx-rpi . The command is quite large as it has a lot of options: git clone --depth 1 https://github.com/FFmpeg/FFmpeg.git ~/FFmpeg \\ && cd ~/FFmpeg \\ && ./configure \\ --extra-cflags = \"-I/usr/local/include\" \\ --extra-ldflags = \"-L/usr/local/lib\" \\ --extra-libs = \"-lpthread -lm -latomic\" \\ --arch = armel \\ --enable-gmp \\ --enable-gpl \\ --enable-libaom \\ --enable-libass \\ --enable-libdav1d \\ --enable-libdrm \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libkvazaar \\ --enable-libmp3lame \\ --enable-libopencore-amrnb \\ --enable-libopencore-amrwb \\ --enable-libopus \\ --enable-librtmp \\ --enable-libsnappy \\ --enable-libsoxr \\ --enable-libssh \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libzimg \\ --enable-libwebp \\ --enable-libx264 \\ --enable-libx265 \\ --enable-libxml2 \\ --enable-mmal \\ --enable-nonfree \\ --enable-omx \\ --enable-omx-rpi \\ --enable-version3 \\ --target-os = linux \\ --enable-pthreads \\ --enable-openssl \\ --enable-hardcoded-tables \\ && make -j $( nproc ) \\ && sudo make install The compilation time is quite long, usually 5 hours on Raspberry Pi WiFi Zero, so be patient. Restart the system when the compilation ends, and check for the supported Hardware Acceleration codec: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"1.5. Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#2-autobuild-script","text":"Thank cdgriffith for the below awesome pi_streaming_setup script.","title":"2. Autobuild script"},{"location":"blog/pi/compile-ffmpeg/#21-the-pi_streaming_setup-script","text":"There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a Paspberry Pi with a compatible camera into a MPEG-DASH / HLS streaming server . The steps it will attempt to do: Install FFmpeg (or compile it before install) with H264 hardware acceleration and free libraries Install NGINX for DASH / HLS or install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create a systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile FFmpeg, just need 2 options: --compile-ffmpeg --compile-only","title":"2.1. The pi_streaming_setup script"},{"location":"blog/pi/compile-ffmpeg/#22-compile-ffmpeg","text":"Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from github: cd ~ git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script\u2019s folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow Raspberry Pi, such as a Pi Zero.","title":"2.2. Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#23-test-compiled-ffmpeg","text":"After the compilation finishes, reboot the Pi, and when it\u2019s booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"2.3. Test compiled FFmpeg"},{"location":"blog/pi/headless-mode/","text":"1. Download Lite OS Image \u2693\ufe0e Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please download the OS zip file in preparation. The release notes of Lite OS is listed here . 2. Burn Image to SDCard \u2693\ufe0e Raspberry Pi Imager is the official Image Writer from Raspberry Pi. The application balenaEtcher is a very good image writer that will write the OS image to an SDCard. Download and install it, then run it. Just follow the guided steps: Select image - browse to the zip file downloaded above Select drive - it may find the SDCard drive automatically Click Flash Etcher is writing the OS image After copying the image to the target SDCard, File Explorer may have trouble seeing the content of that SDCard. A simple fix is to pull the SDCard out then plug it back. It should appear with a partition named boot . 3. Enable SSH \u2693\ufe0e For security reasons, Secure Socket Shell ( ssh ) is no longer enabled by default. To enable it, place a blank text file called ssh no file extension in the root of the boot partition on the SDCard. 4. Add WiFi Network \u2693\ufe0e To add a wireless network which Pi will automatically connect to, create a text file called wpa_supplicant.conf and place that file in the root of the boot partition on SDCard too. In below config file, the ssid field is the WiFi Access Point name, and the psk field is the password of that WiFi. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } Added ssh and wpa_supplicant.conf in the boot partition Direct USB connection (Pi Zero / Zero W Only) See the below section to skip setting a WiFi network, as it will setup a virtual network over the USB connection. 5. Direct USB connection (Pi Zero / Zero W Only) \u2693\ufe0e On Pi Zero / Zero W only, it\u2019s able to turn on USB OTG mode and the Pi will act as an USB slave with different modes: Serial, Ethernet, Mass storage device, etc. The research was published here and here . This step will setup Pi in USB OTG Ethernet mode, so that when plugging Pi into computer by the Peripheral USB port labelled USB, not PWR , there is virtual network will be created and Pi can be accessed over that network, and no need of an external WiFi network is required. This method also helps to power Pi over the USB port. Add dtoverlay=dwc2 on a new line in the config.txt file. Open up the cmdline.txt file. Insert modules-load=dwc2,g_ether after rootwait with only one space between the text rootwait and the new text!!! 6. Login to Pi \u2693\ufe0e Power Pi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the Pi. A plugin on MobaXterm can be used too. Scan for Pi\u2019s IP For the official Raspberry Pi OS, the default user name is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan To edit or review the wifi settings, run this command: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Connect to another Wifi network Open the wpa-supplicant configuration file in nano: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0 7. Update system (optional) \u2693\ufe0e To get the latest version of Pi OS and its packages, please update the system by entering below commands: sudo apt-get update sudo apt-get upgrade -y 8. Expand Filesystem (optional) \u2693\ufe0e To use all of available space on the SDCard, expand the filesystem by running: sudo raspi-config Select Advanced Options \u2192 Expand Filesystem Then reboot the system. 9. Others (optional) \u2693\ufe0e Please read the Notes - Save power post.","title":"Headless mode"},{"location":"blog/pi/headless-mode/#1-download-lite-os-image","text":"Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please download the OS zip file in preparation. The release notes of Lite OS is listed here .","title":"1. Download Lite OS Image"},{"location":"blog/pi/headless-mode/#2-burn-image-to-sdcard","text":"Raspberry Pi Imager is the official Image Writer from Raspberry Pi. The application balenaEtcher is a very good image writer that will write the OS image to an SDCard. Download and install it, then run it. Just follow the guided steps: Select image - browse to the zip file downloaded above Select drive - it may find the SDCard drive automatically Click Flash Etcher is writing the OS image After copying the image to the target SDCard, File Explorer may have trouble seeing the content of that SDCard. A simple fix is to pull the SDCard out then plug it back. It should appear with a partition named boot .","title":"2. Burn Image to SDCard"},{"location":"blog/pi/headless-mode/#3-enable-ssh","text":"For security reasons, Secure Socket Shell ( ssh ) is no longer enabled by default. To enable it, place a blank text file called ssh no file extension in the root of the boot partition on the SDCard.","title":"3. Enable SSH"},{"location":"blog/pi/headless-mode/#4-add-wifi-network","text":"To add a wireless network which Pi will automatically connect to, create a text file called wpa_supplicant.conf and place that file in the root of the boot partition on SDCard too. In below config file, the ssid field is the WiFi Access Point name, and the psk field is the password of that WiFi. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } Added ssh and wpa_supplicant.conf in the boot partition Direct USB connection (Pi Zero / Zero W Only) See the below section to skip setting a WiFi network, as it will setup a virtual network over the USB connection.","title":"4. Add WiFi Network"},{"location":"blog/pi/headless-mode/#5-direct-usb-connection-pi-zero--zero-w-only","text":"On Pi Zero / Zero W only, it\u2019s able to turn on USB OTG mode and the Pi will act as an USB slave with different modes: Serial, Ethernet, Mass storage device, etc. The research was published here and here . This step will setup Pi in USB OTG Ethernet mode, so that when plugging Pi into computer by the Peripheral USB port labelled USB, not PWR , there is virtual network will be created and Pi can be accessed over that network, and no need of an external WiFi network is required. This method also helps to power Pi over the USB port. Add dtoverlay=dwc2 on a new line in the config.txt file. Open up the cmdline.txt file. Insert modules-load=dwc2,g_ether after rootwait with only one space between the text rootwait and the new text!!!","title":"5. Direct USB connection (Pi Zero / Zero W Only)"},{"location":"blog/pi/headless-mode/#6-login-to-pi","text":"Power Pi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the Pi. A plugin on MobaXterm can be used too. Scan for Pi\u2019s IP For the official Raspberry Pi OS, the default user name is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan To edit or review the wifi settings, run this command: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Connect to another Wifi network Open the wpa-supplicant configuration file in nano: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0","title":"6. Login to Pi"},{"location":"blog/pi/headless-mode/#7-update-system-optional","text":"To get the latest version of Pi OS and its packages, please update the system by entering below commands: sudo apt-get update sudo apt-get upgrade -y","title":"7. Update system (optional)"},{"location":"blog/pi/headless-mode/#8-expand-filesystem-optional","text":"To use all of available space on the SDCard, expand the filesystem by running: sudo raspi-config Select Advanced Options \u2192 Expand Filesystem Then reboot the system.","title":"8. Expand Filesystem (optional)"},{"location":"blog/pi/headless-mode/#9-others-optional","text":"Please read the Notes - Save power post.","title":"9. Others (optional)"},{"location":"blog/pi/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Search 1 for a package distributed by Debian: Search 1. Setup Wireless \u2693\ufe0e Setup Wireless Refer to the official guide at Raspberry Pi Configuration . Note that there are two type of access points: Routed wireless access point Create a new local network, which is not connected any other existing network +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | 192.168.4.1 | | 192.168.4.2 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)---WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ Bridged wireless access point Extend an existing Ethernet network to wireless computers and devices +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | Bridge | | 10.10.0.5 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)---WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ 2. Python packages \u2693\ufe0e Python packages Most packages can be installed using sudo apt-get install followed by python-<packagename> for Python2 or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install python-pip python3-pip Then install the target package. For example: sudo apt install python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package pip3 install ws4py 3. Who is logged on? \u2693\ufe0e Who is logged on? Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w 4. Save power \u2693\ufe0e Save power Save power when running on battery by turning off unused peripherals, or features. 4.1. Turn off USB \u2693\ufe0e Turn OFF the USB chip : echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind 4.2. Turn off HDMI \u2693\ufe0e Turn OFF the HDMI output : sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p 4.3. Throttle CPU \u2693\ufe0e Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0 4.4. Disable Wi-Fi & Bluetooth \u2693\ufe0e Disable Wi-Fi & Bluetooth Starting from Raspberry Pi 3, WiFi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It\u2019s correct to use the word pi3 in the params\u2019s value, for other version of RPi. The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background. 4.5. Disable on-board LEDs \u2693\ufe0e Disable on-board LEDs Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on Add a form in markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" > < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"Notes"},{"location":"blog/pi/notes/#1-setup-wireless","text":"Setup Wireless Refer to the official guide at Raspberry Pi Configuration . Note that there are two type of access points: Routed wireless access point Create a new local network, which is not connected any other existing network +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | 192.168.4.1 | | 192.168.4.2 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)---WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ Bridged wireless access point Extend an existing Ethernet network to wireless computers and devices +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | Bridge | | 10.10.0.5 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)---WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+","title":"1. Setup Wireless"},{"location":"blog/pi/notes/#2-python-packages","text":"Python packages Most packages can be installed using sudo apt-get install followed by python-<packagename> for Python2 or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install python-pip python3-pip Then install the target package. For example: sudo apt install python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package pip3 install ws4py","title":"2. Python packages"},{"location":"blog/pi/notes/#3-who-is-logged-on","text":"Who is logged on? Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w","title":"3. Who is logged on?"},{"location":"blog/pi/notes/#4-save-power","text":"Save power Save power when running on battery by turning off unused peripherals, or features.","title":"4. Save power"},{"location":"blog/pi/notes/#41-turn-off-usb","text":"Turn OFF the USB chip : echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind","title":"4.1. Turn off USB"},{"location":"blog/pi/notes/#42-turn-off-hdmi","text":"Turn OFF the HDMI output : sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p","title":"4.2. Turn off HDMI"},{"location":"blog/pi/notes/#43-throttle-cpu","text":"Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0","title":"4.3. Throttle CPU"},{"location":"blog/pi/notes/#44-disable-wi-fi--bluetooth","text":"Disable Wi-Fi & Bluetooth Starting from Raspberry Pi 3, WiFi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It\u2019s correct to use the word pi3 in the params\u2019s value, for other version of RPi. The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background.","title":"4.4. Disable Wi-Fi &amp; Bluetooth"},{"location":"blog/pi/notes/#45-disable-on-board-leds","text":"Disable on-board LEDs Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on Add a form in markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" > < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"4.5. Disable on-board LEDs"},{"location":"blog/pi/resource-usage/","text":"The final script Download monitor.sh then save to ~/monitor.sh . Add below line to ~/.bashrc : source monitor.sh Usage: monitor \"title\" program params This post is written as a walk through guide, step by step, to help understanding how the script was made. 1. Export a function in bash \u2693\ufe0e In a bash file, a function with a name and its body can be defined and then exported with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"Params: $@ \" } export -f myfunc To make function available outside of the script, run source command before calling the function: source myfunc.sh myfunc abc All params are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th param $# The number of command-line arguments $* All of the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself 2. Command-Grouping \u2693\ufe0e Refer to Bash Manual - Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment ), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace 3. Run a process \u2693\ufe0e The basic idea is to run a process in background and while it\u2019s running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor 4. ps or top \u2693\ufe0e Both ps and top report CPU Usage, but the returned values are different. Let\u2019s check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU \u2013 CPU Usage, The task\u2019s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let\u2019s check top \u2018s options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n\u2019 command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one\u2019s personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 \u2026 or -pN1,N2,N3 \u2026 Monitor only processes with specified process IDs. Switch to use top get the the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg 5. grep and awk \u2693\ufe0e Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline. 6. Line buffered mode \u2693\ufe0e When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered but block buffered, usually the block is 4KB,leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive sets un-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4 7. Save log with tee \u2693\ufe0e Use tee to read from the standard input and write to the standard output and a file. That is simple enough to clone the output to a log file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are twp issues happened: an empty log.txt file the usage.txt content is invalid 7.1. Fix empty log \u2693\ufe0e When making pipeline to tee , only the STDOUT (1) is forwarded, while ffmpeg prints output on the STDERR (2) not on the STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt & 7.2. Fix wrong data \u2693\ufe0e Add some debug lines ps -p $pid to check the process ID after creating the processes: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee\u2019s PID will be saved in the macro $! . The solution is to save the PID in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top 8. Graph with gnuplot \u2693\ufe0e Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many different types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage 9. Some enhancements \u2693\ufe0e Some small modifications to make script run in multiple sessions: 1. Set title for a new session Let\u2019s modify the script to accept params in this format: monitor \"title\" command by extracting those params at the beginning of the script: monitor () ( # extract params title = $1 command = ${ @: 2 } # get params from the 2nd one ... ) The title will be used to name the session, to create a folder to save log files. 2. Save output to a separated folder # create result folder if not existed [ ! -d $title ] && mkdir $title 3. Change output format to CPU= X MEM= Y It needs to change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \" 10. The final script \u2693\ufe0e Download the final script in the top of this page.","title":"Resource usage"},{"location":"blog/pi/resource-usage/#1-export-a-function-in-bash","text":"In a bash file, a function with a name and its body can be defined and then exported with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"Params: $@ \" } export -f myfunc To make function available outside of the script, run source command before calling the function: source myfunc.sh myfunc abc All params are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th param $# The number of command-line arguments $* All of the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself","title":"1. Export a function in bash"},{"location":"blog/pi/resource-usage/#2-command-grouping","text":"Refer to Bash Manual - Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment ), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace","title":"2. Command-Grouping"},{"location":"blog/pi/resource-usage/#3-run-a-process","text":"The basic idea is to run a process in background and while it\u2019s running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor","title":"3. Run a process"},{"location":"blog/pi/resource-usage/#4-ps-or-top","text":"Both ps and top report CPU Usage, but the returned values are different. Let\u2019s check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU \u2013 CPU Usage, The task\u2019s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let\u2019s check top \u2018s options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n\u2019 command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one\u2019s personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 \u2026 or -pN1,N2,N3 \u2026 Monitor only processes with specified process IDs. Switch to use top get the the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg","title":"4. ps or top"},{"location":"blog/pi/resource-usage/#5-grep-and-awk","text":"Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline.","title":"5. grep and awk"},{"location":"blog/pi/resource-usage/#6-line-buffered-mode","text":"When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered but block buffered, usually the block is 4KB,leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive sets un-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4","title":"6. Line buffered mode"},{"location":"blog/pi/resource-usage/#7-save-log-with-tee","text":"Use tee to read from the standard input and write to the standard output and a file. That is simple enough to clone the output to a log file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are twp issues happened: an empty log.txt file the usage.txt content is invalid","title":"7. Save log with tee"},{"location":"blog/pi/resource-usage/#71-fix-empty-log","text":"When making pipeline to tee , only the STDOUT (1) is forwarded, while ffmpeg prints output on the STDERR (2) not on the STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt &","title":"7.1. Fix empty log"},{"location":"blog/pi/resource-usage/#72-fix-wrong-data","text":"Add some debug lines ps -p $pid to check the process ID after creating the processes: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee\u2019s PID will be saved in the macro $! . The solution is to save the PID in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top","title":"7.2. Fix wrong data"},{"location":"blog/pi/resource-usage/#8-graph-with-gnuplot","text":"Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many different types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage","title":"8. Graph with gnuplot"},{"location":"blog/pi/resource-usage/#9-some-enhancements","text":"Some small modifications to make script run in multiple sessions: 1. Set title for a new session Let\u2019s modify the script to accept params in this format: monitor \"title\" command by extracting those params at the beginning of the script: monitor () ( # extract params title = $1 command = ${ @: 2 } # get params from the 2nd one ... ) The title will be used to name the session, to create a folder to save log files. 2. Save output to a separated folder # create result folder if not existed [ ! -d $title ] && mkdir $title 3. Change output format to CPU= X MEM= Y It needs to change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \"","title":"9. Some enhancements"},{"location":"blog/pi/resource-usage/#10-the-final-script","text":"Download the final script in the top of this page.","title":"10. The final script"},{"location":"blog/pi/setup-camera/","text":"RaspberryPi Camera Module This tutorial is for setting up the official Raspberry Pi Camera module which is attached with a CSI cable. Other types of USB Camera should work on Pi out-of-the-box. 1. Enable Camera module \u2693\ufe0e Run raspi-config configuration tool: sudo raspi-config then select Interfacing Options \u2192 Camera \u2192 Yes . This method will automatically set start_x=1 in /boot/config.txt file. raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in Pi OS. This tool requires root permission, therefore, it must be run with the super user right using sudo . User interface of raspi-config 2. Increase GPU memory \u2693\ufe0e Some video encoders need a big buffer to process video encoding or decoding. To increase the memory reserved for video processor, in the raspi-config configuration tool, go to Performance Options \u2192 GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem=256 in /boot/config.txt . 3. Test Camera \u2693\ufe0e Detect the camera connection by running the checking tool: vcgencmd get_camera which should print out supported=1 detected=1 telling that the camera is supported and connected. vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record an video: raspivid -o vid.h264 4. Video for Linux 2 - V4L2 \u2693\ufe0e Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written an user space V4L driver for the Raspberry Pi camera but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included Raspberry Pi OS by default. Use v4l2-ctl utility tool to capture from the camera. 4.1. List devices \u2693\ufe0e v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0 4.2. Driver info \u2693\ufe0e v4l2-ctl -d /dev/video0 --all Driver Info: Driver name : bm2835 mmal Card type : mmal service 16.1 Bus info : platform:bcm2835-v4l2 Driver version : 5.4.79 Capabilities : 0x85200005 Video Capture Video Overlay Read/Write Streaming ... 4.3. Supported formats \u2693\ufe0e v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly. 4.4. Capture JPEG Image \u2693\ufe0e v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg 4.5. Record H264 Video \u2693\ufe0e Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264 5. FFmpeg \u2693\ufe0e The pre-built ffmpeg package of Pi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator . 5.1. Encoders \u2693\ufe0e To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . ffmpeg -h encoder = <format> Here is the list of formats supported by OpenMAX IL H.264 video encoder (h264_omx): ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V...... 5.2. Performance \u2693\ufe0e Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor - Script to check performance . Note that ffmpeg will use v4l2 driver if user does not specify the driver!\u201d Video settings Video side: 1024x768 Framerate: 30 fps Input Length: 60 seconds 5.2.1. Raw to MJPEG (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average CPU: 93 (too high) Average MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG 5.2.2. Raw to H264_OMX @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average CPU: 16 (OK) Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps 5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average CPU: 23 Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps 5.2.4. V4L2 MJPEG direct copy (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG strem 5.2.5. V4L2 H264 direct copy (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream 5.2.6. Conclusion \u2693\ufe0e After above tests, it can be said that using compressed input format from v4l2 is much more effective than compressing by an software encoder. Let\u2019s add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4 6. Install picamera \u2693\ufe0e The picamera package is a pure Python interface to the Raspberry Pi camera module for Python language. If using the Raspbian distro, probably it has picamera installed by default. Run a test to check it is installed or not: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of examples in the official guide . Here are some starting points: Get maximum resolution of the camera import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for the testing purpose, let\u2019s record a 60-second video from the camera and measure the resource usage with monitor , then use ffmpeg to convert raw h264 to mp4: 6.1. Picamera H264 (.h264) \u2693\ufe0e Recode a raw H264 video file from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () Convert to MP4 video file ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) Picamera 6.2. Picamera H264 (.h264) with Text overlay \u2693\ufe0e Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive CPU and MEM usage, comparing to using FFmpeg. The result shows that the CPU uses twice as much as it does in non-overlay text, while the MEM keeps the same percentage.","title":"Setup Camera"},{"location":"blog/pi/setup-camera/#1-enable-camera-module","text":"Run raspi-config configuration tool: sudo raspi-config then select Interfacing Options \u2192 Camera \u2192 Yes . This method will automatically set start_x=1 in /boot/config.txt file. raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in Pi OS. This tool requires root permission, therefore, it must be run with the super user right using sudo . User interface of raspi-config","title":"1. Enable Camera module"},{"location":"blog/pi/setup-camera/#2-increase-gpu-memory","text":"Some video encoders need a big buffer to process video encoding or decoding. To increase the memory reserved for video processor, in the raspi-config configuration tool, go to Performance Options \u2192 GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem=256 in /boot/config.txt .","title":"2. Increase GPU memory"},{"location":"blog/pi/setup-camera/#3-test-camera","text":"Detect the camera connection by running the checking tool: vcgencmd get_camera which should print out supported=1 detected=1 telling that the camera is supported and connected. vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record an video: raspivid -o vid.h264","title":"3. Test Camera"},{"location":"blog/pi/setup-camera/#4-video-for-linux-2---v4l2","text":"Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written an user space V4L driver for the Raspberry Pi camera but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included Raspberry Pi OS by default. Use v4l2-ctl utility tool to capture from the camera.","title":"4. Video for Linux 2 - V4L2"},{"location":"blog/pi/setup-camera/#41-list-devices","text":"v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0","title":"4.1. List devices"},{"location":"blog/pi/setup-camera/#42-driver-info","text":"v4l2-ctl -d /dev/video0 --all Driver Info: Driver name : bm2835 mmal Card type : mmal service 16.1 Bus info : platform:bcm2835-v4l2 Driver version : 5.4.79 Capabilities : 0x85200005 Video Capture Video Overlay Read/Write Streaming ...","title":"4.2. Driver info"},{"location":"blog/pi/setup-camera/#43-supported-formats","text":"v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly.","title":"4.3. Supported formats"},{"location":"blog/pi/setup-camera/#44-capture-jpeg-image","text":"v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg","title":"4.4. Capture JPEG Image"},{"location":"blog/pi/setup-camera/#45-record-h264-video","text":"Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264","title":"4.5. Record H264 Video"},{"location":"blog/pi/setup-camera/#5-ffmpeg","text":"The pre-built ffmpeg package of Pi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator .","title":"5. FFmpeg"},{"location":"blog/pi/setup-camera/#51-encoders","text":"To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . ffmpeg -h encoder = <format> Here is the list of formats supported by OpenMAX IL H.264 video encoder (h264_omx): ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V......","title":"5.1. Encoders"},{"location":"blog/pi/setup-camera/#52-performance","text":"Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor - Script to check performance . Note that ffmpeg will use v4l2 driver if user does not specify the driver!\u201d Video settings Video side: 1024x768 Framerate: 30 fps Input Length: 60 seconds","title":"5.2. Performance"},{"location":"blog/pi/setup-camera/#521-raw-to-mjpeg-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average CPU: 93 (too high) Average MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG","title":"5.2.1. Raw to MJPEG (.avi)"},{"location":"blog/pi/setup-camera/#522-raw-to-h264_omx-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average CPU: 16 (OK) Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps","title":"5.2.2. Raw to H264_OMX @8Mbps (.mp4)"},{"location":"blog/pi/setup-camera/#523-raw-to-h264_v4l2m2m-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average CPU: 23 Average MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps","title":"5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4)"},{"location":"blog/pi/setup-camera/#524-v4l2-mjpeg-direct-copy-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG strem","title":"5.2.4. V4L2 MJPEG direct copy (.avi)"},{"location":"blog/pi/setup-camera/#525-v4l2-h264-direct-copy-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average CPU: 10 (Good) Average MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream","title":"5.2.5. V4L2 H264 direct copy (.mp4)"},{"location":"blog/pi/setup-camera/#526-conclusion","text":"After above tests, it can be said that using compressed input format from v4l2 is much more effective than compressing by an software encoder. Let\u2019s add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4","title":"5.2.6. Conclusion"},{"location":"blog/pi/setup-camera/#6-install-picamera","text":"The picamera package is a pure Python interface to the Raspberry Pi camera module for Python language. If using the Raspbian distro, probably it has picamera installed by default. Run a test to check it is installed or not: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of examples in the official guide . Here are some starting points: Get maximum resolution of the camera import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for the testing purpose, let\u2019s record a 60-second video from the camera and measure the resource usage with monitor , then use ffmpeg to convert raw h264 to mp4:","title":"6. Install picamera"},{"location":"blog/pi/setup-camera/#61-picamera-h264-h264","text":"Recode a raw H264 video file from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () Convert to MP4 video file ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) Picamera","title":"6.1. Picamera H264 (.h264)"},{"location":"blog/pi/setup-camera/#62-picamera-h264-h264-with-text-overlay","text":"Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive CPU and MEM usage, comparing to using FFmpeg. The result shows that the CPU uses twice as much as it does in non-overlay text, while the MEM keeps the same percentage.","title":"6.2. Picamera H264 (.h264) with Text overlay"},{"location":"blog/pi/stream-ffmpeg-hls-dash/","text":"stream_ffmpeg_hls Delay when streaming in HLS protocol Big Buck Bunny movie , \u00a9 2008, Blender Foundation 1. Install FFmpeg \u2693\ufe0e Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y or compile an executable file by following Compile FFmpeg manually guide. 2. HLS vs. MPEG-DASH \u2693\ufe0e A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol. 2.1. HLS \u2693\ufe0e HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bitrate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly. 2.2. MPEG-DASH \u2693\ufe0e As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bitrate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH. 3. Setup web server \u2693\ufe0e Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files. 3.1. Apache \u2693\ufe0e Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache\u2019s design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/ . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device\u2019s browsers. 3.2. NGINX \u2693\ufe0e NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX\u2019s design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html/ . Goto http://localhost/etc/nginx/sites-available to see the site\u2019s links. As the article Apache Vs NGINX \u2013 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests). 4. Stream live video \u2693\ufe0e MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SDCard, it is better to write video chunks to RAM memory. When the number of chunks go high, clear the old ones to get more space . Let\u2019s do it with HLS first! 4.1. Create video chunks \u2693\ufe0e Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8 4.2. Use HLS streaming \u2693\ufe0e A javascript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( \"video\" ); var videoSrc = \"hls/live.m3u8\" ; // First check for native browser HLS support if ( video . canPlayType ( \"application/vnd.apple.mpegurl\" )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension. 4.3. Use MPEG-DASH streaming \u2693\ufe0e DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" />< title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function () { var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , }, }, }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later. 5. Python Web Server \u2693\ufe0e Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: js var config = Hls.DefaultConfig; config.liveSyncDurationCount = 1; config.startFragPrefetch = true; console.log(config); var hls = new Hls(config); hls.js HLS Stream player written in Javascript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post. Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only . Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it\u2019s really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"HLS/DASH Streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#1-install-ffmpeg","text":"Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y or compile an executable file by following Compile FFmpeg manually guide.","title":"1. Install FFmpeg"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#2-hls-vs-mpeg-dash","text":"A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol.","title":"2. HLS vs. MPEG-DASH"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#21-hls","text":"HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bitrate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly.","title":"2.1. HLS"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#22-mpeg-dash","text":"As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bitrate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH.","title":"2.2. MPEG-DASH"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#3-setup-web-server","text":"Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files.","title":"3. Setup web server"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#31-apache","text":"Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache\u2019s design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/ . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device\u2019s browsers.","title":"3.1. Apache"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#32-nginx","text":"NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX\u2019s design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html/ . Goto http://localhost/etc/nginx/sites-available to see the site\u2019s links. As the article Apache Vs NGINX \u2013 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests).","title":"3.2. NGINX"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#4-stream-live-video","text":"MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SDCard, it is better to write video chunks to RAM memory. When the number of chunks go high, clear the old ones to get more space . Let\u2019s do it with HLS first!","title":"4. Stream live video"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#41-create-video-chunks","text":"Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8","title":"4.1. Create video chunks"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#42-use-hls-streaming","text":"A javascript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( \"video\" ); var videoSrc = \"hls/live.m3u8\" ; // First check for native browser HLS support if ( video . canPlayType ( \"application/vnd.apple.mpegurl\" )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension.","title":"4.2. Use HLS streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#43-use-mpeg-dash-streaming","text":"DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" />< title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function () { var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , }, }, }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later.","title":"4.3. Use MPEG-DASH streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#5-python-web-server","text":"Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: js var config = Hls.DefaultConfig; config.liveSyncDurationCount = 1; config.startFragPrefetch = true; console.log(config); var hls = new Hls(config); hls.js HLS Stream player written in Javascript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post. Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only . Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it\u2019s really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"5. Python Web Server"},{"location":"blog/pi/stream-picamera-h264/","text":"stream_picamera_h264 Low latency streaming using H264 format Big Buck Bunny movie , \u00a9 2008, Blender Foundation 1. Stream video \u2693\ufe0e Live streaming requires very low latency with acceptable quality and bandwidth. MJPEG Streaming has low latency but high bandwidth. HLS/DASH Streaming is not realtime. Therefore people have to find a method to transfer encoded video in realtime. An example of streaming real video (not frame by frame) is pistreaming which uses mpeg1video format. The video stream is sent to user\u2019s browser via a websocket , and is decoded by JSMPEG javascript library. This post will show a method similar to both MPEG stream and MJPEG images: send video using H264 Network Abstract Layer (NAL) units and decode those units to display video. 2. Broadway.js - H264 decoder \u2693\ufe0e The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js library to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , and websocket . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (Video Control Layer (VCL) or non-VLC packages), then transported using a websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player\u2019s canvas to an element to display the video; and call the decode function with the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > ); 3. Create a webpage \u2693\ufe0e The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html > 4. Create server \u2693\ufe0e Here is the structure of a H264 streaming system use in the post. PiCamera will capture a H264 stream and write to FrameBuffer each NALU package which will be sent to the Broadway.js via a websocket. The decoded video frame will be drawn on a canvas to show in the webpage. The webpage is provided via a HTTP server which will load the Broadway.js and setup the decoder and a websocket client. H264 streaming server structure 4.1. Frame buffer \u2693\ufe0e The FrameBuffer is implemented as an output of Picamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all () 4.2. HTTP Server \u2693\ufe0e The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever ) 4.3. Websocket Server \u2693\ufe0e One of good WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever ) 4.4. Main thread \u2693\ufe0e The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a IDR Frame (keyframe) to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"H264 streaming"},{"location":"blog/pi/stream-picamera-h264/#1-stream-video","text":"Live streaming requires very low latency with acceptable quality and bandwidth. MJPEG Streaming has low latency but high bandwidth. HLS/DASH Streaming is not realtime. Therefore people have to find a method to transfer encoded video in realtime. An example of streaming real video (not frame by frame) is pistreaming which uses mpeg1video format. The video stream is sent to user\u2019s browser via a websocket , and is decoded by JSMPEG javascript library. This post will show a method similar to both MPEG stream and MJPEG images: send video using H264 Network Abstract Layer (NAL) units and decode those units to display video.","title":"1. Stream video"},{"location":"blog/pi/stream-picamera-h264/#2-broadwayjs---h264-decoder","text":"The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js library to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , and websocket . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (Video Control Layer (VCL) or non-VLC packages), then transported using a websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player\u2019s canvas to an element to display the video; and call the decode function with the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > );","title":"2. Broadway.js - H264 decoder"},{"location":"blog/pi/stream-picamera-h264/#3-create-a-webpage","text":"The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html >","title":"3. Create a webpage"},{"location":"blog/pi/stream-picamera-h264/#4-create-server","text":"Here is the structure of a H264 streaming system use in the post. PiCamera will capture a H264 stream and write to FrameBuffer each NALU package which will be sent to the Broadway.js via a websocket. The decoded video frame will be drawn on a canvas to show in the webpage. The webpage is provided via a HTTP server which will load the Broadway.js and setup the decoder and a websocket client. H264 streaming server structure","title":"4. Create server"},{"location":"blog/pi/stream-picamera-h264/#41-frame-buffer","text":"The FrameBuffer is implemented as an output of Picamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all ()","title":"4.1. Frame buffer"},{"location":"blog/pi/stream-picamera-h264/#42-http-server","text":"The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever )","title":"4.2. HTTP Server"},{"location":"blog/pi/stream-picamera-h264/#43-websocket-server","text":"One of good WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever )","title":"4.3. Websocket Server"},{"location":"blog/pi/stream-picamera-h264/#44-main-thread","text":"The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a IDR Frame (keyframe) to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"4.4. Main thread"},{"location":"blog/pi/stream-picamera-mjpeg/","text":"stream_picamera_mjpeg Low latency streaming using MJPEG format Big Buck Bunny movie , \u00a9 2008, Blender Foundation There are many methods to implement a streaming server using MJPEG (MJPG) format. The basic principle is to send a series of JPEG (JPG) image to the user\u2019s webpage and display it in an image <img> tag. An example is the mjpg-streamer . This post shows a method to develop a streaming system, starting with a Python package named picamera and a simple Python HTTP server. Setup PiCamera To setup picamera package, please read more in the Setup Camera post. PiCamera also has an example to stream MJPEG at Web streaming section. The basic structure of this MJPEG streaming server is as below. PiCamera will capture JPEG images to a buffer that will be sent to user\u2019s web browser via an endless multipart/x-mixed-replace content when the webpage requests to show an image in a <img> element. A structure of an MJPEG streaming server 1. Record video to a stream \u2693\ufe0e This is a basic step to write a video stream to a buffered memory. Python has the io package which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed, because PiCamera requests to V4L2 driver to handle the encoding in hardware. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'mjpeg' ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording () 2. Frame buffer \u2693\ufe0e Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs . A file-like object (as far as picamera is concerned) is simply an object with: a write() method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. a flush() method with no parameters, which will be called at the end of output. In write() method, it can implement code that reacts to each and every frame. The write() method is called frequently, so its implementation must be sufficiently rapid that it doesn\u2019t stall the encoding flow. Let\u2019s write a class FrameBuffer() which checks the JPEG Magic Number 0xFF 0xD8 at the beginning of an JPEG image: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user\u2019s webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' ) 3. Streaming Web server \u2693\ufe0e Python has a built-in simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; BaseHTTPRequestHandler just provides a number of class and instance variables, and methods for use by subclasses. It must be subclassed to handle each request method (e.g. GET or POST). The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let\u2019s start with SimpleHTTPRequestHandler which has some implemented features. 4. Request Handler \u2693\ufe0e Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will looking for index.html for the homepage. To display image, create an <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web server should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) Send header with information to notify web client about type of responded content, which is multipart/x-mixed-replace Send the content in a stream format (loop forever!): send the boundary FRAME , send content type of each frame image/jpeg , send the length of the content, and then send the actual image data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating an instance of FrameBuffer , PiCamera , HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is availabe. 5. Synchronize between threads \u2693\ufe0e Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH streaming. However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming Hint Above sections are enough to create a simple MJPEG streaming server. Below sections are for an advanced implementation which need some advanced Python programming to create multiple buffers in an application, which can be used to merge or manipulate the image before sending to user\u2019s browsers. 6. Some updates in the script \u2693\ufe0e The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let\u2019s check how they work. 6.1. Class variable \u2693\ufe0e Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer 6.2. Instance variable \u2693\ufe0e Instance variables are for the data unique to each instance, they are create in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected params list to new params list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the param directory which is an optional param in original constructor of SimpleHTTPRequestHandler . To solve this problem, let\u2019s use special *args and **kwargs params. 6.3. *args and **kwargs \u2693\ufe0e The special *args and **kwargs params allow to pass multiple arguments or keyword arguments to a function. Read about them in here . So, change the param list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) 6.4. Lambda function \u2693\ufe0e Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args )) 6.5. Measure FPS \u2693\ufe0e In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"MJPEG streaming"},{"location":"blog/pi/stream-picamera-mjpeg/#1-record-video-to-a-stream","text":"This is a basic step to write a video stream to a buffered memory. Python has the io package which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed, because PiCamera requests to V4L2 driver to handle the encoding in hardware. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'mjpeg' ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording ()","title":"1. Record video to a stream"},{"location":"blog/pi/stream-picamera-mjpeg/#2-frame-buffer","text":"Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs . A file-like object (as far as picamera is concerned) is simply an object with: a write() method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. a flush() method with no parameters, which will be called at the end of output. In write() method, it can implement code that reacts to each and every frame. The write() method is called frequently, so its implementation must be sufficiently rapid that it doesn\u2019t stall the encoding flow. Let\u2019s write a class FrameBuffer() which checks the JPEG Magic Number 0xFF 0xD8 at the beginning of an JPEG image: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user\u2019s webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' )","title":"2. Frame buffer"},{"location":"blog/pi/stream-picamera-mjpeg/#3-streaming-web-server","text":"Python has a built-in simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; BaseHTTPRequestHandler just provides a number of class and instance variables, and methods for use by subclasses. It must be subclassed to handle each request method (e.g. GET or POST). The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let\u2019s start with SimpleHTTPRequestHandler which has some implemented features.","title":"3. Streaming Web server"},{"location":"blog/pi/stream-picamera-mjpeg/#4-request-handler","text":"Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will looking for index.html for the homepage. To display image, create an <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web server should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) Send header with information to notify web client about type of responded content, which is multipart/x-mixed-replace Send the content in a stream format (loop forever!): send the boundary FRAME , send content type of each frame image/jpeg , send the length of the content, and then send the actual image data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating an instance of FrameBuffer , PiCamera , HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is availabe.","title":"4. Request Handler"},{"location":"blog/pi/stream-picamera-mjpeg/#5-synchronize-between-threads","text":"Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH streaming. However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming Hint Above sections are enough to create a simple MJPEG streaming server. Below sections are for an advanced implementation which need some advanced Python programming to create multiple buffers in an application, which can be used to merge or manipulate the image before sending to user\u2019s browsers.","title":"5. Synchronize between threads"},{"location":"blog/pi/stream-picamera-mjpeg/#6-some-updates-in-the-script","text":"The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let\u2019s check how they work.","title":"6. Some updates in the script"},{"location":"blog/pi/stream-picamera-mjpeg/#61-class-variable","text":"Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer","title":"6.1. Class variable"},{"location":"blog/pi/stream-picamera-mjpeg/#62-instance-variable","text":"Instance variables are for the data unique to each instance, they are create in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected params list to new params list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the param directory which is an optional param in original constructor of SimpleHTTPRequestHandler . To solve this problem, let\u2019s use special *args and **kwargs params.","title":"6.2. Instance variable"},{"location":"blog/pi/stream-picamera-mjpeg/#63-args-and-kwargs","text":"The special *args and **kwargs params allow to pass multiple arguments or keyword arguments to a function. Read about them in here . So, change the param list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler )","title":"6.3. *args and **kwargs"},{"location":"blog/pi/stream-picamera-mjpeg/#64-lambda-function","text":"Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args ))","title":"6.4. Lambda function"},{"location":"blog/pi/stream-picamera-mjpeg/#65-measure-fps","text":"In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"6.5. Measure FPS"},{"location":"blog/setup-blog/","text":"1. Installation \u2693\ufe0e There are some static site generators written in several languages such as Javascript, Go, Ruby, Python. They also use different template languages, e.g. React, Go, Liquid, Jinja. Among those generators, I\u2019d like to choose an engine based on Python language, because I am familiar with Python, so if I want to modify or add an extension, I can do it myself. Python-based site generators include MkDocs, Pelican, Sphinx, etc. MkDocs and Pelican are the most popular ones. I used Pelican few years ago, but recently, I was looking for a way to export blog posts to PDF files for printing and offline sharing, then Material theme for MkDocs which has a clear printing style became my choice. 1.1. Material for MkDocs \u2693\ufe0e MkDocs is a fast and simple engine to build a site for project documentation. Content source files are written in Markdown format, and the site is configured with a single YAML config file. MkDocs runs on Python 3 , so download and install it first. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features than the base MkDocs: it has webapp mode, flexible settings, and as I mentioned, it has a clear layout and good styles for printing. When installing this Material theme, it will automatically install the MkDocs engine. 1.1.1. Start a new project \u2693\ufe0e Create a new folder to store the project: mkdir CodeInsideOut cd CodeInsideOut Create the project\u2019s virtual environment to isolate this project with others from a possible package conflict: python -m venv .venv Activate the virtual environment: .venv\\Scripts\\activate.bat 1.1.2. Install main packages \u2693\ufe0e Update the pip , setuptools and wheel as they\u2019re used to install and configure other packages: python -m pip install -U pip setuptools wheel -U or --upgrade will upgrade the package if it is already installed Then install the Material for Mkdocs package: pip install -U mkdocs-material 1.1.3. Initialize the site \u2693\ufe0e Bring up the base of the site: mkdocs new . This will create the following file structure: . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material 1.1.4. Start a local server \u2693\ufe0e Run a local server with: mkdocs serve and preview the site at http://localhost:8000 to see the default homepage. 1.1.5. Write a post \u2693\ufe0e Each Markdown file inside the folder docs will be rendered to a page of the site. The index page is located at docs\\index.md . There can be sub-folders inside the docs directory to contain a group of posts in separate main topics. If a post is named other than index.md , the filename will be used as the directory path of the generated page. Here is how MkDocs generates URLs for Markdown posts: folder docs becomes the root of the site www.site.com/ file docs\\blog\\index.md becomes a link www.site.com/blog/ file docs\\blog\\a-post.md becomes a link www.site.com/blog/a-post/ Use hyphen - in folder name and file name to create good URLs. Here are some tips to keep URLs simple . 1.1.6. Publish \u2693\ufe0e To publish the site, build it first: mkdocs build then copy all the content in the site folder to the website root folder. 1.2. Visual Studio Code \u2693\ufe0e Download and install Visual Studio Code - a lightweight but powerful source code editor. It well supports users to write code, documents, notes. This editor also have some extensions to turn it into a full-feature IDE for coding, such as PlatformIO . Write blog posts and preview in a local browser Useful extensions for writing in Markdown format and editing HTML template: Markdown All in One : add keyboard shortcuts, auto completion, edit and format list and table Markdown Paste : paste images, links from the clipboard Draw.io Integration : edit diagrams and svg images Jinja : highlight Jinja syntax in HTML templates Sublime Text Keymap and Settings Importer : import keybindings and settings Code Spell Checker : catch common spelling errors Prettier - Code formatter : a formatter which supports a lot of languages 2. Configuration \u2693\ufe0e Material for MkDocs is just a start point. It is needed to be customized a little to fit my personal tastes. Refer to the official homepage of for more and complete guides, as I just list here main points to tweak the theme. 2.1. Site information \u2693\ufe0e Site information consists of the name, the URL, the title, a description and some keywords that are used to get brief information about the content of the site. These information is configured in the config file mkdocs.yml as below: site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming copyright : >- \u00a9 2021 Code Inside Out The social links can be added in the extra section in the config file mkdocs.yml . Refer to the guide of setting up the footer . The icon field must point to a valid icon path referencing to a bundled icon . extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/vuquangtrong name : vuquangtrong - icon : fontawesome/brands/facebook-f link : https://facebook.com/trongvq name : trongvq - icon : fontawesome/brands/linkedin-in link : https://www.linkedin.com/in/vqtrong name : vqtrong 2.2. Color palette \u2693\ufe0e Changing color is to select colors for 2 main groups: the primary color which is used for the header, the sidebar, text links and several other components. the accent color which is used to denote elements that can be interacted with, e.g. hovered links, buttons and scroll-bars. Both of them can be changed in mkdocs.yml by choosing a valid color name. As this page is intent to be printed on paper, I choose the white color as the primary look and feel, and the deep orange color for interactive elements. theme : palette : primary : white accent : deep orange 2.3. Fonts \u2693\ufe0e Serif fonts 1 are widely used for body text because they are considered to be more easier to read than Sans-Serif fonts in print. For better reading, distinguishing the digit zero 0 from the Latin script letter Oh o or O is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed / dotted / open zero 2 , but fonts for reading don\u2019t have those styles. It\u2019s also needed to clearly distinguish the digit one 1 with lowercase i i , the uppercase i I , and the lowercase l l . Luckily, they usually do not stand close to each other. To replace the defaults fonts , this site uses Noto Serif for the body text, and Roboto Mono for the code block. theme : font : text : Noto Serif code : Roboto Mono Can you easily read below pairs of characters? Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL 2.4. Logo & Icon \u2693\ufe0e I want to replace the default icon and logo with this code symbol . theme : icon : logo : fontawesome/solid/code favicon : favicon.png To use the included icons in Material theme, refer to Markdown syntax - Icons and Emojis . 2.5. Navigation \u2693\ufe0e Here are some interesting features for the navigation in Material theme: 2.5.1. Instant loading \u2693\ufe0e When instant loading is enabled, clicks on internal links will be intercepted and dispatched via XHR without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. Material for MkDocs is the only MkDocs theme offering this feature. Dynamic Javascript-enabled elements do not work after AJAX content is loaded After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. A solution is given in Fix AJAX issue . 2.5.2. Navigation tabs \u2693\ufe0e When tabs are enabled, top-level sections (first-level directories in the docs folder) are rendered in a menu layer below the header. 2.5.3. Back-to-top button \u2693\ufe0e A back-to-top button can be shown when the user, after scrolling down, starts to scroll up again. It\u2019s rendered in the lower right corner of the viewport, and help to go to the top a the page quickly. 2.5.4. Hide header bar \u2693\ufe0e When auto hiding is enabled, the header is automatically hidden when the user scrolls past a certain threshold, leaving more space for content. theme : features : - navigation.instant - navigation.tabs - navigation.top - header.autohide 2.6. Table of Content \u2693\ufe0e The Table of Content extension provides a quick navigation between sections in the post, it also places an anchor link at each header. This anchor can be used to link the header from other pages. The toc_depth: 4 makes the list displays from <h1> to <h4> . markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4 2.7. Site analytics \u2693\ufe0e Material for MkDocs natively integrates with Google Analytics . Just need to create a new GA property in order to obtain a unique tracking id of the form UA-XXXXXXXX-X , add it to mkdocs.yml: google_analytics : - UA-XXXXXXXX-X - auto 2.8. Comments section \u2693\ufe0e Material for MkDocs is natively integrated with Disqus , a comment system that provides a wide range of features like social integrations, user profiles, as well as spam and moderation tools. After setting up the site_url in mkdocs.yml , Disqus is configured by adding the Disqus shortname: extra : disqus : \"shortname\" This will insert a comment system on every page, except the index page . If the Metadata extension is enabled, Disqus can be disabled per page by using an empty string: --- disqus : \"\" --- 2.9. Extra styles and scripts \u2693\ufe0e Add stylesheets and javascript files to the docs directory as below structure: . \u251c\u2500 docs/ \u2502 \u251c\u2500 assets/ \u2502 | \u2514\u2500 extra.css \u2502 | \u2514\u2500 extra.js | \u2514\u2500 blog/ \u2514\u2500 mkdocs.yml Then, add the following line to mkdocs.yml : extra_css : - assets/extra.css extra_javascript : - assets/extra.js It\u2019s ready to add extra styles and scripts to the site at the moment, but it should be done later after adding new layouts and elements to the theme. At this time, I just need to add some small additional styles to make the theme look a bit harmonious with the selected theme color. To do that, in the webpage, right-click on an element, then select Inspect menu to go to the Developer Mode , and check the tag and the class of the selected element. The page content is usually wrapped inside the tag < article class = \"md-content__inner md-typeset\" > </ article > , so select either the tag or a class of that tag to use as the container of extra styles. Here are some small requirements: Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } For more stylings, please read more in Customize theme . 2.10. Override templates \u2693\ufe0e MkDocs allows to override the them by just adding extra files that will replace the original ones when building the site. Create a new folder overrides in the project folder to save the overriding files, then enable them in the config file mkdocs.yml : theme : name : material custom_dir : overrides 2.10.1. Override files \u2693\ufe0e The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , which originally located in the folder .venv\\Lib\\site-packages\\material , is the starting point of any site\u2019s page. All other pages should extend from it. The main.html template, which extends the base.html , is used to add a custom template. To use other template, in the metadata of the Markdown file, set the attribute template with the name of template file. For example: --- title: Blog template: blog.html --- 2.10.2. Override blocks \u2693\ufe0e Besides overriding partials, it\u2019s also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new template .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>New title</title> {% endblock %} To extend a block, use the {{ super () }} command: {% extends \"base.html\" %} {% block head %} {{ super () }} Appended content {% endblock %} To replace a block, don\u2019t use the {{ super () }} command. {% block head %} New content {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available) 2.10.3. The index page \u2693\ufe0e The index page of the website is located at docs\\index.md . Material theme created a default one then it has to be modified. I\u2019d like to write a brief information about me and why this blog is created: Welcome to # Code Inside Out Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89\\*:\u30fb\uff9f \u2727 2.10.4. The 404 page \u2693\ufe0e Whenever a page is not found in a website, the error 404 is return to the requested users. I need to create this special page to display a short message and guide user to search in this blog. The 404 page should be created in the overrides folder as it will replace the default 404 page of Material theme. Its layout is based on the base.html , and the content is a message displayed in the center of the page. The disqus comment section is removed. The sidebar should not be visible to display message clearly. {% extends \"main.html\" %} {% block content %} <style> .md-sidebar { display: none; } </style> <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage,<br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %} 3. Markdown extensions \u2693\ufe0e Markdown comes with a simple syntax to create headers, links, images, and paragraphs with formatted text, lists. However, that\u2019s not enough. Some Markdown extensions bring more syntaxes to create complex elements or new layouts that help writing documents easier, faster, and look professional. Read more in Markdown syntax . 4. MkDocs plugins \u2693\ufe0e New features can be added to MkDocs engine by installing plugins. These packages can modify the navigation behavior, or render new content types, or export the site to PDF documents. Plugins also can be modified easily as they are written in Python. Read more in MkDocs plugins . 5. Customize theme \u2693\ufe0e A personal website should look different to others to make it unique and standout. I prefer a simple look which goes straight to the content, and pages should be clear to be printed on papers. Therefore, I modified styles for some elements, also bring must-have elements of a blog like tag cloud, tag page, list of posts. Read more in Customize theme . 6. Print to PDF \u2693\ufe0e For printing or offline reading, the document should be exported to PDF format. A manual method is to print each post by the user browser. There is a plugin to automatically export all site\u2019s posts to PDF during the build time, but it needs some configuration to work as I expected. Generated PDF files can be download by clicking on the download button at the beginning of each page. Read more in Print to PDF . https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"Setup blog"},{"location":"blog/setup-blog/#1-installation","text":"There are some static site generators written in several languages such as Javascript, Go, Ruby, Python. They also use different template languages, e.g. React, Go, Liquid, Jinja. Among those generators, I\u2019d like to choose an engine based on Python language, because I am familiar with Python, so if I want to modify or add an extension, I can do it myself. Python-based site generators include MkDocs, Pelican, Sphinx, etc. MkDocs and Pelican are the most popular ones. I used Pelican few years ago, but recently, I was looking for a way to export blog posts to PDF files for printing and offline sharing, then Material theme for MkDocs which has a clear printing style became my choice.","title":"1. Installation"},{"location":"blog/setup-blog/#11-material-for-mkdocs","text":"MkDocs is a fast and simple engine to build a site for project documentation. Content source files are written in Markdown format, and the site is configured with a single YAML config file. MkDocs runs on Python 3 , so download and install it first. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features than the base MkDocs: it has webapp mode, flexible settings, and as I mentioned, it has a clear layout and good styles for printing. When installing this Material theme, it will automatically install the MkDocs engine.","title":"1.1. Material for MkDocs"},{"location":"blog/setup-blog/#111-start-a-new-project","text":"Create a new folder to store the project: mkdir CodeInsideOut cd CodeInsideOut Create the project\u2019s virtual environment to isolate this project with others from a possible package conflict: python -m venv .venv Activate the virtual environment: .venv\\Scripts\\activate.bat","title":"1.1.1. Start a new project"},{"location":"blog/setup-blog/#112-install-main-packages","text":"Update the pip , setuptools and wheel as they\u2019re used to install and configure other packages: python -m pip install -U pip setuptools wheel -U or --upgrade will upgrade the package if it is already installed Then install the Material for Mkdocs package: pip install -U mkdocs-material","title":"1.1.2. Install main packages"},{"location":"blog/setup-blog/#113-initialize-the-site","text":"Bring up the base of the site: mkdocs new . This will create the following file structure: . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material","title":"1.1.3. Initialize the site"},{"location":"blog/setup-blog/#114-start-a-local-server","text":"Run a local server with: mkdocs serve and preview the site at http://localhost:8000 to see the default homepage.","title":"1.1.4. Start a local server"},{"location":"blog/setup-blog/#115-write-a-post","text":"Each Markdown file inside the folder docs will be rendered to a page of the site. The index page is located at docs\\index.md . There can be sub-folders inside the docs directory to contain a group of posts in separate main topics. If a post is named other than index.md , the filename will be used as the directory path of the generated page. Here is how MkDocs generates URLs for Markdown posts: folder docs becomes the root of the site www.site.com/ file docs\\blog\\index.md becomes a link www.site.com/blog/ file docs\\blog\\a-post.md becomes a link www.site.com/blog/a-post/ Use hyphen - in folder name and file name to create good URLs. Here are some tips to keep URLs simple .","title":"1.1.5. Write a post"},{"location":"blog/setup-blog/#116-publish","text":"To publish the site, build it first: mkdocs build then copy all the content in the site folder to the website root folder.","title":"1.1.6. Publish"},{"location":"blog/setup-blog/#12-visual-studio-code","text":"Download and install Visual Studio Code - a lightweight but powerful source code editor. It well supports users to write code, documents, notes. This editor also have some extensions to turn it into a full-feature IDE for coding, such as PlatformIO . Write blog posts and preview in a local browser Useful extensions for writing in Markdown format and editing HTML template: Markdown All in One : add keyboard shortcuts, auto completion, edit and format list and table Markdown Paste : paste images, links from the clipboard Draw.io Integration : edit diagrams and svg images Jinja : highlight Jinja syntax in HTML templates Sublime Text Keymap and Settings Importer : import keybindings and settings Code Spell Checker : catch common spelling errors Prettier - Code formatter : a formatter which supports a lot of languages","title":"1.2. Visual Studio Code"},{"location":"blog/setup-blog/#2-configuration","text":"Material for MkDocs is just a start point. It is needed to be customized a little to fit my personal tastes. Refer to the official homepage of for more and complete guides, as I just list here main points to tweak the theme.","title":"2. Configuration"},{"location":"blog/setup-blog/#21-site-information","text":"Site information consists of the name, the URL, the title, a description and some keywords that are used to get brief information about the content of the site. These information is configured in the config file mkdocs.yml as below: site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming copyright : >- \u00a9 2021 Code Inside Out The social links can be added in the extra section in the config file mkdocs.yml . Refer to the guide of setting up the footer . The icon field must point to a valid icon path referencing to a bundled icon . extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/vuquangtrong name : vuquangtrong - icon : fontawesome/brands/facebook-f link : https://facebook.com/trongvq name : trongvq - icon : fontawesome/brands/linkedin-in link : https://www.linkedin.com/in/vqtrong name : vqtrong","title":"2.1. Site information"},{"location":"blog/setup-blog/#22-color-palette","text":"Changing color is to select colors for 2 main groups: the primary color which is used for the header, the sidebar, text links and several other components. the accent color which is used to denote elements that can be interacted with, e.g. hovered links, buttons and scroll-bars. Both of them can be changed in mkdocs.yml by choosing a valid color name. As this page is intent to be printed on paper, I choose the white color as the primary look and feel, and the deep orange color for interactive elements. theme : palette : primary : white accent : deep orange","title":"2.2. Color palette"},{"location":"blog/setup-blog/#23-fonts","text":"Serif fonts 1 are widely used for body text because they are considered to be more easier to read than Sans-Serif fonts in print. For better reading, distinguishing the digit zero 0 from the Latin script letter Oh o or O is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed / dotted / open zero 2 , but fonts for reading don\u2019t have those styles. It\u2019s also needed to clearly distinguish the digit one 1 with lowercase i i , the uppercase i I , and the lowercase l l . Luckily, they usually do not stand close to each other. To replace the defaults fonts , this site uses Noto Serif for the body text, and Roboto Mono for the code block. theme : font : text : Noto Serif code : Roboto Mono Can you easily read below pairs of characters? Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL","title":"2.3. Fonts"},{"location":"blog/setup-blog/#24-logo--icon","text":"I want to replace the default icon and logo with this code symbol . theme : icon : logo : fontawesome/solid/code favicon : favicon.png To use the included icons in Material theme, refer to Markdown syntax - Icons and Emojis .","title":"2.4. Logo &amp; Icon"},{"location":"blog/setup-blog/#25-navigation","text":"Here are some interesting features for the navigation in Material theme:","title":"2.5. Navigation"},{"location":"blog/setup-blog/#251-instant-loading","text":"When instant loading is enabled, clicks on internal links will be intercepted and dispatched via XHR without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. Material for MkDocs is the only MkDocs theme offering this feature. Dynamic Javascript-enabled elements do not work after AJAX content is loaded After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. A solution is given in Fix AJAX issue .","title":"2.5.1. Instant loading"},{"location":"blog/setup-blog/#252-navigation-tabs","text":"When tabs are enabled, top-level sections (first-level directories in the docs folder) are rendered in a menu layer below the header.","title":"2.5.2. Navigation tabs"},{"location":"blog/setup-blog/#253-back-to-top-button","text":"A back-to-top button can be shown when the user, after scrolling down, starts to scroll up again. It\u2019s rendered in the lower right corner of the viewport, and help to go to the top a the page quickly.","title":"2.5.3. Back-to-top button"},{"location":"blog/setup-blog/#254-hide-header-bar","text":"When auto hiding is enabled, the header is automatically hidden when the user scrolls past a certain threshold, leaving more space for content. theme : features : - navigation.instant - navigation.tabs - navigation.top - header.autohide","title":"2.5.4. Hide header bar"},{"location":"blog/setup-blog/#26-table-of-content","text":"The Table of Content extension provides a quick navigation between sections in the post, it also places an anchor link at each header. This anchor can be used to link the header from other pages. The toc_depth: 4 makes the list displays from <h1> to <h4> . markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4","title":"2.6. Table of Content"},{"location":"blog/setup-blog/#27-site-analytics","text":"Material for MkDocs natively integrates with Google Analytics . Just need to create a new GA property in order to obtain a unique tracking id of the form UA-XXXXXXXX-X , add it to mkdocs.yml: google_analytics : - UA-XXXXXXXX-X - auto","title":"2.7. Site analytics"},{"location":"blog/setup-blog/#28-comments-section","text":"Material for MkDocs is natively integrated with Disqus , a comment system that provides a wide range of features like social integrations, user profiles, as well as spam and moderation tools. After setting up the site_url in mkdocs.yml , Disqus is configured by adding the Disqus shortname: extra : disqus : \"shortname\" This will insert a comment system on every page, except the index page . If the Metadata extension is enabled, Disqus can be disabled per page by using an empty string: --- disqus : \"\" ---","title":"2.8. Comments section"},{"location":"blog/setup-blog/#29-extra-styles-and-scripts","text":"Add stylesheets and javascript files to the docs directory as below structure: . \u251c\u2500 docs/ \u2502 \u251c\u2500 assets/ \u2502 | \u2514\u2500 extra.css \u2502 | \u2514\u2500 extra.js | \u2514\u2500 blog/ \u2514\u2500 mkdocs.yml Then, add the following line to mkdocs.yml : extra_css : - assets/extra.css extra_javascript : - assets/extra.js It\u2019s ready to add extra styles and scripts to the site at the moment, but it should be done later after adding new layouts and elements to the theme. At this time, I just need to add some small additional styles to make the theme look a bit harmonious with the selected theme color. To do that, in the webpage, right-click on an element, then select Inspect menu to go to the Developer Mode , and check the tag and the class of the selected element. The page content is usually wrapped inside the tag < article class = \"md-content__inner md-typeset\" > </ article > , so select either the tag or a class of that tag to use as the container of extra styles. Here are some small requirements: Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } For more stylings, please read more in Customize theme .","title":"2.9. Extra styles and scripts"},{"location":"blog/setup-blog/#210-override-templates","text":"MkDocs allows to override the them by just adding extra files that will replace the original ones when building the site. Create a new folder overrides in the project folder to save the overriding files, then enable them in the config file mkdocs.yml : theme : name : material custom_dir : overrides","title":"2.10. Override templates"},{"location":"blog/setup-blog/#2101-override-files","text":"The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , which originally located in the folder .venv\\Lib\\site-packages\\material , is the starting point of any site\u2019s page. All other pages should extend from it. The main.html template, which extends the base.html , is used to add a custom template. To use other template, in the metadata of the Markdown file, set the attribute template with the name of template file. For example: --- title: Blog template: blog.html ---","title":"2.10.1. Override files"},{"location":"blog/setup-blog/#2102-override-blocks","text":"Besides overriding partials, it\u2019s also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new template .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>New title</title> {% endblock %} To extend a block, use the {{ super () }} command: {% extends \"base.html\" %} {% block head %} {{ super () }} Appended content {% endblock %} To replace a block, don\u2019t use the {{ super () }} command. {% block head %} New content {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available)","title":"2.10.2. Override blocks"},{"location":"blog/setup-blog/#2103-the-index-page","text":"The index page of the website is located at docs\\index.md . Material theme created a default one then it has to be modified. I\u2019d like to write a brief information about me and why this blog is created: Welcome to # Code Inside Out Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89\\*:\u30fb\uff9f \u2727","title":"2.10.3. The index page"},{"location":"blog/setup-blog/#2104-the-404-page","text":"Whenever a page is not found in a website, the error 404 is return to the requested users. I need to create this special page to display a short message and guide user to search in this blog. The 404 page should be created in the overrides folder as it will replace the default 404 page of Material theme. Its layout is based on the base.html , and the content is a message displayed in the center of the page. The disqus comment section is removed. The sidebar should not be visible to display message clearly. {% extends \"main.html\" %} {% block content %} <style> .md-sidebar { display: none; } </style> <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage,<br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %}","title":"2.10.4. The 404 page"},{"location":"blog/setup-blog/#3-markdown-extensions","text":"Markdown comes with a simple syntax to create headers, links, images, and paragraphs with formatted text, lists. However, that\u2019s not enough. Some Markdown extensions bring more syntaxes to create complex elements or new layouts that help writing documents easier, faster, and look professional. Read more in Markdown syntax .","title":"3. Markdown extensions"},{"location":"blog/setup-blog/#4-mkdocs-plugins","text":"New features can be added to MkDocs engine by installing plugins. These packages can modify the navigation behavior, or render new content types, or export the site to PDF documents. Plugins also can be modified easily as they are written in Python. Read more in MkDocs plugins .","title":"4. MkDocs plugins"},{"location":"blog/setup-blog/#5-customize-theme","text":"A personal website should look different to others to make it unique and standout. I prefer a simple look which goes straight to the content, and pages should be clear to be printed on papers. Therefore, I modified styles for some elements, also bring must-have elements of a blog like tag cloud, tag page, list of posts. Read more in Customize theme .","title":"5. Customize theme"},{"location":"blog/setup-blog/#6-print-to-pdf","text":"For printing or offline reading, the document should be exported to PDF format. A manual method is to print each post by the user browser. There is a plugin to automatically export all site\u2019s posts to PDF during the build time, but it needs some configuration to work as I expected. Generated PDF files can be download by clicking on the download button at the beginning of each page. Read more in Print to PDF . https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"6. Print to PDF"},{"location":"blog/setup-blog/customize-theme/","text":"1. The post\u2019s title \u2693\ufe0e By using the Awesome Pages plugin and the Section index plugin, the navigation sidebar can show a good structure of posts. However, each entry is displaying the post\u2019s title with long text, this make the navigation bar look a bit messy. It is easy to add a full title into a post by using the Metadata section . For example: --- title : Customize theme title_full : Customize the theme with personal styles description : A personal website should look different to others ... --- However, the content of each post will also display the short title. To fix this, I am going to override the main template. Before do it, I will add tags in the Metadata section also. 2. The post\u2019s tags \u2693\ufe0e A tag is a word or a phrase that describes one main point of a blog post\u2019s content. They are an easy way to attach labels to the content and link similar posts together. The tags of a post are defined in the Metadata section , then they are gathered and processed in templates later. --- title : title description : description tags : - python - mkdocs --- 3. The Tags page \u2693\ufe0e The tag page is the place to list all tags, and list all pages that have a common tag. A new page will be created at docs\\tags\\index.md . There is a method to use MkDocs Macros in Markdown template, but it is quite complicated. I use Jinja syntax to create the content of the Tags page, therefore, create a new file at overrides\\tags.html and use it as the template for the Tags page: docs\\tags\\index.md --- title : Tags description : Tags and list of pages template : tags.html hide : - disqus --- # Tags The tags.html template to include 2 parts: tag-cloud.html : make a tag cloud to see how many pages are associated with a tag tag-list-pages.html : for each tag, list all pages having that tag to show similar articles together overrides\\tags.html {% extends \"main.html\" %} {% block page_content %} {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-page-list.html\" %} {% endblock %} Tags will have random colors, to easily disguise them to each other. A helper random_color() macro that returns a random color looks like: overrides\\partials\\random-colors.html {% - macro random_color () - %} {{ - [ \"DarkRed\" , \"DarkGoldenrod\" , \"DarkGreen\" , \"DarkOliveGreen\" , \"DarkCyan\" , \"DarkTurquoise\" , \"DarkBlue\" , \"DarkMagenta\" , \"DarkViolet\" , \"DarkSlateBlue\" , \"DarkOrchid\" , \"DarkSlateGray\" ] | random - }} {% - endmacro - %} Then it can be imported as: {% from \"partials/random-colors.html\" import random_color %} 3.1. The tag cloud \u2693\ufe0e The tag cloud shows all tags in different size and color. The bigger a tag is, the more pages mention that tag. Steps to make a tag cloud: Scan all pages and create a list of pairs (tag, pages[]) {% set tags =[] %} {# scan all pages #} {% for p in pages %} {% if p.page.meta.tags %} {# extract tags if available #} {% for tag in p.page.meta.tags %} {% if tags | length %} {% set ns = namespace ( found = False ) %} {# read more about scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments #} {# check if tag exists, append to its page list #} {% for item in tags %} {% set t , ps = item %} {% if tag == t %} {% set ns.found = True %} {{ ps.append ( p.page ) or \"\" }} {# use (or \"\") to not print} #} {% endif %} {% endfor %} {# if tag doesn't exist, create new page list#} {% if not ns.found %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% else %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% endfor %} {% endif %} {% endfor %} Count the number of pages for each tag then show each tag with different text size and color using font-size and color attributes <p class=\"md-nav\"> <label class=\"md-nav__title\">Tag cloud</label> </p> <div class=\"tag-cloud-content\"> {% if tags | count %} {% for item in tags %} {% set tag , ps = item %} {# create a link with tag name #} {# font size is based on the page count #} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\" font-size: {{ 0.6 + ps | count * 0.1 }} rem; color: {{ random_color () }} ; \"> {{ - tag - }} </span> <sup class=\"tag-count\"> {{ - ps | count - }} </sup> </a> {% endfor %} {% else %} <div> <h3>No tag found!</h3> </div> {% endif %} </div> 3.2. List pages of a tag \u2693\ufe0e This section is simple as it just needs to loop through the list of pairs (tag, pages[]) and create a link to each page. Steps to do that: Scan all pages and create a list of pairs (tag, pages[]) see above section Show each tag with the list of pages in a collapsible <details> block <div class=\"tag-page-list\"> {% for item in tags %} {% set tag , ps = item %} <details class=\"note\" id= {{ tag }} > <summary> {{ - tag }} ( {{ - ps | count - }} ) <a class=\"headerlink\" href=\"# {{ tag }} \">\u2693\ufe0e</a> </summary> <ol> {% for p in ps %} <li> <a href=\" {{ page.canonical_url }} \"> {% - if p.meta and p.meta.title_full - %} {{ - p.meta.title_full - }} {% - elif p.meta and p.meta.title - %} {{ - p.meta.title - }} {% - else - %} {{ - p.title - }} ` {% - endif - %} </a> </li> {% endfor %} </ol> </details> {% endfor %} </div> Only one tag block is open at a time to easily follow the selected tag. To do this, I added a callback of the toggle event on all tag blocks. Whenever a block is opened, this script will close all others [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false ; D . addEventListener ( \"toggle\" , ( E ) => D . open && A . forEach (( d ) => d != E . target && ( d . open = false )) ); }); A tag block can be opened via URL with hash being the selected tag var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } Visit the Tags to see the result. 4. The recent blog posts \u2693\ufe0e There should be a page showing the recent posts to help users see what is new and updated. With the Revision Date plugin, it is able to use two new meta-dat fields: git_revision_date_localized , and git_creation_date_localized if the option enable_creation_date is true . Create new index.md file inside the blog folder. When using the Section Index plugin, this index file will be merged to the Blog section, therefore, when user select the Blog label, there is a list of recent posts will be shown. This page will use the blog.html template in which it scans all posts and check the creation date to make a list of posts. Each post should be displayed in a container and be formatted to show the title, the description (at most 250 character using the truncate filter), the creation date, and its tags. Need to check the page\u2019s path to filter blog posts. In my code, I use the abs_url and its length to check if a page is in the blog directory. Here is the code to sort all pages in order of creation date, and then filter all blog posts to save into the array blog_pages which will be used to generate content. {% set blog_pages =[] %} {% for p in pages | sort ( attribute = 'page.meta.git_creation_date_localized' , reverse = True ) %} {% set pg = p.page %} {% if pg.abs_url.startswith ( '/blog/' ) and pg.abs_url | length > 6 %} {{ blog_pages.append ( pg ) or \"\" }} {% endif %} {% endfor %} <div class=\"pages\"> ... create list from blog_pages ... </div> 4.1. Create the pagination \u2693\ufe0e When the number of posts goes bigger, the recent post list becomes longer. It\u2019s time to brake the long list into pages - the user can click on the page number to see its children posts. This is called \u201cPagination\u201d. How to implement it? Jinja template has the slice filter to divide a list into sub-lists. Here, I\u2019d like to have maximum of 10 posts on each page. <div class=\"pages\"> {% for pg_group in blog_pages | slice (( blog_pages | count / 10 )| int ) %} <div class=\"page\" id=\"page {{ loop .index }} \"> {% for pg in pg_group %} <div class=\"post\"> ... create post layout and content ... </div> {% endfor %} </div> {% endfor %} </div> 4.2. Create a post entry \u2693\ufe0e Each post is wrapped inside a < div class = \"post\" > and its elements are marked with different classes, such as post-title , post-description , etc. for applying styles later. <div class=\"post\"> <h3 class=\"post-title\"> <a class=\"link\" href=\" {{ pg.canonical_url }} \"> {{ title }} </a> </h3> <p class=\"post-description\"> {% if pg.meta.description %} {{ pg.meta.description | truncate }} {% endif %} </p> <div class=\"post-extra\"> <span class=\"post-timestamp\"> {% if pg.meta and pg.meta.git_revision_date_localized %} <span class=\"post-timestamp-update\"> Updated: {{ pg.meta.git_revision_date_localized - }} </span> {% endif %} </span> <span class=\"post-tags\"> {% if pg.meta.tags %} {% for tag in pg.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} {% endif %} </span> </div> <hr /> </div> Here is a simple styles to make each post display necessary basic information: . md-typeset . post : first-of-type h3 { margin-top : 0 ; } . md-typeset . post-title { margin-bottom : 0 ; } . md-typeset . post-extra { color : gray ; } . md-typeset . post-tags { float : right ; } 4.3. Create active page \u2693\ufe0e To show the current active page, I use pure css and javascript. The idea is to use the URL hash to detect which page is activated, such as #page1 . <div class=\"center\"> <div class=\"pagination\" id=\"pagination\"> <a href=\"#\">&laquo;</a> {% for pg_group in blog_pages | slice (( blog_pages | count / 10 )| int ) %} <a class=\"page-number {% if loop .index == 1 %} active {% endif %} \" href=\"#page {{ loop .index }} \"> {{ loop .index }} </a> {% endfor %} <a href=\"#\">&raquo;</a> </div> </div> Then add some styles to the pagination block and its children links: CSS Styles : Use target keyword to select the selected page id , then show only the target element. assets\\extra.css . md-typeset . pages > . page : target ~ . page : last-child , . md-typeset . pages > . page { display : none ; } . md-typeset . pages > : last-child , . md-typeset . pages > . page : target { display : block ; } Javascript When the page is loaded, a script will run to get all pagination\u2019s links, and then add a callback function for click event, that remove active class from last activated element and then assign active class to the event\u2019s source element. Note that the first page is activated by default when the page is loaded. assets\\extra.js var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } 5. The main template \u2693\ufe0e The main.html file, extending the base.html template, will be used for all markdown pages and it is the starting point to add custom template. To override it, add the main.html file in the overrides folder. Here are things I\u2019m going to do to add more content into a blog post: Extract metadata to get title , title_full , description , tags , and other information {% set title = config.site_name %} {% if page and page.meta and page.meta.title_full %} {% set title = page.meta.title_full %} {% elif page and page.meta and page.meta.title %} {% set title = page.meta.title %} {% elif page and page.title %} {% set title = page.title %} {% endif %} {% set description = config.site_description %} {% if page and page.meta and page.meta.description %} {% set description = page.meta.description %} {% endif %} {% if page and page.meta and page.meta.banner %} {% set image = page.meta.banner %} {% endif %} {% if page and page.meta and page.meta.tags %} {% set tags = page.meta.tags %} {% endif %} Add block to use the Open Graph protocol to show the page\u2019s information when an user shares a page on a social network {% block htmltitle %} <title> {{ title | striptags }} - {{ config.site_name }} </title> {% endblock %} {% block extrahead %} <meta property=\"og:type\" content=\"website\" /> <meta property=\"og:title\" content=\" {{ - title | striptags ~ ' - ' ~ config.site_name - }} \"/> <meta property=\"og:description\" content=\" {{ description }} \" /> <meta property=\"og:url\" content=\" {{ page.canonical_url }} \" /> <meta property=\"og:image\" content=\" {% - if image is defined - %} {{ page.canonical_url ~ image }} {% - else - %} {{ config.site_url ~ 'assets/banner.jpg' }} {% - endif - %} \" /> <meta property=\"og:site_name\" content=\" {{ config.site_name }} \" /> <meta name=\"twitter:card\" content=\"summary\" /> {% endblock %} The page content should have a cover section which displays the title , description and tags on all pages, except the home page. {% block content %} {% if not page.is_homepage %} <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} </div> {% endif %} {{ page.content }} {% endblock %} The tag cloud should show in the sidebars based on the page\u2019s width {% block site_nav %} {% if nav %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"navigation\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--primary\" data-md-component=\"sidebar\" data-md-type=\"navigation\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/nav.html\" %} <div class=\"tag-cloud-nav\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% if page.toc and not \"toc.integrate\" in features %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"toc\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--secondary\" data-md-component=\"sidebar\" data-md-type=\"toc\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/toc.html\" %} <div class=\"tag-cloud-toc\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% endblock %} 6. Zoom-in Images \u2693\ufe0e As mentioned in the Images section, view-bigimg library helps to zoom and pan images. It\u2019s useful when the image is in high resolution and resized to fit site\u2019s width. Download view-bigimg.css and view-bigimg.js files from the view-bigimg repo, then add them into the addition assets configs in mkdocs.yml : mkdocs.yml extra_css : - assets/view-bigimg.css extra_javascript : - assets/view-bigimg.js When click on the image, this library will create a new layer and show the image in a bigger size. However, it must be clicked on the close button to go back to the page\u2019s content. I want to simplify this step by just click on the image. Panning still is activated by press and hold. Therefore, I write a function to detect mousedown and mousemove event, then only close the image if it is a simple click: assets\\extra.js var dragged = false ; document . addEventListener ( \"mousedown\" , () => ( dragged = false )); document . addEventListener ( \"mousemove\" , () => ( dragged = true )); var viewer = new ViewBigimg (); var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } 7. Open external links \u2693\ufe0e When following links, to remain the blog page opened, external links should be shown in new tabs without any tracking information. To do that, I write some lines of code to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" to them. assets\\extra.js /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } 8. Custom styles \u2693\ufe0e After all extensions and plugins are installed, some extra pages and elements are added, this is the time to tweak the whole site\u2019s styles. 8.1. Colors \u2693\ufe0e Here are some small additional styles to make the theme look a bit harmonious with the selected theme color Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } The highlight color should not be too yellowish, I\u2019d like to reduce its opacity: : root > * { --md-code-hl-color : rgba ( 255 , 255 , 0 , 0.1 ); --md-typeset-mark-color : var ( --md-code-hl-color ); } 8.2. Admonition \u2693\ufe0e I want to make admonitions look more harmonious to the theme, so I decided to remove border and shadow box, then add a light background color which is the title background color of each type. The font and the margin also need modified a bit to make admonitions look consistent to the main content. First, icon should be bigger: . md-typeset . admonition-title : before , . md-typeset summary : before { height : 1.2 rem ; width : 1.2 rem ; } Remove border, shadow box, and increase font size: . md-typeset . admonition , . md-typeset details { border : none ; box-shadow : none ; font-size : 0.95 em ; margin-top : 0 ; } Remove background color in the title, step it back to the right, due to the increased icon size: . md-typeset . admonition > . admonition-title , . md-typeset details > summary { background-color : transparent !important ; border-left : 0.2 rem solid transparent !important ; padding-left : 3 em ; } Fill background color for different admonition types: . md-typeset . admonition . note , . md-typeset details . note { background-color : rgba ( 68 , 138 , 255 , 0.05 ); } . md-typeset . admonition . abstract , . md-typeset . admonition . summary , . md-typeset . admonition . tldr , . md-typeset details . abstract , . md-typeset details . summary , . md-typeset details . tldr { background-color : rgba ( 0 , 176 , 255 , 0.05 ); } . md-typeset . admonition . info , . md-typeset . admonition . todo , . md-typeset details . info , . md-typeset details . todo { background-color : rgba ( 0 , 184 , 212 , 0.05 ); } . md-typeset . admonition . hint , . md-typeset . admonition . important , . md-typeset . admonition . tip , . md-typeset details . hint , . md-typeset details . important , . md-typeset details . tip { background-color : rgba ( 0 , 191 , 165 , 0.05 ); } . md-typeset . admonition . check , . md-typeset . admonition . done , . md-typeset . admonition . success , . md-typeset details . check , . md-typeset details . done , . md-typeset details . success { background-color : rgba ( 0 , 200 , 83 , 0.05 ); } . md-typeset . admonition . faq , . md-typeset . admonition . help , . md-typeset . admonition . question , . md-typeset details . faq , . md-typeset details . help , . md-typeset details . question { background-color : rgba ( 100 , 221 , 23 , 0.05 ); } . md-typeset . admonition . attention , . md-typeset . admonition . caution , . md-typeset . admonition . warning , . md-typeset details . attention , . md-typeset details . caution , . md-typeset details . warning { background-color : rgba ( 255 , 145 , 0 , 0.05 ); } . md-typeset . admonition . fail , . md-typeset . admonition . failure , . md-typeset . admonition . missing , . md-typeset details . fail , . md-typeset details . failure , . md-typeset details . missing { background-color : rgba ( 255 , 82 , 82 , 0.05 ); } . md-typeset . admonition . danger , . md-typeset . admonition . error , . md-typeset details . danger , . md-typeset details . error { background-color : rgba ( 255 , 23 , 68 , 0.05 ); } . md-typeset . admonition . bug , . md-typeset details . bug { background-color : rgba ( 245 , 0 , 87 , 0.05 ); } . md-typeset . admonition . example , . md-typeset details . example { background-color : rgba ( 124 , 77 , 255 , 0.05 ); } . md-typeset . admonition . cite , . md-typeset . admonition . quote , . md-typeset details . cite , . md-typeset details . quote { background-color : hsla ( 0 , 0 % , 62 % , 0.05 ); } Make the content close to the title a bit: . md-typeset . admonition > . admonition-title + *, . md-typeset details > summary + * { margin-top : 0 ; } Change admonition style And tweak the style to show admonitions which has icon but do not have title. The trick is to add left padding to the first letter in the content paragraph , and move the content up by applying a negative top margin: . md-typeset . admonition . nt > . admonition-title + p :: first-letter , . md-typeset details . nt > summary + p :: first-letter { padding-left : 2.2 em ; } . md-typeset . admonition . nt > . admonition-title + *, . md-typeset details . nt > summary + * { margin-top : -2.1 em ; } Use these additional styles, with .nt class and an empty title (use \"&nbsp;\" or \"\\ \" ): !!! info nt \"\\ \" This admonition has an icon as an inline element with the content !!! info Default title !!! info \"New title\" Content of the admonition is indented !!! info \"\" There is no title and no icon This admonition has an icon as an inline element with the content Info Default title New title Content of the admonition There is no title and no icon 8.3. Quotes \u2693\ufe0e Quote is used to provide additional data, so I changed its style a bit to not make it confusing with the main text. . md-typeset blockquote { color : unset ; border-left-width : 2 px ; opacity : 0.7 ; } . md-typeset blockquote : first-child { margin-top : 0.25 em ; } . md-typeset blockquote : last-child { margin-bottom : 0.25 em ; } Admonition also has quote and cite type which are used as cited content. 8.4. Code block \u2693\ufe0e It is better to show the line number inline with its line of code: markdown_extensions : - meta - pymdownx.superfences - pymdownx.highlight : linenums_style : pymdownx-inline And then increase the font size to get make them easy to read: . md-typeset code , . md-typeset kbd { font-size : 1 em ; word-break : keep-all !important ; } . md-typeset pre code { white-space : pre-wrap ; font-size : 0.9 em ; } Then the line number should be dimmed to not distract the main code: . md-typeset . highlight [ data-linenos ] : before { background-color : transparent ; box-shadow : none ; color : lightgray ; } #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } 8.5. Tables \u2693\ufe0e Table should show cell border and use full width to make the content clear. . md-typeset__scrollwrap { margin : unset ; } . md-typeset__table { padding : 0 ; display : block ; } . md-typeset table : not ([ class ]) { font-size : 0.9 em ; box-shadow : none ; display : table ; border-collapse : collapse ; } . md-typeset table : not ([ class ]) th , . md-typeset table : not ([ class ]) td { padding : 0.5 em ; border : 1 px solid #f0f0f0 ; min-width : unset ; } Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts 8.6. Tabs \u2693\ufe0e Tab\u2019s content should show some intent to visualize its structure. The label is tweaked a bit to look consisted with its content at the left margin. Note that in printing, all tabs will be expanded to show all of its content. . md-typeset . tabbed-content { box-shadow : none ; border-top : 1 px solid var ( --md-default-fg-color--lightest ); } . md-typeset . tabbed-content > . tabbed-set { padding-left : 2 em ; } . md-typeset . tabbed-set > label { font-size : 0.9 em ; padding : 0 margin-right : 1.25 em ; } Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts 8.7. Buttons \u2693\ufe0e When using white primary color, the default button class md-button has issues to display correctly. Here are the fix for those buttons: change the margin to make them smaller change the border, and text color change the size of the icon . md-typeset . md-button { font-size : small ; font-weight : unset ; padding : 0.25 em 0.5 em ; border : 1 px solid ; color : orangered ; } . md-typeset . md-button . twemoji { font-size : large ; } Click here 8.8. Image caption \u2693\ufe0e The caption should not have restricted width, and its bottom margin should be smaller. . md-typeset figcaption { max-width : unset ; margin : 1 em auto ; } A photo from https://picsum.photos 8.9. Sidebar scrolls \u2693\ufe0e Only show the scrollbar when hovering to make sidebar look clear. . md-sidebar__scrollwrap { overflow : hidden ; } . md-sidebar__scrollwrap : hover { overflow-y : auto ; } 8.10. Spaces \u2693\ufe0e This part modifies some small space gap and margins to make the overall layout look better. Remove some space gaps. . md-main__inner { margin-top : 0 ; } md-typeset dd { margin : 0 em 0 1 em 1.875 em ; } . md-typeset dd > * { margin-top : 0 ; } . md-typeset p : empty { display : none ; } . md-typeset . admonition + *, . md-typeset details + * { margin-top : 0 ; } /* .md-typeset blockquote, */ . md-typeset dl , . md-typeset figure , . md-typeset ol , . md-typeset pre , . md-typeset ul { margin-top : 0 ; margin-bottom : 0 ; } 8.11. Tags \u2693\ufe0e Add styles to have a space between tags. . tag { white-space : nowrap ; margin-right : 0.25 em ; } Then the tag cloud should have some indent: . tag-cloud-content { padding : 0 0.6 rem ; margin-bottom : 1 em ; } 8.12. New elements \u2693\ufe0e 8.12.1. New span \u2693\ufe0e Class .ns is used in a new span to clear font-style of the target element, when using attribute list on it. . md-typeset . ns { font-style : unset ; } An example of adding .ns class to an emphasized word: _without new span: italic style_ \\ _with new span: normal style thanks to `.ns` class_ {.ns} without new span: italic style with new span: normal style thanks to .ns class 8.12.2. Row and Column \u2693\ufe0e With Custom Blocks extension, I can make column layout with class .row and .col . Here are the style to make column layout in a row, and set column\u2019s margins: . md-typeset . row { display : flex ; flex-direction : row ; } . md-typeset . row . col { display : flex ; flex-direction : column ; width : 100 % ; margin : 0 0.25 em ; } . md-typeset . row . col : first-of-type { margin-left : 0 ; } . md-typeset . row . col : last-of-type { margin-right : 0 ; } A column will try to fit 100% of the page width. To set a percentage, use the class .wXX for the width of XX% . These classes can be applied to other elements too. And here is an example to create 2 column, a big one is 80% page width: ::: row ::: col w80 style=\"background-color: lightyellow;\" A big column using 80% of page width ::: col w20 style=\"background-color: lightblue;\" A small column A big column using 80% of page width A small column","title":"Customize theme"},{"location":"blog/setup-blog/customize-theme/#1-the-posts-title","text":"By using the Awesome Pages plugin and the Section index plugin, the navigation sidebar can show a good structure of posts. However, each entry is displaying the post\u2019s title with long text, this make the navigation bar look a bit messy. It is easy to add a full title into a post by using the Metadata section . For example: --- title : Customize theme title_full : Customize the theme with personal styles description : A personal website should look different to others ... --- However, the content of each post will also display the short title. To fix this, I am going to override the main template. Before do it, I will add tags in the Metadata section also.","title":"1. The post's title"},{"location":"blog/setup-blog/customize-theme/#2-the-posts-tags","text":"A tag is a word or a phrase that describes one main point of a blog post\u2019s content. They are an easy way to attach labels to the content and link similar posts together. The tags of a post are defined in the Metadata section , then they are gathered and processed in templates later. --- title : title description : description tags : - python - mkdocs ---","title":"2. The post's tags"},{"location":"blog/setup-blog/customize-theme/#3-the-tags-page","text":"The tag page is the place to list all tags, and list all pages that have a common tag. A new page will be created at docs\\tags\\index.md . There is a method to use MkDocs Macros in Markdown template, but it is quite complicated. I use Jinja syntax to create the content of the Tags page, therefore, create a new file at overrides\\tags.html and use it as the template for the Tags page: docs\\tags\\index.md --- title : Tags description : Tags and list of pages template : tags.html hide : - disqus --- # Tags The tags.html template to include 2 parts: tag-cloud.html : make a tag cloud to see how many pages are associated with a tag tag-list-pages.html : for each tag, list all pages having that tag to show similar articles together overrides\\tags.html {% extends \"main.html\" %} {% block page_content %} {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-page-list.html\" %} {% endblock %} Tags will have random colors, to easily disguise them to each other. A helper random_color() macro that returns a random color looks like: overrides\\partials\\random-colors.html {% - macro random_color () - %} {{ - [ \"DarkRed\" , \"DarkGoldenrod\" , \"DarkGreen\" , \"DarkOliveGreen\" , \"DarkCyan\" , \"DarkTurquoise\" , \"DarkBlue\" , \"DarkMagenta\" , \"DarkViolet\" , \"DarkSlateBlue\" , \"DarkOrchid\" , \"DarkSlateGray\" ] | random - }} {% - endmacro - %} Then it can be imported as: {% from \"partials/random-colors.html\" import random_color %}","title":"3. The Tags page"},{"location":"blog/setup-blog/customize-theme/#31-the-tag-cloud","text":"The tag cloud shows all tags in different size and color. The bigger a tag is, the more pages mention that tag. Steps to make a tag cloud: Scan all pages and create a list of pairs (tag, pages[]) {% set tags =[] %} {# scan all pages #} {% for p in pages %} {% if p.page.meta.tags %} {# extract tags if available #} {% for tag in p.page.meta.tags %} {% if tags | length %} {% set ns = namespace ( found = False ) %} {# read more about scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments #} {# check if tag exists, append to its page list #} {% for item in tags %} {% set t , ps = item %} {% if tag == t %} {% set ns.found = True %} {{ ps.append ( p.page ) or \"\" }} {# use (or \"\") to not print} #} {% endif %} {% endfor %} {# if tag doesn't exist, create new page list#} {% if not ns.found %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% else %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% endfor %} {% endif %} {% endfor %} Count the number of pages for each tag then show each tag with different text size and color using font-size and color attributes <p class=\"md-nav\"> <label class=\"md-nav__title\">Tag cloud</label> </p> <div class=\"tag-cloud-content\"> {% if tags | count %} {% for item in tags %} {% set tag , ps = item %} {# create a link with tag name #} {# font size is based on the page count #} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\" font-size: {{ 0.6 + ps | count * 0.1 }} rem; color: {{ random_color () }} ; \"> {{ - tag - }} </span> <sup class=\"tag-count\"> {{ - ps | count - }} </sup> </a> {% endfor %} {% else %} <div> <h3>No tag found!</h3> </div> {% endif %} </div>","title":"3.1. The tag cloud"},{"location":"blog/setup-blog/customize-theme/#32-list-pages-of-a-tag","text":"This section is simple as it just needs to loop through the list of pairs (tag, pages[]) and create a link to each page. Steps to do that: Scan all pages and create a list of pairs (tag, pages[]) see above section Show each tag with the list of pages in a collapsible <details> block <div class=\"tag-page-list\"> {% for item in tags %} {% set tag , ps = item %} <details class=\"note\" id= {{ tag }} > <summary> {{ - tag }} ( {{ - ps | count - }} ) <a class=\"headerlink\" href=\"# {{ tag }} \">\u2693\ufe0e</a> </summary> <ol> {% for p in ps %} <li> <a href=\" {{ page.canonical_url }} \"> {% - if p.meta and p.meta.title_full - %} {{ - p.meta.title_full - }} {% - elif p.meta and p.meta.title - %} {{ - p.meta.title - }} {% - else - %} {{ - p.title - }} ` {% - endif - %} </a> </li> {% endfor %} </ol> </details> {% endfor %} </div> Only one tag block is open at a time to easily follow the selected tag. To do this, I added a callback of the toggle event on all tag blocks. Whenever a block is opened, this script will close all others [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false ; D . addEventListener ( \"toggle\" , ( E ) => D . open && A . forEach (( d ) => d != E . target && ( d . open = false )) ); }); A tag block can be opened via URL with hash being the selected tag var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } Visit the Tags to see the result.","title":"3.2. List pages of a tag"},{"location":"blog/setup-blog/customize-theme/#4-the-recent-blog-posts","text":"There should be a page showing the recent posts to help users see what is new and updated. With the Revision Date plugin, it is able to use two new meta-dat fields: git_revision_date_localized , and git_creation_date_localized if the option enable_creation_date is true . Create new index.md file inside the blog folder. When using the Section Index plugin, this index file will be merged to the Blog section, therefore, when user select the Blog label, there is a list of recent posts will be shown. This page will use the blog.html template in which it scans all posts and check the creation date to make a list of posts. Each post should be displayed in a container and be formatted to show the title, the description (at most 250 character using the truncate filter), the creation date, and its tags. Need to check the page\u2019s path to filter blog posts. In my code, I use the abs_url and its length to check if a page is in the blog directory. Here is the code to sort all pages in order of creation date, and then filter all blog posts to save into the array blog_pages which will be used to generate content. {% set blog_pages =[] %} {% for p in pages | sort ( attribute = 'page.meta.git_creation_date_localized' , reverse = True ) %} {% set pg = p.page %} {% if pg.abs_url.startswith ( '/blog/' ) and pg.abs_url | length > 6 %} {{ blog_pages.append ( pg ) or \"\" }} {% endif %} {% endfor %} <div class=\"pages\"> ... create list from blog_pages ... </div>","title":"4. The recent blog posts"},{"location":"blog/setup-blog/customize-theme/#41-create-the-pagination","text":"When the number of posts goes bigger, the recent post list becomes longer. It\u2019s time to brake the long list into pages - the user can click on the page number to see its children posts. This is called \u201cPagination\u201d. How to implement it? Jinja template has the slice filter to divide a list into sub-lists. Here, I\u2019d like to have maximum of 10 posts on each page. <div class=\"pages\"> {% for pg_group in blog_pages | slice (( blog_pages | count / 10 )| int ) %} <div class=\"page\" id=\"page {{ loop .index }} \"> {% for pg in pg_group %} <div class=\"post\"> ... create post layout and content ... </div> {% endfor %} </div> {% endfor %} </div>","title":"4.1. Create the pagination"},{"location":"blog/setup-blog/customize-theme/#42-create-a-post-entry","text":"Each post is wrapped inside a < div class = \"post\" > and its elements are marked with different classes, such as post-title , post-description , etc. for applying styles later. <div class=\"post\"> <h3 class=\"post-title\"> <a class=\"link\" href=\" {{ pg.canonical_url }} \"> {{ title }} </a> </h3> <p class=\"post-description\"> {% if pg.meta.description %} {{ pg.meta.description | truncate }} {% endif %} </p> <div class=\"post-extra\"> <span class=\"post-timestamp\"> {% if pg.meta and pg.meta.git_revision_date_localized %} <span class=\"post-timestamp-update\"> Updated: {{ pg.meta.git_revision_date_localized - }} </span> {% endif %} </span> <span class=\"post-tags\"> {% if pg.meta.tags %} {% for tag in pg.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} {% endif %} </span> </div> <hr /> </div> Here is a simple styles to make each post display necessary basic information: . md-typeset . post : first-of-type h3 { margin-top : 0 ; } . md-typeset . post-title { margin-bottom : 0 ; } . md-typeset . post-extra { color : gray ; } . md-typeset . post-tags { float : right ; }","title":"4.2. Create a post entry"},{"location":"blog/setup-blog/customize-theme/#43-create-active-page","text":"To show the current active page, I use pure css and javascript. The idea is to use the URL hash to detect which page is activated, such as #page1 . <div class=\"center\"> <div class=\"pagination\" id=\"pagination\"> <a href=\"#\">&laquo;</a> {% for pg_group in blog_pages | slice (( blog_pages | count / 10 )| int ) %} <a class=\"page-number {% if loop .index == 1 %} active {% endif %} \" href=\"#page {{ loop .index }} \"> {{ loop .index }} </a> {% endfor %} <a href=\"#\">&raquo;</a> </div> </div> Then add some styles to the pagination block and its children links: CSS Styles : Use target keyword to select the selected page id , then show only the target element. assets\\extra.css . md-typeset . pages > . page : target ~ . page : last-child , . md-typeset . pages > . page { display : none ; } . md-typeset . pages > : last-child , . md-typeset . pages > . page : target { display : block ; } Javascript When the page is loaded, a script will run to get all pagination\u2019s links, and then add a callback function for click event, that remove active class from last activated element and then assign active class to the event\u2019s source element. Note that the first page is activated by default when the page is loaded. assets\\extra.js var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); }","title":"4.3. Create active page"},{"location":"blog/setup-blog/customize-theme/#5-the-main-template","text":"The main.html file, extending the base.html template, will be used for all markdown pages and it is the starting point to add custom template. To override it, add the main.html file in the overrides folder. Here are things I\u2019m going to do to add more content into a blog post: Extract metadata to get title , title_full , description , tags , and other information {% set title = config.site_name %} {% if page and page.meta and page.meta.title_full %} {% set title = page.meta.title_full %} {% elif page and page.meta and page.meta.title %} {% set title = page.meta.title %} {% elif page and page.title %} {% set title = page.title %} {% endif %} {% set description = config.site_description %} {% if page and page.meta and page.meta.description %} {% set description = page.meta.description %} {% endif %} {% if page and page.meta and page.meta.banner %} {% set image = page.meta.banner %} {% endif %} {% if page and page.meta and page.meta.tags %} {% set tags = page.meta.tags %} {% endif %} Add block to use the Open Graph protocol to show the page\u2019s information when an user shares a page on a social network {% block htmltitle %} <title> {{ title | striptags }} - {{ config.site_name }} </title> {% endblock %} {% block extrahead %} <meta property=\"og:type\" content=\"website\" /> <meta property=\"og:title\" content=\" {{ - title | striptags ~ ' - ' ~ config.site_name - }} \"/> <meta property=\"og:description\" content=\" {{ description }} \" /> <meta property=\"og:url\" content=\" {{ page.canonical_url }} \" /> <meta property=\"og:image\" content=\" {% - if image is defined - %} {{ page.canonical_url ~ image }} {% - else - %} {{ config.site_url ~ 'assets/banner.jpg' }} {% - endif - %} \" /> <meta property=\"og:site_name\" content=\" {{ config.site_name }} \" /> <meta name=\"twitter:card\" content=\"summary\" /> {% endblock %} The page content should have a cover section which displays the title , description and tags on all pages, except the home page. {% block content %} {% if not page.is_homepage %} <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} </div> {% endif %} {{ page.content }} {% endblock %} The tag cloud should show in the sidebars based on the page\u2019s width {% block site_nav %} {% if nav %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"navigation\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--primary\" data-md-component=\"sidebar\" data-md-type=\"navigation\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/nav.html\" %} <div class=\"tag-cloud-nav\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% if page.toc and not \"toc.integrate\" in features %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"toc\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--secondary\" data-md-component=\"sidebar\" data-md-type=\"toc\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/toc.html\" %} <div class=\"tag-cloud-toc\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% endblock %}","title":"5. The main template"},{"location":"blog/setup-blog/customize-theme/#6-zoom-in-images","text":"As mentioned in the Images section, view-bigimg library helps to zoom and pan images. It\u2019s useful when the image is in high resolution and resized to fit site\u2019s width. Download view-bigimg.css and view-bigimg.js files from the view-bigimg repo, then add them into the addition assets configs in mkdocs.yml : mkdocs.yml extra_css : - assets/view-bigimg.css extra_javascript : - assets/view-bigimg.js When click on the image, this library will create a new layer and show the image in a bigger size. However, it must be clicked on the close button to go back to the page\u2019s content. I want to simplify this step by just click on the image. Panning still is activated by press and hold. Therefore, I write a function to detect mousedown and mousemove event, then only close the image if it is a simple click: assets\\extra.js var dragged = false ; document . addEventListener ( \"mousedown\" , () => ( dragged = false )); document . addEventListener ( \"mousemove\" , () => ( dragged = true )); var viewer = new ViewBigimg (); var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; }","title":"6. Zoom-in Images"},{"location":"blog/setup-blog/customize-theme/#7-open-external-links","text":"When following links, to remain the blog page opened, external links should be shown in new tabs without any tracking information. To do that, I write some lines of code to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" to them. assets\\extra.js /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } }","title":"7. Open external links"},{"location":"blog/setup-blog/customize-theme/#8-custom-styles","text":"After all extensions and plugins are installed, some extra pages and elements are added, this is the time to tweak the whole site\u2019s styles.","title":"8. Custom styles"},{"location":"blog/setup-blog/customize-theme/#81-colors","text":"Here are some small additional styles to make the theme look a bit harmonious with the selected theme color Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } The highlight color should not be too yellowish, I\u2019d like to reduce its opacity: : root > * { --md-code-hl-color : rgba ( 255 , 255 , 0 , 0.1 ); --md-typeset-mark-color : var ( --md-code-hl-color ); }","title":"8.1. Colors"},{"location":"blog/setup-blog/customize-theme/#82-admonition","text":"I want to make admonitions look more harmonious to the theme, so I decided to remove border and shadow box, then add a light background color which is the title background color of each type. The font and the margin also need modified a bit to make admonitions look consistent to the main content. First, icon should be bigger: . md-typeset . admonition-title : before , . md-typeset summary : before { height : 1.2 rem ; width : 1.2 rem ; } Remove border, shadow box, and increase font size: . md-typeset . admonition , . md-typeset details { border : none ; box-shadow : none ; font-size : 0.95 em ; margin-top : 0 ; } Remove background color in the title, step it back to the right, due to the increased icon size: . md-typeset . admonition > . admonition-title , . md-typeset details > summary { background-color : transparent !important ; border-left : 0.2 rem solid transparent !important ; padding-left : 3 em ; } Fill background color for different admonition types: . md-typeset . admonition . note , . md-typeset details . note { background-color : rgba ( 68 , 138 , 255 , 0.05 ); } . md-typeset . admonition . abstract , . md-typeset . admonition . summary , . md-typeset . admonition . tldr , . md-typeset details . abstract , . md-typeset details . summary , . md-typeset details . tldr { background-color : rgba ( 0 , 176 , 255 , 0.05 ); } . md-typeset . admonition . info , . md-typeset . admonition . todo , . md-typeset details . info , . md-typeset details . todo { background-color : rgba ( 0 , 184 , 212 , 0.05 ); } . md-typeset . admonition . hint , . md-typeset . admonition . important , . md-typeset . admonition . tip , . md-typeset details . hint , . md-typeset details . important , . md-typeset details . tip { background-color : rgba ( 0 , 191 , 165 , 0.05 ); } . md-typeset . admonition . check , . md-typeset . admonition . done , . md-typeset . admonition . success , . md-typeset details . check , . md-typeset details . done , . md-typeset details . success { background-color : rgba ( 0 , 200 , 83 , 0.05 ); } . md-typeset . admonition . faq , . md-typeset . admonition . help , . md-typeset . admonition . question , . md-typeset details . faq , . md-typeset details . help , . md-typeset details . question { background-color : rgba ( 100 , 221 , 23 , 0.05 ); } . md-typeset . admonition . attention , . md-typeset . admonition . caution , . md-typeset . admonition . warning , . md-typeset details . attention , . md-typeset details . caution , . md-typeset details . warning { background-color : rgba ( 255 , 145 , 0 , 0.05 ); } . md-typeset . admonition . fail , . md-typeset . admonition . failure , . md-typeset . admonition . missing , . md-typeset details . fail , . md-typeset details . failure , . md-typeset details . missing { background-color : rgba ( 255 , 82 , 82 , 0.05 ); } . md-typeset . admonition . danger , . md-typeset . admonition . error , . md-typeset details . danger , . md-typeset details . error { background-color : rgba ( 255 , 23 , 68 , 0.05 ); } . md-typeset . admonition . bug , . md-typeset details . bug { background-color : rgba ( 245 , 0 , 87 , 0.05 ); } . md-typeset . admonition . example , . md-typeset details . example { background-color : rgba ( 124 , 77 , 255 , 0.05 ); } . md-typeset . admonition . cite , . md-typeset . admonition . quote , . md-typeset details . cite , . md-typeset details . quote { background-color : hsla ( 0 , 0 % , 62 % , 0.05 ); } Make the content close to the title a bit: . md-typeset . admonition > . admonition-title + *, . md-typeset details > summary + * { margin-top : 0 ; } Change admonition style And tweak the style to show admonitions which has icon but do not have title. The trick is to add left padding to the first letter in the content paragraph , and move the content up by applying a negative top margin: . md-typeset . admonition . nt > . admonition-title + p :: first-letter , . md-typeset details . nt > summary + p :: first-letter { padding-left : 2.2 em ; } . md-typeset . admonition . nt > . admonition-title + *, . md-typeset details . nt > summary + * { margin-top : -2.1 em ; } Use these additional styles, with .nt class and an empty title (use \"&nbsp;\" or \"\\ \" ): !!! info nt \"\\ \" This admonition has an icon as an inline element with the content !!! info Default title !!! info \"New title\" Content of the admonition is indented !!! info \"\" There is no title and no icon This admonition has an icon as an inline element with the content Info Default title New title Content of the admonition There is no title and no icon","title":"8.2. Admonition"},{"location":"blog/setup-blog/customize-theme/#83-quotes","text":"Quote is used to provide additional data, so I changed its style a bit to not make it confusing with the main text. . md-typeset blockquote { color : unset ; border-left-width : 2 px ; opacity : 0.7 ; } . md-typeset blockquote : first-child { margin-top : 0.25 em ; } . md-typeset blockquote : last-child { margin-bottom : 0.25 em ; } Admonition also has quote and cite type which are used as cited content.","title":"8.3. Quotes"},{"location":"blog/setup-blog/customize-theme/#84-code-block","text":"It is better to show the line number inline with its line of code: markdown_extensions : - meta - pymdownx.superfences - pymdownx.highlight : linenums_style : pymdownx-inline And then increase the font size to get make them easy to read: . md-typeset code , . md-typeset kbd { font-size : 1 em ; word-break : keep-all !important ; } . md-typeset pre code { white-space : pre-wrap ; font-size : 0.9 em ; } Then the line number should be dimmed to not distract the main code: . md-typeset . highlight [ data-linenos ] : before { background-color : transparent ; box-shadow : none ; color : lightgray ; } #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; }","title":"8.4. Code block"},{"location":"blog/setup-blog/customize-theme/#85-tables","text":"Table should show cell border and use full width to make the content clear. . md-typeset__scrollwrap { margin : unset ; } . md-typeset__table { padding : 0 ; display : block ; } . md-typeset table : not ([ class ]) { font-size : 0.9 em ; box-shadow : none ; display : table ; border-collapse : collapse ; } . md-typeset table : not ([ class ]) th , . md-typeset table : not ([ class ]) td { padding : 0.5 em ; border : 1 px solid #f0f0f0 ; min-width : unset ; } Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts","title":"8.5. Tables"},{"location":"blog/setup-blog/customize-theme/#86-tabs","text":"Tab\u2019s content should show some intent to visualize its structure. The label is tweaked a bit to look consisted with its content at the left margin. Note that in printing, all tabs will be expanded to show all of its content. . md-typeset . tabbed-content { box-shadow : none ; border-top : 1 px solid var ( --md-default-fg-color--lightest ); } . md-typeset . tabbed-content > . tabbed-set { padding-left : 2 em ; } . md-typeset . tabbed-set > label { font-size : 0.9 em ; padding : 0 margin-right : 1.25 em ; } Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts","title":"8.6. Tabs"},{"location":"blog/setup-blog/customize-theme/#87-buttons","text":"When using white primary color, the default button class md-button has issues to display correctly. Here are the fix for those buttons: change the margin to make them smaller change the border, and text color change the size of the icon . md-typeset . md-button { font-size : small ; font-weight : unset ; padding : 0.25 em 0.5 em ; border : 1 px solid ; color : orangered ; } . md-typeset . md-button . twemoji { font-size : large ; } Click here","title":"8.7. Buttons"},{"location":"blog/setup-blog/customize-theme/#88-image-caption","text":"The caption should not have restricted width, and its bottom margin should be smaller. . md-typeset figcaption { max-width : unset ; margin : 1 em auto ; } A photo from https://picsum.photos","title":"8.8. Image caption"},{"location":"blog/setup-blog/customize-theme/#89-sidebar-scrolls","text":"Only show the scrollbar when hovering to make sidebar look clear. . md-sidebar__scrollwrap { overflow : hidden ; } . md-sidebar__scrollwrap : hover { overflow-y : auto ; }","title":"8.9. Sidebar scrolls"},{"location":"blog/setup-blog/customize-theme/#810-spaces","text":"This part modifies some small space gap and margins to make the overall layout look better. Remove some space gaps. . md-main__inner { margin-top : 0 ; } md-typeset dd { margin : 0 em 0 1 em 1.875 em ; } . md-typeset dd > * { margin-top : 0 ; } . md-typeset p : empty { display : none ; } . md-typeset . admonition + *, . md-typeset details + * { margin-top : 0 ; } /* .md-typeset blockquote, */ . md-typeset dl , . md-typeset figure , . md-typeset ol , . md-typeset pre , . md-typeset ul { margin-top : 0 ; margin-bottom : 0 ; }","title":"8.10. Spaces"},{"location":"blog/setup-blog/customize-theme/#811-tags","text":"Add styles to have a space between tags. . tag { white-space : nowrap ; margin-right : 0.25 em ; } Then the tag cloud should have some indent: . tag-cloud-content { padding : 0 0.6 rem ; margin-bottom : 1 em ; }","title":"8.11. Tags"},{"location":"blog/setup-blog/customize-theme/#812-new-elements","text":"","title":"8.12. New elements"},{"location":"blog/setup-blog/customize-theme/#8121-new-span","text":"Class .ns is used in a new span to clear font-style of the target element, when using attribute list on it. . md-typeset . ns { font-style : unset ; } An example of adding .ns class to an emphasized word: _without new span: italic style_ \\ _with new span: normal style thanks to `.ns` class_ {.ns} without new span: italic style with new span: normal style thanks to .ns class","title":"8.12.1. New span"},{"location":"blog/setup-blog/customize-theme/#8122-row-and-column","text":"With Custom Blocks extension, I can make column layout with class .row and .col . Here are the style to make column layout in a row, and set column\u2019s margins: . md-typeset . row { display : flex ; flex-direction : row ; } . md-typeset . row . col { display : flex ; flex-direction : column ; width : 100 % ; margin : 0 0.25 em ; } . md-typeset . row . col : first-of-type { margin-left : 0 ; } . md-typeset . row . col : last-of-type { margin-right : 0 ; } A column will try to fit 100% of the page width. To set a percentage, use the class .wXX for the width of XX% . These classes can be applied to other elements too. And here is an example to create 2 column, a big one is 80% page width: ::: row ::: col w80 style=\"background-color: lightyellow;\" A big column using 80% of page width ::: col w20 style=\"background-color: lightblue;\" A small column A big column using 80% of page width A small column","title":"8.12.2. Row and Column"},{"location":"blog/setup-blog/fix-ajax-issue/","text":"1. Instant loading \u2693\ufe0e As mentioned in the Material for Mkdocs guide, this theme supports Instant Loading feature which intercepts internal links and load content via XHR request without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. However, using XHR in an AJAX site leads to a problem. Dynamic Javascript-enabled elements do not work after AJAX content is loaded. After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. Here are problems I get after click in an internal link: Zoom-in Images function does not work External links is not opened in a new tab Disqus section does not load new thread comments The solution is to detect internal navigation, and then re-register all dynamic elements. 2. Detect internal navigation \u2693\ufe0e When the site fetches new page content, it will change the URL location too, therefore there are some methods to detect an internal navigation: Detect URL change: A while loop to check if URL is changed every 1s, or A handler that listens to browser history change Detect content change: Observe an element and detect its content is changed 2.1. Detect URL change \u2693\ufe0e Here is a fix using URL detection approach, but the handler will be called multiple time causing bad performance, e.g. when a page has a lot of images. This method redefines the handler which calls the old handler ( f in lambda) and fires new events using window.dispatchEvent function: assets\\extra.js function reactivateElements () { /* do something here */ } history . pushState = (( f ) => function pushState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"pushstate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . pushState ); history . replaceState = (( f ) => function replaceState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"replacestate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . replaceState ); window . addEventListener ( \"popstate\" , () => { window . dispatchEvent ( new Event ( \"locationchange\" )); }); window . addEventListener ( \"locationchange\" , () => { // can check actual change of URL but the content may not loaded console . log ( \"locationchange\" ); reactivateElements (); }); 2.2. Detect content change \u2693\ufe0e Another method uses an observer to watch the <HEAD> tag, because whenever a new page is loaded, the title and page\u2019s information will be changed inside the <HEAD> tag. Just need to monitor the children state of this tag. assets\\extra.js var currentLocation = document . location . href ; function reactivateElements () { /* do something here */ } const observer = new MutationObserver (() => { if ( currentLocation !== document . location . href ) { console . log ( \"URL changed!\" ); currentLocation = document . location . href ; reactivateElements (); } }); observer . observe ( document . getElementsByTagName ( \"HEAD\" )[ 0 ], { childList : true }); I chose this method. 3. Activate dynamic elements \u2693\ufe0e This step is to wrap all actions that need to be run: when the page is fully loaded at the first time; and when the content of the page is loaded after an XHR request 3.1. Re-direct external links \u2693\ufe0e External link should be shown in a new tab, without any tracking information. To do that, I write a function to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" . assets\\extra.js function activateExternalLinks () { /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } } Finally add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); } 3.2. Re-register images \u2693\ufe0e Firstly, wrap the handler in a function which will be re-called. Note that, ViewBigimg object will be created once as a constant object. assets\\extra.js var viewer = new ViewBigimg (); function activateBigImg () { /* enable zoom-in */ var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } /* click to close zoomed image */ var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } } Then add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); activateBigImg (); } 3.3. Re-register pagination links \u2693\ufe0e Do the same step as described above to make a wrapped function to add into the re-activation chain: assets\\extra.js function activatePaginationLinks () { var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } } function reactivateElements () { activateExternalLinks (); activateBigImg (); activatePaginationLinks (); } 3.4. Re-enable Disqus \u2693\ufe0e Disqus can not see the URL changed by itself, and it provides an API to reset the Disqus section. There is a guide on Using Disqus on AJAX sites showing a snippet to reload Disqus thread: DISQUS . reset ({ reload : true , config : function () { this . page . identifier = \"newidentifier\" ; this . page . url = \"http://example.com/#!newthread\" ; }, }); Checking the template of Material in partials\\integrations\\disqus.html , it gets page id and page url using jinja template: <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script> var disqus_config = function() { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\",function() { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head||e.body).appendChild(i) }); </script> Therefore, I can get those information in the same way by adding two <div> with data being the page id and page url in the main.html template: main.html {{ page.content }} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> Then, I created a function to reset Disqus which extracts page id and page url from above elements, and call to DISQUS.reset() : assets\\extra.js function resetDisqusPlugin () { var page_url = document . getElementById ( \"page_url\" ); var page_identifier = document . getElementById ( \"page_identifier\" ); if ( page_url && page_identifier ) { page_url = page_url . dataset . value + \"#!newthread\" ; console . log ( page_url ); page_identifier = page_identifier . dataset . value ; console . log ( page_identifier ); try { DISQUS_RECOMMENDATIONS . reset (); DISQUS . reset ({ reload : true , config : function () { this . page . identifier = page_identifier ; this . page . url = page_url ; }, }); } catch ( e ) { console . log ( e ); } } } However, there is still a problem: Disqus is not initialized in some pages The Disqus section is controlled by: setting in mkdocs.yml file the page.is_homepage variable the field disqus in page\u2019s meta-data If an user visits the first page with no disqus activated, the next page even with disqus included still fails to load disqus as the script //{{ disqus }}.disqus.com/embed.js is not loaded. The solution is enable disqus on all pages, then hide the section on some specific pages. How to do it? Here are steps: Remove default Disqus block by extending it with empty content: {% block disqus %} {% endblock %} Wrap the page content inside a new block page_content : {% block page_content %} ... {{ page.content }} {% endblock %} Append the customized Disqus block after the page_content : {% block content %} {% block page_content %} ... {{ page.content }} {% endblock %} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> {% set disqus = config.extra.disqus %} {% if disqus %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"disqus\" in page.meta.hide %} {% endif %} <div {{ hidden }} > {% set disqus = config.extra.disqus %} <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script>var disqus_config = function () { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\", function () { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head || e.body).appendChild(i) })</script> </div> {% endif %} {% endblock %} {% block disqus %} {% endblock %} All other templates which extends the main.html template have to extend the page_content block, not the content block. Finally, in the page where I don\u2019t want to see disqus section, just add disqus to the hide attribute in the meta-data section: --- title: Recent updated posts description: Latest news and recent posts template: blog.html hide: - disqus ---","title":"Fix AJAX issue"},{"location":"blog/setup-blog/fix-ajax-issue/#1-instant-loading","text":"As mentioned in the Material for Mkdocs guide, this theme supports Instant Loading feature which intercepts internal links and load content via XHR request without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. However, using XHR in an AJAX site leads to a problem. Dynamic Javascript-enabled elements do not work after AJAX content is loaded. After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. Here are problems I get after click in an internal link: Zoom-in Images function does not work External links is not opened in a new tab Disqus section does not load new thread comments The solution is to detect internal navigation, and then re-register all dynamic elements.","title":"1. Instant loading"},{"location":"blog/setup-blog/fix-ajax-issue/#2-detect-internal-navigation","text":"When the site fetches new page content, it will change the URL location too, therefore there are some methods to detect an internal navigation: Detect URL change: A while loop to check if URL is changed every 1s, or A handler that listens to browser history change Detect content change: Observe an element and detect its content is changed","title":"2. Detect internal navigation"},{"location":"blog/setup-blog/fix-ajax-issue/#21-detect-url-change","text":"Here is a fix using URL detection approach, but the handler will be called multiple time causing bad performance, e.g. when a page has a lot of images. This method redefines the handler which calls the old handler ( f in lambda) and fires new events using window.dispatchEvent function: assets\\extra.js function reactivateElements () { /* do something here */ } history . pushState = (( f ) => function pushState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"pushstate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . pushState ); history . replaceState = (( f ) => function replaceState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"replacestate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . replaceState ); window . addEventListener ( \"popstate\" , () => { window . dispatchEvent ( new Event ( \"locationchange\" )); }); window . addEventListener ( \"locationchange\" , () => { // can check actual change of URL but the content may not loaded console . log ( \"locationchange\" ); reactivateElements (); });","title":"2.1. Detect URL change"},{"location":"blog/setup-blog/fix-ajax-issue/#22-detect-content-change","text":"Another method uses an observer to watch the <HEAD> tag, because whenever a new page is loaded, the title and page\u2019s information will be changed inside the <HEAD> tag. Just need to monitor the children state of this tag. assets\\extra.js var currentLocation = document . location . href ; function reactivateElements () { /* do something here */ } const observer = new MutationObserver (() => { if ( currentLocation !== document . location . href ) { console . log ( \"URL changed!\" ); currentLocation = document . location . href ; reactivateElements (); } }); observer . observe ( document . getElementsByTagName ( \"HEAD\" )[ 0 ], { childList : true }); I chose this method.","title":"2.2. Detect content change"},{"location":"blog/setup-blog/fix-ajax-issue/#3-activate-dynamic-elements","text":"This step is to wrap all actions that need to be run: when the page is fully loaded at the first time; and when the content of the page is loaded after an XHR request","title":"3. Activate dynamic elements"},{"location":"blog/setup-blog/fix-ajax-issue/#31-re-direct-external-links","text":"External link should be shown in a new tab, without any tracking information. To do that, I write a function to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" . assets\\extra.js function activateExternalLinks () { /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } } Finally add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); }","title":"3.1. Re-direct external links"},{"location":"blog/setup-blog/fix-ajax-issue/#32-re-register-images","text":"Firstly, wrap the handler in a function which will be re-called. Note that, ViewBigimg object will be created once as a constant object. assets\\extra.js var viewer = new ViewBigimg (); function activateBigImg () { /* enable zoom-in */ var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } /* click to close zoomed image */ var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } } Then add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); activateBigImg (); }","title":"3.2. Re-register images"},{"location":"blog/setup-blog/fix-ajax-issue/#33-re-register-pagination-links","text":"Do the same step as described above to make a wrapped function to add into the re-activation chain: assets\\extra.js function activatePaginationLinks () { var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } } function reactivateElements () { activateExternalLinks (); activateBigImg (); activatePaginationLinks (); }","title":"3.3. Re-register pagination links"},{"location":"blog/setup-blog/fix-ajax-issue/#34-re-enable-disqus","text":"Disqus can not see the URL changed by itself, and it provides an API to reset the Disqus section. There is a guide on Using Disqus on AJAX sites showing a snippet to reload Disqus thread: DISQUS . reset ({ reload : true , config : function () { this . page . identifier = \"newidentifier\" ; this . page . url = \"http://example.com/#!newthread\" ; }, }); Checking the template of Material in partials\\integrations\\disqus.html , it gets page id and page url using jinja template: <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script> var disqus_config = function() { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\",function() { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head||e.body).appendChild(i) }); </script> Therefore, I can get those information in the same way by adding two <div> with data being the page id and page url in the main.html template: main.html {{ page.content }} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> Then, I created a function to reset Disqus which extracts page id and page url from above elements, and call to DISQUS.reset() : assets\\extra.js function resetDisqusPlugin () { var page_url = document . getElementById ( \"page_url\" ); var page_identifier = document . getElementById ( \"page_identifier\" ); if ( page_url && page_identifier ) { page_url = page_url . dataset . value + \"#!newthread\" ; console . log ( page_url ); page_identifier = page_identifier . dataset . value ; console . log ( page_identifier ); try { DISQUS_RECOMMENDATIONS . reset (); DISQUS . reset ({ reload : true , config : function () { this . page . identifier = page_identifier ; this . page . url = page_url ; }, }); } catch ( e ) { console . log ( e ); } } } However, there is still a problem: Disqus is not initialized in some pages The Disqus section is controlled by: setting in mkdocs.yml file the page.is_homepage variable the field disqus in page\u2019s meta-data If an user visits the first page with no disqus activated, the next page even with disqus included still fails to load disqus as the script //{{ disqus }}.disqus.com/embed.js is not loaded. The solution is enable disqus on all pages, then hide the section on some specific pages. How to do it? Here are steps: Remove default Disqus block by extending it with empty content: {% block disqus %} {% endblock %} Wrap the page content inside a new block page_content : {% block page_content %} ... {{ page.content }} {% endblock %} Append the customized Disqus block after the page_content : {% block content %} {% block page_content %} ... {{ page.content }} {% endblock %} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> {% set disqus = config.extra.disqus %} {% if disqus %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"disqus\" in page.meta.hide %} {% endif %} <div {{ hidden }} > {% set disqus = config.extra.disqus %} <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script>var disqus_config = function () { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\", function () { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head || e.body).appendChild(i) })</script> </div> {% endif %} {% endblock %} {% block disqus %} {% endblock %} All other templates which extends the main.html template have to extend the page_content block, not the content block. Finally, in the page where I don\u2019t want to see disqus section, just add disqus to the hide attribute in the meta-data section: --- title: Recent updated posts description: Latest news and recent posts template: blog.html hide: - disqus ---","title":"3.4. Re-enable Disqus"},{"location":"blog/setup-blog/markdown-syntax/","text":"For basic markdown syntax, refer to Markdown Guide . 1. Meta-data \u2693\ufe0e The Meta-Data extension adds a syntax for defining meta-data of a document. It is inspired by and follows the syntax of MultiMarkdown . Meta-data is the additional information that can be used to briefly describe the content of a post, such as the title, the short description, tags, and sometimes the banner image. Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a markdown document like this: title : The page title description : The summary of the page content Alternatively, meta-data can be written in YAML style, using two triple-dash --- tags to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content --- The metadata can be used in the template and the page content 1 . In jinja syntax, each page is represented as a page object, then the meta-data field {{ page.meta.title }} will be replaced by the string The page title . MkDocs uses the title of each post to show in the navigation sidebar. In case the title is long, it can make the side look a bit messy. A solution is to use a short title on navigation , and a long title on the post. Read more in Customize theme . 2. Code blocks \u2693\ufe0e The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The standard format which supports to add id , class or custom key=value is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in a simple syntax: ```language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y-th to z-th . Line numbers are always referenced starting at 1 ignoring what the line number is started labeling at the number set by the option linenums = \"n\" . Example: ```cpp linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } Some styles will be added to the code blocks to make it look a bit bigger and wrap long lines. Read more in Customize theme . 3. Inline code \u2693\ufe0e The InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite\u2019s existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language my code` or `#!language my code` . This will render this line `#!python [x for x in range(1, 10) if x % 2]` to a fully colored inline Python code: [ x for x in range ( 1 , 10 ) if x % 2 ] . 4. Admonition \u2693\ufe0e The Admonition extension adds rST-style admonitions to Markdown documents. This block displays its content in a block, with or without a title. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax. The title is optional, use an empty string to remove the title: .md-typeset .admonition.type, .md-typeset details.type { background-color: rgba(68, 138, 255, 0.05); } !!! type \"Title\" Content of the admonition is indented !!! type \"\" There is no title Title Content of the admonition is indented There is no title Other types note, seealso Content of the admonition is indented abstract, summary, tldr Content of the admonition is indented info, todo Content of the admonition is indented tip, hint, important Content of the admonition is indented success, check, done Content of the admonition is indented question, help, faq Content of the admonition is indented warning, caution, attention Content of the admonition is indented failure, fail, missing Content of the admonition is indented danger, error Content of the admonition is indented bug Content of the admonition is indented example Content of the admonition is indented quote, cite Content of the admonition is indented With some additional styles, it is possible to create an admonition without title but still has icon, by using .nt class and an empty title (use \"&nbsp;\" , or \"\\ \" if Escape All extension is used). Read more in Customize theme . !!! info nt \"&nbsp;\" This admonition has icon as an inline element with the content This admonition has icon as an inline element with the content 5. Attribute list \u2693\ufe0e The Attribute Lists extension adds a syntax to add attributes on the various HTML elements in markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example of using attribute list might look like this: { #id .class key='value' } 5.1. Block attribute \u2693\ufe0e To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. This is a paragraph colored in **teal** by using a block attribute. {style=\"color: teal;\"} This is a paragraph colored in teal by using a block attribute. 5.2. Element attribute \u2693\ufe0e To define attributes on inline elements, the attribute list should be defined immediately after an inline element generated by markdown with no white space. This is a _green_ {style=\"color:green\"} word.\\ This is a <span>non-markdown span</span>{style=\"color:green\"} word therefore the attribute is not parsed. This is a green word. This is a non-markdown span {style=\u201dcolor:green\u201d} word therefore the attribute is not parsed. 6. Lists \u2693\ufe0e Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist : custom_checkbox : true - def_list - sane_lists Some styles need to be added to show lists in a better view. Read more in Customize theme . 6.1. Ordered list \u2693\ufe0e 1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2 6.2. Unordered list \u2693\ufe0e - Unordered item 1 - Child 1 - Child 2 - Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2 6.3. Task list \u2693\ufe0e - [x] item 1 - [x] item a - [ ] item b - [ ] item 2 item 1 item a item b item 2 6.4. Definition \u2693\ufe0e Roses : are red Violets : are blue Roses are red Violets are blue 6.5. Sane list \u2693\ufe0e 1. Ordered item 1 2. Ordered item 2 - Unordered item 1 - Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2 7. Images \u2693\ufe0e There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses the alternate text to make caption, accepts markdown in the alternate text. Install the extension: pip install -U markdown-captions then enable it in the config file: markdown_extensions : - markdown_captions Some images have big size that does not show the detail, therefore, it\u2019s better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library can do that requirement well. Read more in Customize theme to learn how to enable that library. ![ A photo from <https://picsum.photos> ]( https://picsum.photos/320/240 ) A photo from https://picsum.photos 8. Tabs \u2693\ufe0e Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab A\" Text A === \"Tab B\" Text B === \"Tab 2\" Some other texts Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts Styles for tabs need to change a little bit to have left margin in tab\u2019s content. Read more in Customize theme . 9. Tables \u2693\ufe0e The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. Styles for table need to change a little bit to show cell border. Read more in Customize theme . | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | Some texts | Some texts | Some texts | Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts 10. Formatting \u2693\ufe0e Some texts may have special formats, and here are extensions that can help to add some styles. 10.1. Caret \u2693\ufe0e Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert^^ the energy E=mc^2^ Insert the energy E=mc 2 10.2. Mark \u2693\ufe0e Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== and ==mark==me==all== mark me and mark==me==all 10.3. Tildes \u2693\ufe0e Tildes optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete~~ the existence of CH~3~CH~2~OH Delete the existence of CH 3 CH 2 OH 10.4. Critic \u2693\ufe0e Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text, use {\u200b++insert me++} and {\u200b--remove me--}.\\ Denote a substitution with {\u200b~~substitute this~>with this~~}. Highlight specific text with {\u200b==highlight me==}.\\ Or even add {\u200b>>a comment<<}. To insert or remove text, use insert me and remove me . Denote a substitution with substitute this with this . Highlight specific text with highlight me . Or even add a comment . 11. HTML block \u2693\ufe0e The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With the this extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed word__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed word__ by Markdown. This is a bold word parsed by Markdown. 12. Icons & Emojis \u2693\ufe0e The Emoji extension adds support for inserting emoji via simple short names enclosed within colons :short_name: . This is accomplished by using a short name index to map easy-to-remember names to the corresponding emoji characters. Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg 12.1. Emojis \u2693\ufe0e Emojis can be written by putting the short-code of the emoji between two colons. Look up the short-codes at Emojipedia . :smile: :heart: 12.2. Icons \u2693\ufe0e Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - . For example: The short-code :material-account-circle: will be converted to an svg image element with the path .icons/material/account-circle.svg which eventually shows the icon on the webpage. 12.3. Use in template \u2693\ufe0e Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span> to show the Twitter icon . 13. Escape All \u2693\ufe0e The Escape All extension makes the backslash \\ character escape everything after it, except things in code blocks of any kind. Enable the extension: markdown_extensions : - pymdownx.escapeall : hardbreak : true nbsp : true There are two special escapes among all of these escapes though: escaping space characters and escaping newline characters: Enable nbsp to convert an escaped space into a non-breaking space: &nbsp; . Enable hardbreak to convert an escaped newline to a hard break <br> . The advantage of hard break is that the backslash is visually seen in the document, opposed to the Markdown\u2019s default method of two spaces at the end of a line. For example: This is a line with one space.\\ This is a new line with some \\ \\ \\ \\ \\ spaces. This is a line with one space. This is a new line with some spaces. 14. Sane Headers \u2693\ufe0e The Sane Headers is an extension that alters the default hashed headers extension to require headers to have spaces after the hashes # in order to be recognized as headers. This allows for other extension syntaxes to use # in their syntaxes as long as no spaces follow the # at the beginning of a line. Enable the extension: markdown_extensions : - pymdownx.saneheaders In default, both of these are treated as headers: ## Header ##Also a Header With SaneHeaders, only the first is a header: ## Header ##Not a Header 15. Special characters \u2693\ufe0e The Smarty Pants converts ASCII dashes, quotes and ellipses to their HTML entity equivalents. The Smart Symbols adds syntax for creating special characters such as trademarks, arrows, fractions, etc. Enable the extension: markdown_extensions : - smarty : smart_angled_quotes : true - pymdownx.smartsymbols 15.1. Smarty Pants \u2693\ufe0e 'single quote' \"double quote\" <<angle quote>> ellipses ... N-dash -- M-dash --- \u2018single quote\u2019 \u201cdouble quote\u201d \u00abangle quote\u00bb ellipses \u2026 N-dash \u2013 M-dash \u2014 15.2. Smart Symbols \u2693\ufe0e trademark (tm) copyright (c) registered (r) in care of c/o plus or minus +/- arrows --> <-- <--> not equal =/= fractions 1/4 ordinal numbers 1st 2nd 3rd 4th 5th trademark \u2122 copyright \u00a9 registered \u00ae in care of \u2105 plus or minus \u00b1 arrows \u2192 \u2190 \u2194 not equal \u2260 fractions \u00bc \u00bd \u00be ordinal numbers 1 st 2 nd 3 rd 4 th 5 th 16. Snippets \u2693\ufe0e The Snippets inserts the content of a file into the markdown document. It is great for situations where there is a content that needs to be inserted into multiple documents. Snippets is run as a preprocessor, so if a snippet is found in a fenced code block etc., it will still get processed. Enable the extension: markdown_extensions : - pymdownx.snippets There are two modes of inserting snippets: single line and block. Single line mode accepts a single file name, and block accepts multiple files. Single line format is done by placing the following markup for the single line notation: -\u200b-8<-- \"filename.ext\" In block format, it is important to note that empty lines are preserved for formatting. -\u200b-8<-- filename.md the below empty line is preserved.log filename.log -\u200b-8<-- To temporarily ignore a file, comment it out by pre-pending the path with semicolon ; and a space. This works for both single line and block format: -\u200b-8<-- \"; skip.md\" -\u200b-8<-- include.md ; skip.md -\u200b-8<-- 17. Custom block \u2693\ufe0e The Custom Blocks extension defines a common markup to create parameter-supported and nestable custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: type class param=value Indented content Example usage Add the filename of a codeblock, to show where the it belongs. Syntax: ::: file main.c ```cpp int main ( void ) { return 0 ; } ``` with style: . md-typeset . file + p { font-size : 0.9 em ; color : gray ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; } There are some more custom block created with new layout and style, such as row and col . Read more in Customize theme . 18. Footnotes \u2693\ufe0e The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label `fn`. Footnotes 2 have a label 3 and the footnote\u2019s content. 19. Tips \u2693\ufe0e There are some tips when writing document in Markdown which help to format the content in a good layout. 19.1. Small headers \u2693\ufe0e At small header levels <h5> and <h6> , the header text is smaller than the body text, and the header is transformed to all capitalized characters. Use a hard break and a bold text instead. This make text clear to be read, and have a good space to the previous paragraph. \\ **Item** 19.2. Ignore formatting \u2693\ufe0e When using Prettier extension to format the documents, some block can be ignored from formatting by adding directives. Refer to the Prettier - Ignore Code . Note the this extension only format the markdown file, and when it is rendered to HTML, it will be displayed in HTML rendered visual. In Markdown, use block directive before a block that needs to be preserved: <!-- prettier-ignore --> Do not format this In case of a big block or multiple blocks, use the range directive: <!-- prettier-ignore-start --> | MY | AWESOME | AUTO-GENERATED | TABLE | |-|-|-|-| | a | b | c | d | <!-- prettier-ignore-end --> 19.3. Look up an icon or emoji \u2693\ufe0e Material for MkDocs provides a tool to look up an icon or an emoji by searching a name. It has fast copy to clipboard when selecting on the wanted icon. Please go there https://squidfunk.github.io/mkdocs-material/reference/icons-emojis/ . Use mkdocs-macros plugin to use Jinja template directly in the Markdown content. \u21a9 This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"Markdown syntax"},{"location":"blog/setup-blog/markdown-syntax/#1-meta-data","text":"The Meta-Data extension adds a syntax for defining meta-data of a document. It is inspired by and follows the syntax of MultiMarkdown . Meta-data is the additional information that can be used to briefly describe the content of a post, such as the title, the short description, tags, and sometimes the banner image. Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a markdown document like this: title : The page title description : The summary of the page content Alternatively, meta-data can be written in YAML style, using two triple-dash --- tags to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content --- The metadata can be used in the template and the page content 1 . In jinja syntax, each page is represented as a page object, then the meta-data field {{ page.meta.title }} will be replaced by the string The page title . MkDocs uses the title of each post to show in the navigation sidebar. In case the title is long, it can make the side look a bit messy. A solution is to use a short title on navigation , and a long title on the post. Read more in Customize theme .","title":"1. Meta-data"},{"location":"blog/setup-blog/markdown-syntax/#2-code-blocks","text":"The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The standard format which supports to add id , class or custom key=value is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in a simple syntax: ```language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y-th to z-th . Line numbers are always referenced starting at 1 ignoring what the line number is started labeling at the number set by the option linenums = \"n\" . Example: ```cpp linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } Some styles will be added to the code blocks to make it look a bit bigger and wrap long lines. Read more in Customize theme .","title":"2. Code blocks"},{"location":"blog/setup-blog/markdown-syntax/#3-inline-code","text":"The InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite\u2019s existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language my code` or `#!language my code` . This will render this line `#!python [x for x in range(1, 10) if x % 2]` to a fully colored inline Python code: [ x for x in range ( 1 , 10 ) if x % 2 ] .","title":"3. Inline code"},{"location":"blog/setup-blog/markdown-syntax/#4-admonition","text":"The Admonition extension adds rST-style admonitions to Markdown documents. This block displays its content in a block, with or without a title. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax. The title is optional, use an empty string to remove the title: .md-typeset .admonition.type, .md-typeset details.type { background-color: rgba(68, 138, 255, 0.05); } !!! type \"Title\" Content of the admonition is indented !!! type \"\" There is no title Title Content of the admonition is indented There is no title Other types note, seealso Content of the admonition is indented abstract, summary, tldr Content of the admonition is indented info, todo Content of the admonition is indented tip, hint, important Content of the admonition is indented success, check, done Content of the admonition is indented question, help, faq Content of the admonition is indented warning, caution, attention Content of the admonition is indented failure, fail, missing Content of the admonition is indented danger, error Content of the admonition is indented bug Content of the admonition is indented example Content of the admonition is indented quote, cite Content of the admonition is indented With some additional styles, it is possible to create an admonition without title but still has icon, by using .nt class and an empty title (use \"&nbsp;\" , or \"\\ \" if Escape All extension is used). Read more in Customize theme . !!! info nt \"&nbsp;\" This admonition has icon as an inline element with the content This admonition has icon as an inline element with the content","title":"4. Admonition"},{"location":"blog/setup-blog/markdown-syntax/#5-attribute-list","text":"The Attribute Lists extension adds a syntax to add attributes on the various HTML elements in markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example of using attribute list might look like this: { #id .class key='value' }","title":"5. Attribute list"},{"location":"blog/setup-blog/markdown-syntax/#51-block-attribute","text":"To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. This is a paragraph colored in **teal** by using a block attribute. {style=\"color: teal;\"} This is a paragraph colored in teal by using a block attribute.","title":"5.1. Block attribute"},{"location":"blog/setup-blog/markdown-syntax/#52-element-attribute","text":"To define attributes on inline elements, the attribute list should be defined immediately after an inline element generated by markdown with no white space. This is a _green_ {style=\"color:green\"} word.\\ This is a <span>non-markdown span</span>{style=\"color:green\"} word therefore the attribute is not parsed. This is a green word. This is a non-markdown span {style=\u201dcolor:green\u201d} word therefore the attribute is not parsed.","title":"5.2. Element attribute"},{"location":"blog/setup-blog/markdown-syntax/#6-lists","text":"Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist : custom_checkbox : true - def_list - sane_lists Some styles need to be added to show lists in a better view. Read more in Customize theme .","title":"6. Lists"},{"location":"blog/setup-blog/markdown-syntax/#61-ordered-list","text":"1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2","title":"6.1. Ordered list"},{"location":"blog/setup-blog/markdown-syntax/#62-unordered-list","text":"- Unordered item 1 - Child 1 - Child 2 - Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2","title":"6.2. Unordered list"},{"location":"blog/setup-blog/markdown-syntax/#63-task-list","text":"- [x] item 1 - [x] item a - [ ] item b - [ ] item 2 item 1 item a item b item 2","title":"6.3. Task list"},{"location":"blog/setup-blog/markdown-syntax/#64-definition","text":"Roses : are red Violets : are blue Roses are red Violets are blue","title":"6.4. Definition"},{"location":"blog/setup-blog/markdown-syntax/#65-sane-list","text":"1. Ordered item 1 2. Ordered item 2 - Unordered item 1 - Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2","title":"6.5. Sane list"},{"location":"blog/setup-blog/markdown-syntax/#7-images","text":"There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses the alternate text to make caption, accepts markdown in the alternate text. Install the extension: pip install -U markdown-captions then enable it in the config file: markdown_extensions : - markdown_captions Some images have big size that does not show the detail, therefore, it\u2019s better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library can do that requirement well. Read more in Customize theme to learn how to enable that library. ![ A photo from <https://picsum.photos> ]( https://picsum.photos/320/240 ) A photo from https://picsum.photos","title":"7. Images"},{"location":"blog/setup-blog/markdown-syntax/#8-tabs","text":"Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab A\" Text A === \"Tab B\" Text B === \"Tab 2\" Some other texts Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts Styles for tabs need to change a little bit to have left margin in tab\u2019s content. Read more in Customize theme .","title":"8. Tabs"},{"location":"blog/setup-blog/markdown-syntax/#9-tables","text":"The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. Styles for table need to change a little bit to show cell border. Read more in Customize theme . | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | Some texts | Some texts | Some texts | Syntax Description Test Text Left align Center align Right align Some texts Some texts Some texts","title":"9. Tables"},{"location":"blog/setup-blog/markdown-syntax/#10-formatting","text":"Some texts may have special formats, and here are extensions that can help to add some styles.","title":"10. Formatting"},{"location":"blog/setup-blog/markdown-syntax/#101-caret","text":"Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert^^ the energy E=mc^2^ Insert the energy E=mc 2","title":"10.1. Caret"},{"location":"blog/setup-blog/markdown-syntax/#102-mark","text":"Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== and ==mark==me==all== mark me and mark==me==all","title":"10.2. Mark"},{"location":"blog/setup-blog/markdown-syntax/#103-tildes","text":"Tildes optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete~~ the existence of CH~3~CH~2~OH Delete the existence of CH 3 CH 2 OH","title":"10.3. Tildes"},{"location":"blog/setup-blog/markdown-syntax/#104-critic","text":"Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text, use {\u200b++insert me++} and {\u200b--remove me--}.\\ Denote a substitution with {\u200b~~substitute this~>with this~~}. Highlight specific text with {\u200b==highlight me==}.\\ Or even add {\u200b>>a comment<<}. To insert or remove text, use insert me and remove me . Denote a substitution with substitute this with this . Highlight specific text with highlight me . Or even add a comment .","title":"10.4. Critic"},{"location":"blog/setup-blog/markdown-syntax/#11-html-block","text":"The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With the this extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed word__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed word__ by Markdown. This is a bold word parsed by Markdown.","title":"11. HTML block"},{"location":"blog/setup-blog/markdown-syntax/#12-icons--emojis","text":"The Emoji extension adds support for inserting emoji via simple short names enclosed within colons :short_name: . This is accomplished by using a short name index to map easy-to-remember names to the corresponding emoji characters. Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg","title":"12. Icons &amp; Emojis"},{"location":"blog/setup-blog/markdown-syntax/#121-emojis","text":"Emojis can be written by putting the short-code of the emoji between two colons. Look up the short-codes at Emojipedia . :smile: :heart:","title":"12.1. Emojis"},{"location":"blog/setup-blog/markdown-syntax/#122-icons","text":"Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - . For example: The short-code :material-account-circle: will be converted to an svg image element with the path .icons/material/account-circle.svg which eventually shows the icon on the webpage.","title":"12.2. Icons"},{"location":"blog/setup-blog/markdown-syntax/#123-use-in-template","text":"Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span> to show the Twitter icon .","title":"12.3. Use in template"},{"location":"blog/setup-blog/markdown-syntax/#13-escape-all","text":"The Escape All extension makes the backslash \\ character escape everything after it, except things in code blocks of any kind. Enable the extension: markdown_extensions : - pymdownx.escapeall : hardbreak : true nbsp : true There are two special escapes among all of these escapes though: escaping space characters and escaping newline characters: Enable nbsp to convert an escaped space into a non-breaking space: &nbsp; . Enable hardbreak to convert an escaped newline to a hard break <br> . The advantage of hard break is that the backslash is visually seen in the document, opposed to the Markdown\u2019s default method of two spaces at the end of a line. For example: This is a line with one space.\\ This is a new line with some \\ \\ \\ \\ \\ spaces. This is a line with one space. This is a new line with some spaces.","title":"13. Escape All"},{"location":"blog/setup-blog/markdown-syntax/#14-sane-headers","text":"The Sane Headers is an extension that alters the default hashed headers extension to require headers to have spaces after the hashes # in order to be recognized as headers. This allows for other extension syntaxes to use # in their syntaxes as long as no spaces follow the # at the beginning of a line. Enable the extension: markdown_extensions : - pymdownx.saneheaders In default, both of these are treated as headers: ## Header ##Also a Header With SaneHeaders, only the first is a header: ## Header ##Not a Header","title":"14. Sane Headers"},{"location":"blog/setup-blog/markdown-syntax/#15-special-characters","text":"The Smarty Pants converts ASCII dashes, quotes and ellipses to their HTML entity equivalents. The Smart Symbols adds syntax for creating special characters such as trademarks, arrows, fractions, etc. Enable the extension: markdown_extensions : - smarty : smart_angled_quotes : true - pymdownx.smartsymbols","title":"15. Special characters"},{"location":"blog/setup-blog/markdown-syntax/#151-smarty-pants","text":"'single quote' \"double quote\" <<angle quote>> ellipses ... N-dash -- M-dash --- \u2018single quote\u2019 \u201cdouble quote\u201d \u00abangle quote\u00bb ellipses \u2026 N-dash \u2013 M-dash \u2014","title":"15.1. Smarty Pants"},{"location":"blog/setup-blog/markdown-syntax/#152-smart-symbols","text":"trademark (tm) copyright (c) registered (r) in care of c/o plus or minus +/- arrows --> <-- <--> not equal =/= fractions 1/4 ordinal numbers 1st 2nd 3rd 4th 5th trademark \u2122 copyright \u00a9 registered \u00ae in care of \u2105 plus or minus \u00b1 arrows \u2192 \u2190 \u2194 not equal \u2260 fractions \u00bc \u00bd \u00be ordinal numbers 1 st 2 nd 3 rd 4 th 5 th","title":"15.2. Smart Symbols"},{"location":"blog/setup-blog/markdown-syntax/#16-snippets","text":"The Snippets inserts the content of a file into the markdown document. It is great for situations where there is a content that needs to be inserted into multiple documents. Snippets is run as a preprocessor, so if a snippet is found in a fenced code block etc., it will still get processed. Enable the extension: markdown_extensions : - pymdownx.snippets There are two modes of inserting snippets: single line and block. Single line mode accepts a single file name, and block accepts multiple files. Single line format is done by placing the following markup for the single line notation: -\u200b-8<-- \"filename.ext\" In block format, it is important to note that empty lines are preserved for formatting. -\u200b-8<-- filename.md the below empty line is preserved.log filename.log -\u200b-8<-- To temporarily ignore a file, comment it out by pre-pending the path with semicolon ; and a space. This works for both single line and block format: -\u200b-8<-- \"; skip.md\" -\u200b-8<-- include.md ; skip.md -\u200b-8<--","title":"16. Snippets"},{"location":"blog/setup-blog/markdown-syntax/#17-custom-block","text":"The Custom Blocks extension defines a common markup to create parameter-supported and nestable custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: type class param=value Indented content Example usage Add the filename of a codeblock, to show where the it belongs. Syntax: ::: file main.c ```cpp int main ( void ) { return 0 ; } ``` with style: . md-typeset . file + p { font-size : 0.9 em ; color : gray ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; } There are some more custom block created with new layout and style, such as row and col . Read more in Customize theme .","title":"17. Custom block"},{"location":"blog/setup-blog/markdown-syntax/#18-footnotes","text":"The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label `fn`. Footnotes 2 have a label 3 and the footnote\u2019s content.","title":"18. Footnotes"},{"location":"blog/setup-blog/markdown-syntax/#19-tips","text":"There are some tips when writing document in Markdown which help to format the content in a good layout.","title":"19. Tips"},{"location":"blog/setup-blog/markdown-syntax/#191-small-headers","text":"At small header levels <h5> and <h6> , the header text is smaller than the body text, and the header is transformed to all capitalized characters. Use a hard break and a bold text instead. This make text clear to be read, and have a good space to the previous paragraph. \\ **Item**","title":"19.1. Small headers"},{"location":"blog/setup-blog/markdown-syntax/#192-ignore-formatting","text":"When using Prettier extension to format the documents, some block can be ignored from formatting by adding directives. Refer to the Prettier - Ignore Code . Note the this extension only format the markdown file, and when it is rendered to HTML, it will be displayed in HTML rendered visual. In Markdown, use block directive before a block that needs to be preserved: <!-- prettier-ignore --> Do not format this In case of a big block or multiple blocks, use the range directive: <!-- prettier-ignore-start --> | MY | AWESOME | AUTO-GENERATED | TABLE | |-|-|-|-| | a | b | c | d | <!-- prettier-ignore-end -->","title":"19.2. Ignore formatting"},{"location":"blog/setup-blog/markdown-syntax/#193-look-up-an-icon-or-emoji","text":"Material for MkDocs provides a tool to look up an icon or an emoji by searching a name. It has fast copy to clipboard when selecting on the wanted icon. Please go there https://squidfunk.github.io/mkdocs-material/reference/icons-emojis/ . Use mkdocs-macros plugin to use Jinja template directly in the Markdown content. \u21a9 This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"19.3. Look up an icon or emoji"},{"location":"blog/setup-blog/mkdocs-plugins/","text":"1. Awesome Pages \u2693\ufe0e MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some more extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A 3-dots ... entry is used to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. For example: .pages nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path, so it can be used to filter files in sub-folders. Hide directory by setting the hide attribute to true . Optionally set the directory title using the title attribute. Optionally specify a title for the navigation entry before its document path. For example: .pages title : New section nav : - First page : page1.md - Link Title : https://example.com Collapse single nested pages by setting collapse_single_pages attribute to true . Using collapse_single_pages only, before and after applying 2. Section index \u2693\ufe0e MkDocs Section Index is a plug that change the navigation sidebar to turn section name to a link that show the index page that section. Install the plugin: pip install -U mkdocs-section-index Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages - section-index # must be after awesome-pages In MkDocs, each directory will become a section, and by default, section only contains its children. There is no page associated to a section. This plugin will merge the index.md page in the directory to its section label. However, the merge section page show the section\u2019s title from directory name , not the page\u2019s title. Using the Section Index plugin only, before and after applying This result is different from using collapse_single_pages: true option in the Awesome Pages plugin. If use single page collapsing, Awesome Pages plugin replace the section which has only one child by its child page. Therefore, a directory with index.md and some sub-folders will not be processed to merge the index.md to the section label of that directory. Use both Awesome Pages collapse_single_pages option and Section Index will make a better result because both page and title are merged to the section. 3. Revision date \u2693\ufe0e To keep tracking the last modified date of a post, git-revision-date plugin can be used. A better alternative plugin is git-revision-date-localized which provides more types of date format (even in time-ago format), and the creation date. Install the plugin: pip install -U mkdocs-git-revision-date-localized-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - git-revision-date-localized : enable_creation_date : true type : iso_date This plugin create new field in the post\u2019s meta-data which content the creation and update date. This information is used to sort the posts by revision date to get recently updated items, as shown in the Blog page. Read more in the Customize theme . 4. Print to PDF \u2693\ufe0e To export the posts on this blog, there are plugins which can do it. However, most of them depend on Weasy Print which in turn depends on many other packages. There is one plugin that does printing in an easy and simple way: use browser to print page by sending print command (like press Ctrl + S ). More detail of installation and configuration the MkDocs PDF with JS plugin for printing to PDF can be read in Print to PDF . 5. Macros \u2693\ufe0e This plugin is no longer used in this site! MkDocs Macros is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transform the markdown pages into a Jinja2 templates that can use variables, macros and filters. Replace MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - macros Incomplete data in marco The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data. This issue happens when rendering a the content of the first page, but it needs to know the content of the second page which has not been parsed already as it is waiting for the first page getting done. 6. DrawIO Exporter \u2693\ufe0e This plugin is no longer used in this site! DrawIO Exporter is a great plugin that exports the .drawio diagrams to images at build time and insert them to the document. This plugin can replace the Mermaid plugin, and it is faster thanks to no javascript needed at runtime. It also helps to enable instant navigation mode of the Material theme. Install the plugin: pip install -U mkdocs-drawio-exporter Enable it in the config file: plugins : - search # built-in search must be always activated - drawio-exporter To create end edit .drawio diagram, download and install the diagrams.net application. To import a diagram, just use the syntax for inserting an image: ![ My alt text ]( my-diagram.drawio ) The plugin will generate an svg image to a cache folder (default in docs\\drawio-exporter ), and then modify the image source attribute to the generated image. If the diagram is a multi-page documents, append the index of the page as an anchor in the URL: ![ Page 1 ]( my-diagram.drawio#0 ) A draw.io diagram A limitation Using Draw.io Integration extension in Visual Studio Code, I can save a DrawIO diagram as a .drawio.svg file, then use that file directly in the page as an usual image. However this method will not support multiple pages in the drawing: ![ My alt text ]( my-diagram.drawio.svg ) // work ![ My alt text ]( my-diagram.drawio.svg#1 ) // does not work 7. Mermaid \u2693\ufe0e This plugin is no longer used in this site! MkDocs Mermaid2 is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - mermaid2 And configure the codeblock parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ```mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: A diagram generated by Mermaid","title":"MkDocs plugins"},{"location":"blog/setup-blog/mkdocs-plugins/#1-awesome-pages","text":"MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some more extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A 3-dots ... entry is used to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. For example: .pages nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path, so it can be used to filter files in sub-folders. Hide directory by setting the hide attribute to true . Optionally set the directory title using the title attribute. Optionally specify a title for the navigation entry before its document path. For example: .pages title : New section nav : - First page : page1.md - Link Title : https://example.com Collapse single nested pages by setting collapse_single_pages attribute to true . Using collapse_single_pages only, before and after applying","title":"1. Awesome Pages"},{"location":"blog/setup-blog/mkdocs-plugins/#2-section-index","text":"MkDocs Section Index is a plug that change the navigation sidebar to turn section name to a link that show the index page that section. Install the plugin: pip install -U mkdocs-section-index Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages - section-index # must be after awesome-pages In MkDocs, each directory will become a section, and by default, section only contains its children. There is no page associated to a section. This plugin will merge the index.md page in the directory to its section label. However, the merge section page show the section\u2019s title from directory name , not the page\u2019s title. Using the Section Index plugin only, before and after applying This result is different from using collapse_single_pages: true option in the Awesome Pages plugin. If use single page collapsing, Awesome Pages plugin replace the section which has only one child by its child page. Therefore, a directory with index.md and some sub-folders will not be processed to merge the index.md to the section label of that directory. Use both Awesome Pages collapse_single_pages option and Section Index will make a better result because both page and title are merged to the section.","title":"2. Section index"},{"location":"blog/setup-blog/mkdocs-plugins/#3-revision-date","text":"To keep tracking the last modified date of a post, git-revision-date plugin can be used. A better alternative plugin is git-revision-date-localized which provides more types of date format (even in time-ago format), and the creation date. Install the plugin: pip install -U mkdocs-git-revision-date-localized-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - git-revision-date-localized : enable_creation_date : true type : iso_date This plugin create new field in the post\u2019s meta-data which content the creation and update date. This information is used to sort the posts by revision date to get recently updated items, as shown in the Blog page. Read more in the Customize theme .","title":"3. Revision date"},{"location":"blog/setup-blog/mkdocs-plugins/#4-print-to-pdf","text":"To export the posts on this blog, there are plugins which can do it. However, most of them depend on Weasy Print which in turn depends on many other packages. There is one plugin that does printing in an easy and simple way: use browser to print page by sending print command (like press Ctrl + S ). More detail of installation and configuration the MkDocs PDF with JS plugin for printing to PDF can be read in Print to PDF .","title":"4. Print to PDF"},{"location":"blog/setup-blog/mkdocs-plugins/#5-macros","text":"This plugin is no longer used in this site! MkDocs Macros is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transform the markdown pages into a Jinja2 templates that can use variables, macros and filters. Replace MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - macros Incomplete data in marco The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data. This issue happens when rendering a the content of the first page, but it needs to know the content of the second page which has not been parsed already as it is waiting for the first page getting done.","title":"5. Macros"},{"location":"blog/setup-blog/mkdocs-plugins/#6-drawio-exporter","text":"This plugin is no longer used in this site! DrawIO Exporter is a great plugin that exports the .drawio diagrams to images at build time and insert them to the document. This plugin can replace the Mermaid plugin, and it is faster thanks to no javascript needed at runtime. It also helps to enable instant navigation mode of the Material theme. Install the plugin: pip install -U mkdocs-drawio-exporter Enable it in the config file: plugins : - search # built-in search must be always activated - drawio-exporter To create end edit .drawio diagram, download and install the diagrams.net application. To import a diagram, just use the syntax for inserting an image: ![ My alt text ]( my-diagram.drawio ) The plugin will generate an svg image to a cache folder (default in docs\\drawio-exporter ), and then modify the image source attribute to the generated image. If the diagram is a multi-page documents, append the index of the page as an anchor in the URL: ![ Page 1 ]( my-diagram.drawio#0 ) A draw.io diagram A limitation Using Draw.io Integration extension in Visual Studio Code, I can save a DrawIO diagram as a .drawio.svg file, then use that file directly in the page as an usual image. However this method will not support multiple pages in the drawing: ![ My alt text ]( my-diagram.drawio.svg ) // work ![ My alt text ]( my-diagram.drawio.svg#1 ) // does not work","title":"6. DrawIO Exporter"},{"location":"blog/setup-blog/mkdocs-plugins/#7-mermaid","text":"This plugin is no longer used in this site! MkDocs Mermaid2 is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - mermaid2 And configure the codeblock parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ```mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: A diagram generated by Mermaid","title":"7. Mermaid"},{"location":"blog/setup-blog/print-to-pdf/","text":"1. The cover page \u2693\ufe0e When printing to a PDF file, the first page should show the post title and its short description. This page is called the cover page which will be created only in printing mode. Create an element with class cover in the main.html template to wrap the cover section. In print mode, this element should cover the full height (100%) of the first paper and align its content vertically. After the line of tags, the updated date will be shown to easily check the latest version of the document: overrides\\main.html <style> @media print { .md-typeset .cover { height: 100vh; display: flex; flex-direction: column; justify-content: center; } } </style> <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% if page.meta.git_revision_date_localized %} {% import \"partials/language.html\" as lang with context %} <p class=\"md-source-date\"> <hr style=\"margin-bottom: .5em;\"> <small> {{ lang.t ( \"source.revision.date\" ) }} : {{ page.meta.git_revision_date_localized }} </small> </p> {% endif %} </div> 2. The Table of Content page \u2693\ufe0e When displaying on a screen, the Table of Content is displayed in the right sidebar. In printed pages, there should be a page to display the table of content too. This page is also only visible in printing. The base Material for MkDocs theme has a partial block for Table of Content section, so I just need to include it in the modified main.html template, between the cover page and the main content. {% block content %} <div class=\"cover\"> ... </div> <div class=\"toc\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {{ page.content }} {% endblock %} There are some styles applied for this section: Hide the default label and add a new <h2> header Remove list-style to make a clear list When printing, remove color effect on link items . md-typeset . toc { display : none ; } . md-typeset . toc label { display : none ; } . md-typeset . toc . md-nav { font-size : unset ; line-height : 1.6 ; } . md-typeset . toc . md-nav--secondary { margin-left : -2 em ; } . md-typeset . toc . md-nav__list { margin : 0 ; } . md-typeset . toc ul { list-style : none ; } @ media print { . md-typeset . toc { display : block ; page-break-after : always ; } . md-typeset . toc . md-nav__link { color : var ( --md-typeset-a-color ); } . md-typeset . toc . md-nav__link . md-nav__link--active { font-weight : unset ; } } Preview of the printed document 3. Printing styles \u2693\ufe0e There are some more additional styles need to be applied on the page when printing. I preview the printed version using Save to PDF option in the Chrome browser. Set the paper size and printing margins: @ page { size : a4 portrait ; margin : 25mm 15mm 25mm 20mm ; } Some elements only show in printing version, add media query type to display them: . md-typeset . print-only { display : none ; } @ media print { . md-typeset . print-only { display : block ; } . md-typeset . screen-only { display : none ; } } Tabs labels should be marked in printing as they are selected: . md-typeset . tabbed-set > label { border-color : var ( --md-accent-fg-color ); color : var ( --md-accent-fg-color ); } The disqus section also needs hidden in printing: @ media print { . md-typeset # __comments , . md-typeset # disqus_recommendations , . md-typeset # disqus_thread { display : none ; } } Class .np is used for force break page in printing: . md-typeset . np { page-break-after : always ; } it is good to used with a custom block: ::: np Some elements do not keep the top margin in printing: @ media print { . md-typeset . np + *, . md-typeset . toc + *, . md-typeset . btn-actions + * { margin-top : 0 ; } } Image and its caption should be displayed in the same page: @ media print { . md-typeset figure { page-break-inside : avoid ; } } Admonition can be printed on multiple pages: @ media print { . md-typeset . admonition , . md-typeset details { page-break-inside : auto ; } } 4. Print to PDF plugin \u2693\ufe0e The MkDocs PDF with JS Plugin 1 exports documentation in PDF format with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the page, and it is hidden in the PDF files. For executing the JavaScript code, ChromeDriver is used, so it is nesseccary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user\u2019s PATH environment After that, install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install the original plugin with pip install mkdocs-pdf-with-js-plugin if don\u2019t need a customized version. The following features are not implemented in the original version. Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the PDF files will be generated. They are stored in the site\\pdfs folder. 4.1. Add the download button \u2693\ufe0e Create an element to contain the download button at the beginning of the document content in the base.html template. This element should be hidden in printing mode. The plugin will find the < div class = \"btn-actions\" > element to insert a button. If there is no such existing element, the plugin will create a new element and insert to the page content. def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . p . insert ( 0 , btn ) else : toc = soup . find ( \"div\" , { \"class\" : \"toc\" }) if toc : div = BeautifulSoup ( '' '<div class=\"btn-actions screen-only\">' '<p></p>' '</div>' , 'html.parser' ) div . p . insert ( 0 , btn ) toc . insert_after ( div ) return soup 4.2. Add header and footer \u2693\ufe0e The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol - printToPDF . This command needs some params to control the printing, which include: landscape : boolean Paper orientation. Defaults to false. displayHeaderFooter : boolean Display header and footer. Defaults to false. headerTemplate : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate a span containing the title . footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate . Those params are initialized in the __init__ function: def __init__ ( self ): self . displayHeaderFooter = True self . headerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of ' \\ '<span class=\"totalPages\"></span>' \\ '</div>' and they are used to create print options in in a dictionary variable: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } Finally, the print options are used in the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options () ) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ]) 4.3. Add plugin config options \u2693\ufe0e To allow user to change the print options in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) When the MkDocs engine calls to on_config() function in this plugin, save the user\u2019s configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config By doing this, users can add their params to the pdf-with-js entry under the plugins field in the config file mkdocs.yml : plugins : - search # built-in search must be always activated - pdf-with-js : enable : true display_header_footer : true header_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> <span class=title></span> </div> footer_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span> </div> That\u2019s it. When all blog posts now have a download button for users to get a PDF version. originally developed by smaxtec \u21a9","title":"Print to PDF"},{"location":"blog/setup-blog/print-to-pdf/#1-the-cover-page","text":"When printing to a PDF file, the first page should show the post title and its short description. This page is called the cover page which will be created only in printing mode. Create an element with class cover in the main.html template to wrap the cover section. In print mode, this element should cover the full height (100%) of the first paper and align its content vertically. After the line of tags, the updated date will be shown to easily check the latest version of the document: overrides\\main.html <style> @media print { .md-typeset .cover { height: 100vh; display: flex; flex-direction: column; justify-content: center; } } </style> <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% if page.meta.git_revision_date_localized %} {% import \"partials/language.html\" as lang with context %} <p class=\"md-source-date\"> <hr style=\"margin-bottom: .5em;\"> <small> {{ lang.t ( \"source.revision.date\" ) }} : {{ page.meta.git_revision_date_localized }} </small> </p> {% endif %} </div>","title":"1. The cover page"},{"location":"blog/setup-blog/print-to-pdf/#2-the-table-of-content-page","text":"When displaying on a screen, the Table of Content is displayed in the right sidebar. In printed pages, there should be a page to display the table of content too. This page is also only visible in printing. The base Material for MkDocs theme has a partial block for Table of Content section, so I just need to include it in the modified main.html template, between the cover page and the main content. {% block content %} <div class=\"cover\"> ... </div> <div class=\"toc\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {{ page.content }} {% endblock %} There are some styles applied for this section: Hide the default label and add a new <h2> header Remove list-style to make a clear list When printing, remove color effect on link items . md-typeset . toc { display : none ; } . md-typeset . toc label { display : none ; } . md-typeset . toc . md-nav { font-size : unset ; line-height : 1.6 ; } . md-typeset . toc . md-nav--secondary { margin-left : -2 em ; } . md-typeset . toc . md-nav__list { margin : 0 ; } . md-typeset . toc ul { list-style : none ; } @ media print { . md-typeset . toc { display : block ; page-break-after : always ; } . md-typeset . toc . md-nav__link { color : var ( --md-typeset-a-color ); } . md-typeset . toc . md-nav__link . md-nav__link--active { font-weight : unset ; } } Preview of the printed document","title":"2. The Table of Content page"},{"location":"blog/setup-blog/print-to-pdf/#3-printing-styles","text":"There are some more additional styles need to be applied on the page when printing. I preview the printed version using Save to PDF option in the Chrome browser. Set the paper size and printing margins: @ page { size : a4 portrait ; margin : 25mm 15mm 25mm 20mm ; } Some elements only show in printing version, add media query type to display them: . md-typeset . print-only { display : none ; } @ media print { . md-typeset . print-only { display : block ; } . md-typeset . screen-only { display : none ; } } Tabs labels should be marked in printing as they are selected: . md-typeset . tabbed-set > label { border-color : var ( --md-accent-fg-color ); color : var ( --md-accent-fg-color ); } The disqus section also needs hidden in printing: @ media print { . md-typeset # __comments , . md-typeset # disqus_recommendations , . md-typeset # disqus_thread { display : none ; } } Class .np is used for force break page in printing: . md-typeset . np { page-break-after : always ; } it is good to used with a custom block: ::: np Some elements do not keep the top margin in printing: @ media print { . md-typeset . np + *, . md-typeset . toc + *, . md-typeset . btn-actions + * { margin-top : 0 ; } } Image and its caption should be displayed in the same page: @ media print { . md-typeset figure { page-break-inside : avoid ; } } Admonition can be printed on multiple pages: @ media print { . md-typeset . admonition , . md-typeset details { page-break-inside : auto ; } }","title":"3. Printing styles"},{"location":"blog/setup-blog/print-to-pdf/#4-print-to-pdf-plugin","text":"The MkDocs PDF with JS Plugin 1 exports documentation in PDF format with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the page, and it is hidden in the PDF files. For executing the JavaScript code, ChromeDriver is used, so it is nesseccary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user\u2019s PATH environment After that, install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install the original plugin with pip install mkdocs-pdf-with-js-plugin if don\u2019t need a customized version. The following features are not implemented in the original version. Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the PDF files will be generated. They are stored in the site\\pdfs folder.","title":"4. Print to PDF plugin"},{"location":"blog/setup-blog/print-to-pdf/#41-add-the-download-button","text":"Create an element to contain the download button at the beginning of the document content in the base.html template. This element should be hidden in printing mode. The plugin will find the < div class = \"btn-actions\" > element to insert a button. If there is no such existing element, the plugin will create a new element and insert to the page content. def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . p . insert ( 0 , btn ) else : toc = soup . find ( \"div\" , { \"class\" : \"toc\" }) if toc : div = BeautifulSoup ( '' '<div class=\"btn-actions screen-only\">' '<p></p>' '</div>' , 'html.parser' ) div . p . insert ( 0 , btn ) toc . insert_after ( div ) return soup","title":"4.1. Add the download button"},{"location":"blog/setup-blog/print-to-pdf/#42-add-header-and-footer","text":"The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol - printToPDF . This command needs some params to control the printing, which include: landscape : boolean Paper orientation. Defaults to false. displayHeaderFooter : boolean Display header and footer. Defaults to false. headerTemplate : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate a span containing the title . footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate . Those params are initialized in the __init__ function: def __init__ ( self ): self . displayHeaderFooter = True self . headerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of ' \\ '<span class=\"totalPages\"></span>' \\ '</div>' and they are used to create print options in in a dictionary variable: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } Finally, the print options are used in the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options () ) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ])","title":"4.2. Add header and footer"},{"location":"blog/setup-blog/print-to-pdf/#43-add-plugin-config-options","text":"To allow user to change the print options in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) When the MkDocs engine calls to on_config() function in this plugin, save the user\u2019s configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config By doing this, users can add their params to the pdf-with-js entry under the plugins field in the config file mkdocs.yml : plugins : - search # built-in search must be always activated - pdf-with-js : enable : true display_header_footer : true header_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> <span class=title></span> </div> footer_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span> </div> That\u2019s it. When all blog posts now have a download button for users to get a PDF version. originally developed by smaxtec \u21a9","title":"4.3. Add plugin config options"},{"location":"blog/stm32/","text":"STM32 Nucleo boards Topics \u2693\ufe0e In this blog, I\u2019ll try to write posts in an easy-to-follow order, so that beginners can understand them well. There are also some advanced topics for debugging or programming with more complex techniques or projects. Communities \u2693\ufe0e Official Homepage: https://www.st.com/ ST\u2019s Education center: https://www.st.com/content/st_com/en/support/learning/stm32-education.html The Education Center has a lot of materials and documents arranged into groups: basics, tools, product lines, application, tips & tricks. ST\u2019s Forum: https://community.st.com/s/ ST\u2019s Wiki page: https://wiki.st.com/stm32mcu OpenSTM32 Forum: https://www.openstm32.org/forums STM32Duino: https://www.stm32duino.com/ Content \u2693\ufe0e The content of each post is based on my experience, but it\u2019s hard to write down all of them. Since I also taught some embedded courses in my company for freshers, I would like to keep the content as simple as possible to help beginners feel easy to follow. The guides and tutorials given here can be be applied to different types of STM32 MCUs, as I will try to use the internal peripherals of the microcontroller and some popular external ones. I am also in the process of learning, therefore, some posts I shared may have a mistake or be out-of-date, so please give me a comment and feedback to help me improve this series. I hope you can find something interesting and helpful here. References \u2693\ufe0e While learning, I\u2019ve read a lot of resource on books and on the internet. I could not re-draw or rephrase all of the information pieces, so I will use include them in my posts. In those cases, the credit belong to the original authors. Here are the reference list: The book \u201cMastering STM32\u201d by Carmine Noviello The tutorials on DeepBlue MBedded","title":"STM32"},{"location":"blog/stm32/#topics","text":"In this blog, I\u2019ll try to write posts in an easy-to-follow order, so that beginners can understand them well. There are also some advanced topics for debugging or programming with more complex techniques or projects.","title":"Topics"},{"location":"blog/stm32/#communities","text":"Official Homepage: https://www.st.com/ ST\u2019s Education center: https://www.st.com/content/st_com/en/support/learning/stm32-education.html The Education Center has a lot of materials and documents arranged into groups: basics, tools, product lines, application, tips & tricks. ST\u2019s Forum: https://community.st.com/s/ ST\u2019s Wiki page: https://wiki.st.com/stm32mcu OpenSTM32 Forum: https://www.openstm32.org/forums STM32Duino: https://www.stm32duino.com/","title":"Communities"},{"location":"blog/stm32/#content","text":"The content of each post is based on my experience, but it\u2019s hard to write down all of them. Since I also taught some embedded courses in my company for freshers, I would like to keep the content as simple as possible to help beginners feel easy to follow. The guides and tutorials given here can be be applied to different types of STM32 MCUs, as I will try to use the internal peripherals of the microcontroller and some popular external ones. I am also in the process of learning, therefore, some posts I shared may have a mistake or be out-of-date, so please give me a comment and feedback to help me improve this series. I hope you can find something interesting and helpful here.","title":"Content"},{"location":"blog/stm32/#references","text":"While learning, I\u2019ve read a lot of resource on books and on the internet. I could not re-draw or rephrase all of the information pieces, so I will use include them in my posts. In those cases, the credit belong to the original authors. Here are the reference list: The book \u201cMastering STM32\u201d by Carmine Noviello The tutorials on DeepBlue MBedded","title":"References"},{"location":"blog/stm32/add-swo/","text":"Any original ST\u2019s board has an integrated ST-LINK/V2 debugger which supports SWO to trace ITM outputs on Cortext-M3+. That debugger can be used to program and debug an external MCU on other board, or turn into an J-Link debugger. Many ST-LINK clones do not have SWO pin exposed. When open the clone board, the STM32F103 chip is found, which is the same as the chip used in the original ST-LINK. So, the problem of missing SWO can be solved by exposing the SWO pin. 1. ST-LINK/V2 Schematic \u2693\ufe0e The original boards from ST always come with a schematic. Under the tab CAD Resources of the page for the Nucleo-F103 board on ST\u2019s site, the schematic is nucleo_64pins_sch.zip . In the schematic, it is clear that T_SWO line is connected to the pin PA10 (#31) on the STM32F103 chip. Original ST-LINK/V2 with the SWO pin 2. Clone schematic \u2693\ufe0e There is no way to see a schematic of a clone device. Clone hardwares are marked with MX-LINK label. However, as the schematic for ST-LINK/V2 is public in the board document, it\u2019s expected that the clone uses the exactly same hardware with the original one. The firmware download works well on the clone, so it\u2019s mainly sure that the hardware is identical. People also have found that some cloned devices use STM32F101 instead of STM32F103, and the pinout maybe LQFP64, not LQFP48. However, thanks to the pin compatibility of STM32, PA10 will still have the same function on variant chips. 3. Wire SWO Pin \u2693\ufe0e One thing apparently clear at the moment is the PA10 (#31) pin can be exposed to the header. Just cut a 5V pin, and wire the PA10 pin through a small resister (22R or 100R). Write the PA10 pin to the header on a LQFP64 STM32F101 That\u2019s it. Hardware modding is very simple. Next is to test with SWV mode in a debugging session. Check the steps in Debug with SWV mode . Capture of working ST-LINK/V2 SWV with SWV Viewer or CubeMonitor:","title":"Add SWO"},{"location":"blog/stm32/add-swo/#1-st-linkv2-schematic","text":"The original boards from ST always come with a schematic. Under the tab CAD Resources of the page for the Nucleo-F103 board on ST\u2019s site, the schematic is nucleo_64pins_sch.zip . In the schematic, it is clear that T_SWO line is connected to the pin PA10 (#31) on the STM32F103 chip. Original ST-LINK/V2 with the SWO pin","title":"1. ST-LINK/V2 Schematic"},{"location":"blog/stm32/add-swo/#2-clone-schematic","text":"There is no way to see a schematic of a clone device. Clone hardwares are marked with MX-LINK label. However, as the schematic for ST-LINK/V2 is public in the board document, it\u2019s expected that the clone uses the exactly same hardware with the original one. The firmware download works well on the clone, so it\u2019s mainly sure that the hardware is identical. People also have found that some cloned devices use STM32F101 instead of STM32F103, and the pinout maybe LQFP64, not LQFP48. However, thanks to the pin compatibility of STM32, PA10 will still have the same function on variant chips.","title":"2. Clone schematic"},{"location":"blog/stm32/add-swo/#3-wire-swo-pin","text":"One thing apparently clear at the moment is the PA10 (#31) pin can be exposed to the header. Just cut a 5V pin, and wire the PA10 pin through a small resister (22R or 100R). Write the PA10 pin to the header on a LQFP64 STM32F101 That\u2019s it. Hardware modding is very simple. Next is to test with SWV mode in a debugging session. Check the steps in Debug with SWV mode . Capture of working ST-LINK/V2 SWV with SWV Viewer or CubeMonitor:","title":"3. Wire SWO Pin"},{"location":"blog/stm32/clock/","text":"1. Clock source \u2693\ufe0e A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle . A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator High Speed Internal (HSI) ; or an external dedicated crystal oscillator High Speed External (HSE) There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25\u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal Low Speed External (LSE) ; or the internal dedicated RC oscillator Low Speed Internal (LSI) The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency 2. Clock tree \u2693\ufe0e The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC) , and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK - that is the one that feeds the core, DMAs and AHB bus), and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses. 3. Master Clock Output \u2693\ufe0e The RCC peripheral also allows to enable the Master Clock Output (MCO) , which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view. 4. Clock Security System \u2693\ufe0e The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception - a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initializations inside the NMI exception handler. Example of a clock tree 5. Configure Clocks \u2693\ufe0e After a reset : The device is running from the Internal High Speed oscillator (HSI 8 MHz) with Flash 0 wait state, Flash prefetch buffer is enabled, and all peripherals are off except internal SRAM, Flash and JTAG. There is no prescaler on High speed (AHB) and Low speed (APB) buses; all peripherals mapped on these buses are running at HSI speed. The clock for all peripherals is switched off, except the SRAM and FLASH. All GPIOs are in input floating state, except the JTAG pins which are assigned to be used for debug purpose. Once start up, the user application has to : Configure the clock source to be used to drive the System clock (if the application needs higher frequency/ performance) Configure the System clock frequency and Flash settings Configure the AHB and APB buses prescalers Enable the clock for the peripheral(s) to be used Configure the clock source(s) for peripherals whose clocks are not derived from the System clock (RTC, ADC, I2C, USART, TIM, USB FS, etc.) 6. CubeMX Usage \u2693\ufe0e Here are two examples of setting up the clock on 2 boards - one with only internal oscillator, one with external crystals. Note that when changing the clock speed, there are some limitation of the frequency of the target buses, e.g. HCLK , PCK1 , PCK2 . For both HSE and LSE external crystals, CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. User can fill in a number in a frequency node, and press Enter to let IDE automatically calculate the multiplier\u2019s and divider\u2019s value. 6.1. Internal RC oscillators \u2693\ufe0e This is an example guide on an official STM32F0 Discovery board , which only has internal RC oscillators: Select PLL Source Mux is HSI Set PLL Multiplier and Divider to get PLLCLK Select System Clock Mux is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK and APB1 Bus PCLK1 Setup clock with HSI on STM32F051R8 6.2. External crystals \u2693\ufe0e This is an example guide on a custom black pill STM32F411CE board , which has external crystals: Enable HSE and LSE : In the RCC peripheral under the System Core modules, choose option Crystal/Ceramic Resonator . This will automatically setups 2 pins for HSE, and 2 pins for LSE. Enable HSE and LSE Select PLL Source Mux is HSE Set PLL Multiplier and Divider to get PLLCLK Select System Clock Mux is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK , APB1 Bus PCLK1 , APB2 Bus PCLK2 Setup clock with HSE on STM32F411CE 7. STM32Cube HAL Usage \u2693\ufe0e CubeMX is designed to generate the right code initialization for the clock tree of MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c : The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . Use HAL_RCC_OscConfig() function to setup the Oscillator source, and then use HAL_RCC_ClockConfig() function to setup the System clock (CPU) and Bus clocks (AHB, APB). To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Example 1 - Setting clock on F051R8, with 8 MHz HSI, to make 48 MHZ SYSCLK, and drive MCO at 48 MHz using SYSCLK: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); } Example 2 - Setting clock on F411CE, with 25 MHZ HSE and 32.765KHz LSE, to make 100 MHz SYSCLK, 50 MHz APB1 Bus, 100 MHZ APB2, with CSS Enabled: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE1 ); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSE ; RCC_OscInitStruct . HSEState = RCC_HSE_ON ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSE ; RCC_OscInitStruct . PLL . PLLM = 12 ; RCC_OscInitStruct . PLL . PLLN = 96 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV2 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ) != HAL_OK ) { Error_Handler (); } /** Enables the Clock Security System */ HAL_RCC_EnableCSS (); } Note that when CSS is enabled, HAL_RCC_NMI_IRQHandler() is added into the NMI_Handler() ISR. User should override the HAL_RCC_CSSCallback() function to re-configure the system clocks as the same way as it only has the internal RC oscillators.","title":"Clock Tree"},{"location":"blog/stm32/clock/#1-clock-source","text":"A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle . A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator High Speed Internal (HSI) ; or an external dedicated crystal oscillator High Speed External (HSE) There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25\u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal Low Speed External (LSE) ; or the internal dedicated RC oscillator Low Speed Internal (LSI) The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency","title":"1. Clock source"},{"location":"blog/stm32/clock/#2-clock-tree","text":"The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC) , and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK - that is the one that feeds the core, DMAs and AHB bus), and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses.","title":"2. Clock tree"},{"location":"blog/stm32/clock/#3-master-clock-output","text":"The RCC peripheral also allows to enable the Master Clock Output (MCO) , which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view.","title":"3. Master Clock Output"},{"location":"blog/stm32/clock/#4-clock-security-system","text":"The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception - a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initializations inside the NMI exception handler. Example of a clock tree","title":"4. Clock Security System"},{"location":"blog/stm32/clock/#5-configure-clocks","text":"After a reset : The device is running from the Internal High Speed oscillator (HSI 8 MHz) with Flash 0 wait state, Flash prefetch buffer is enabled, and all peripherals are off except internal SRAM, Flash and JTAG. There is no prescaler on High speed (AHB) and Low speed (APB) buses; all peripherals mapped on these buses are running at HSI speed. The clock for all peripherals is switched off, except the SRAM and FLASH. All GPIOs are in input floating state, except the JTAG pins which are assigned to be used for debug purpose. Once start up, the user application has to : Configure the clock source to be used to drive the System clock (if the application needs higher frequency/ performance) Configure the System clock frequency and Flash settings Configure the AHB and APB buses prescalers Enable the clock for the peripheral(s) to be used Configure the clock source(s) for peripherals whose clocks are not derived from the System clock (RTC, ADC, I2C, USART, TIM, USB FS, etc.)","title":"5. Configure Clocks"},{"location":"blog/stm32/clock/#6-cubemx-usage","text":"Here are two examples of setting up the clock on 2 boards - one with only internal oscillator, one with external crystals. Note that when changing the clock speed, there are some limitation of the frequency of the target buses, e.g. HCLK , PCK1 , PCK2 . For both HSE and LSE external crystals, CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. User can fill in a number in a frequency node, and press Enter to let IDE automatically calculate the multiplier\u2019s and divider\u2019s value.","title":"6. CubeMX Usage"},{"location":"blog/stm32/clock/#61-internal-rc-oscillators","text":"This is an example guide on an official STM32F0 Discovery board , which only has internal RC oscillators: Select PLL Source Mux is HSI Set PLL Multiplier and Divider to get PLLCLK Select System Clock Mux is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK and APB1 Bus PCLK1 Setup clock with HSI on STM32F051R8","title":"6.1. Internal RC oscillators"},{"location":"blog/stm32/clock/#62-external-crystals","text":"This is an example guide on a custom black pill STM32F411CE board , which has external crystals: Enable HSE and LSE : In the RCC peripheral under the System Core modules, choose option Crystal/Ceramic Resonator . This will automatically setups 2 pins for HSE, and 2 pins for LSE. Enable HSE and LSE Select PLL Source Mux is HSE Set PLL Multiplier and Divider to get PLLCLK Select System Clock Mux is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK , APB1 Bus PCLK1 , APB2 Bus PCLK2 Setup clock with HSE on STM32F411CE","title":"6.2. External crystals"},{"location":"blog/stm32/clock/#7-stm32cube-hal-usage","text":"CubeMX is designed to generate the right code initialization for the clock tree of MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c : The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . Use HAL_RCC_OscConfig() function to setup the Oscillator source, and then use HAL_RCC_ClockConfig() function to setup the System clock (CPU) and Bus clocks (AHB, APB). To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Example 1 - Setting clock on F051R8, with 8 MHz HSI, to make 48 MHZ SYSCLK, and drive MCO at 48 MHz using SYSCLK: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); } Example 2 - Setting clock on F411CE, with 25 MHZ HSE and 32.765KHz LSE, to make 100 MHz SYSCLK, 50 MHz APB1 Bus, 100 MHZ APB2, with CSS Enabled: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE1 ); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSE ; RCC_OscInitStruct . HSEState = RCC_HSE_ON ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSE ; RCC_OscInitStruct . PLL . PLLM = 12 ; RCC_OscInitStruct . PLL . PLLN = 96 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV2 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ) != HAL_OK ) { Error_Handler (); } /** Enables the Clock Security System */ HAL_RCC_EnableCSS (); } Note that when CSS is enabled, HAL_RCC_NMI_IRQHandler() is added into the NMI_Handler() ISR. User should override the HAL_RCC_CSSCallback() function to re-configure the system clocks as the same way as it only has the internal RC oscillators.","title":"7. STM32Cube HAL Usage"},{"location":"blog/stm32/dma/","text":"DMA Mem2Mem vs memcpy 1. DMA Controller \u2693\ufe0e The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports , named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port , connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows to assign different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory The DMA architecture in an STM32 F0/F1/F3/L1 MCUs The DMA architecture in an STM32 F2/F4/F7 MCU 2. DMA Channels \u2693\ufe0e Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC (peripheral address increment) and MINC (memory address inscrement) bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size. 3. DMA Circular Mode \u2693\ufe0e The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served. 4. DMA Interrupts \u2693\ufe0e From the performance point of view, the DMA transfer in polling mode is meaningless as there is no reason to start a DMA transfer then consume a lot of CPU cycles just to wait for the transfer completion. So the best option is to arm the DMA and let it notify when the transfer is completed. The DMA is able to generate interrupts related to channel activities (for example, the DMA1 in an STM32F030 MCU has one IRQ for channel 1, one for channels 2 and 3, one for channels 4 and 5). Moreover, three independent enable bits are available to enable IRQ on half transfer, full transfer and transfer error. Separate interrupt enable bits are available for flexibility. 5. STM32Cube HAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer, HAL_DMA_IRQHandler() function is executed and user can add a callback function by assigning function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure). 6. Lab: DMA Memory to Memory \u2693\ufe0e To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer in byte-to-byte mode. Requirement : Create a 4KB data block in flash memory (slow speed) Create a 4KB buffer in SRAM memory (high speed) Disable code optimization in compilation Run CPU memcpy() function to copy from flash to sram Run DMA Mem2Mem transfer to copy from flash to sram Each operation\u2019s duration will be measure by a pulse on GPIO to visual view on a logic analyser Target board : Any board has GPIOs to output execution time pulses. STM32F051R8 Mode PC8 Output Push Pull, No Pull-up and No Pull-down PC9 Output Push Pull, No Pull-up and No Pull-down 6.1. Start new project \u2693\ufe0e If start a new project on a ST\u2019s Discovery / Nucleo board, select to use default settings for the board. If start a new custom project, make sure to set up the system clock, and programer interface. 6.2. Enable DMA \u2693\ufe0e Goto System Core \u00bb DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core 6.3. Generated code \u2693\ufe0e An instance of DMA_HandleTypeDef hdma_m2m_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: Enable DMA clock Setup DMA properties: Channel / Mode / Memory Address Increment / Data size /Priority static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_m2m_dma1_channel1 on DMA1_Channel1 */ hdma_m2m_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_m2m_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_m2m_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_m2m_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_m2m_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } } 6.4. User code \u2693\ufe0e Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Always allocated memory for DMA at the global scope Using const modifier to put variable in to the Flash Memory by Linker. Read more here . Measure execution time To measure the execution time in a logic analyser, output a pulse on PC9 during the transfers. This pin is set to LOW at the startup, and set to HIGH when starting transfer, and set back to LOW when the transfer completes. Test the CPU memcpy() function HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer Note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); ` HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_m2m_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1193 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem 6.5. DMA interrupts \u2693\ufe0e Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \u201cDMA1 channel 1 interrupt\u201d : Enable DMA Interrupt in IDE Then generated code will add into an IRQ handler in the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_m2m_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, those callback are not set, therefore, write 2 functions to handle DMA interrupts. Note that, a new GPIO PC8 is used to show the last half transfer time. void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else /* DMA Polling mode */ #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer 6.6. DMA Data size \u2693\ufe0e Using Word-aligned memory block to speed up the DMA transfer. Note that transfer size will be reduced. static void MX_DMA_Init ( void ) { ... hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; ... } int main ( void ) { HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE / 4 ); } As seen in below image, the DMA transferring time in Word-aligned mode is only 142us, comparing the 525us in Byte-aligned mode. Using World-aligned to reduce DMA transfer time","title":"DMA"},{"location":"blog/stm32/dma/#1-dma-controller","text":"The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports , named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port , connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows to assign different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory The DMA architecture in an STM32 F0/F1/F3/L1 MCUs The DMA architecture in an STM32 F2/F4/F7 MCU","title":"1. DMA Controller"},{"location":"blog/stm32/dma/#2-dma-channels","text":"Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC (peripheral address increment) and MINC (memory address inscrement) bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size.","title":"2. DMA Channels"},{"location":"blog/stm32/dma/#3-dma-circular-mode","text":"The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served.","title":"3. DMA Circular Mode"},{"location":"blog/stm32/dma/#4-dma-interrupts","text":"From the performance point of view, the DMA transfer in polling mode is meaningless as there is no reason to start a DMA transfer then consume a lot of CPU cycles just to wait for the transfer completion. So the best option is to arm the DMA and let it notify when the transfer is completed. The DMA is able to generate interrupts related to channel activities (for example, the DMA1 in an STM32F030 MCU has one IRQ for channel 1, one for channels 2 and 3, one for channels 4 and 5). Moreover, three independent enable bits are available to enable IRQ on half transfer, full transfer and transfer error. Separate interrupt enable bits are available for flexibility.","title":"4. DMA Interrupts"},{"location":"blog/stm32/dma/#5-stm32cube-hal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer, HAL_DMA_IRQHandler() function is executed and user can add a callback function by assigning function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure).","title":"5. STM32Cube HAL Usage"},{"location":"blog/stm32/dma/#6-lab-dma-memory-to-memory","text":"To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer in byte-to-byte mode. Requirement : Create a 4KB data block in flash memory (slow speed) Create a 4KB buffer in SRAM memory (high speed) Disable code optimization in compilation Run CPU memcpy() function to copy from flash to sram Run DMA Mem2Mem transfer to copy from flash to sram Each operation\u2019s duration will be measure by a pulse on GPIO to visual view on a logic analyser Target board : Any board has GPIOs to output execution time pulses. STM32F051R8 Mode PC8 Output Push Pull, No Pull-up and No Pull-down PC9 Output Push Pull, No Pull-up and No Pull-down","title":"6. Lab: DMA Memory to Memory"},{"location":"blog/stm32/dma/#61-start-new-project","text":"If start a new project on a ST\u2019s Discovery / Nucleo board, select to use default settings for the board. If start a new custom project, make sure to set up the system clock, and programer interface.","title":"6.1. Start new project"},{"location":"blog/stm32/dma/#62-enable-dma","text":"Goto System Core \u00bb DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core","title":"6.2. Enable DMA"},{"location":"blog/stm32/dma/#63-generated-code","text":"An instance of DMA_HandleTypeDef hdma_m2m_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: Enable DMA clock Setup DMA properties: Channel / Mode / Memory Address Increment / Data size /Priority static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_m2m_dma1_channel1 on DMA1_Channel1 */ hdma_m2m_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_m2m_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_m2m_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_m2m_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_m2m_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } }","title":"6.3. Generated code"},{"location":"blog/stm32/dma/#64-user-code","text":"Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Always allocated memory for DMA at the global scope Using const modifier to put variable in to the Flash Memory by Linker. Read more here . Measure execution time To measure the execution time in a logic analyser, output a pulse on PC9 during the transfers. This pin is set to LOW at the startup, and set to HIGH when starting transfer, and set back to LOW when the transfer completes. Test the CPU memcpy() function HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer Note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); ` HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_m2m_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1193 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem","title":"6.4. User code"},{"location":"blog/stm32/dma/#65-dma-interrupts","text":"Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \u201cDMA1 channel 1 interrupt\u201d : Enable DMA Interrupt in IDE Then generated code will add into an IRQ handler in the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_m2m_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, those callback are not set, therefore, write 2 functions to handle DMA interrupts. Note that, a new GPIO PC8 is used to show the last half transfer time. void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else /* DMA Polling mode */ #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer","title":"6.5. DMA interrupts"},{"location":"blog/stm32/dma/#66-dma-data-size","text":"Using Word-aligned memory block to speed up the DMA transfer. Note that transfer size will be reduced. static void MX_DMA_Init ( void ) { ... hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; ... } int main ( void ) { HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE / 4 ); } As seen in below image, the DMA transferring time in Word-aligned mode is only 142us, comparing the 525us in Byte-aligned mode. Using World-aligned to reduce DMA transfer time","title":"6.6. DMA Data size"},{"location":"blog/stm32/docs/","text":"STM32CubeIDE has a better way to list all related documents of selected processor, and it can download documents too. Find the documents in menu Help \u2192 Target device docs and resources . List of documents for a target 1. The Datasheet \u2693\ufe0e This document contains highlight of the target microprocessor with main features and capabilities. Many people are confused with Reference Manual, but when comparing the content, they are written for different purpose. This document is helpful when designing a PCB. It gives recommended layout for things like signal characteristic, NRST pin, ADC pins, Boot mode, etc. Datasheet provides the following: General description including product line, speed, memory, operating voltage, temperature range Device overview with block diagram, available peripherals and functions Pinouts and pin descriptions Memory map and memory ranges Electrical Characteristics Package information, for modeling PCB footprints Ordering Information Excerpt from DS8668 - STM32F051x4 STM32F051x6 STM32F051x8 Datasheet The block diagram of STM32F051xx Boot modes At startup, the boot pin and boot selector option bit are used to select one of the three boot options: boot from User Flash memory boot from System Memory boot from embedded SRAM The boot loader is located in System Memory. It is used to reprogram the Flash memory by using USART on pins PA14 / PA15 or PA9 / PA10 . Pinout table I/O structure with marker FT for 5V-tolerant I/O, TT or TC for 3.3V-only I/O. Unless otherwise specified by a note, all I/Os are set as floating inputs during and after reset. The pinout description Alternate functions Memory map and boundary address Operation condition Speed modes on IO 2. The Reference Manual \u2693\ufe0e This is by far the most important document in order to program the target device. It defines all information about the core and peripheral at register level with bit-by-bit description. By using only this document, developer still can program the chip without any higher level API - usually called Bare-metal programming. Reference Manual provides the following: System Architecture with bus, peripherals, and connections Memory map and boundary address Boot configuration and vector table relocation Peripheral with details features, descriptions, and structure Register name and bit-fields for all accessible registers Code examples using CMSIS header files Excerpt from RM0091 - STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM\u00ae-based 32-bit MCUs System architecture for STM32F0x Boot modes The boot mode configuration is latched on the 4 th rising edge of SYSCLK after a reset, and is also re-sampled when exiting from Standby mode. After this startup delay has elapsed, the CPU always fetches the top-of-stack value from address 0x00000000 , then starts code execution from the boot memory at 0x00000004 . Depending on the selected boot mode, main Flash memory, system memory or SRAM is accessible as follows: Boot from main Flash memory: the main Flash memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space 0x08000000 . Boot from system memory: the system memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space ( 0x1FFFEC00 on STM32F03x and STM32F05x devices, 0x1FFFC400 on STM32F04x devices, 0x1FFFC800 on STM32F07x and 0x1FFFD800 on STM32F09x devices). Boot from the embedded SRAM: the SRAM is aliased in the boot memory space 0x00000000 , but it is still accessible from its original memory space 0x20000000 . Physical remap For application code which is located in a different address than 0x08000000 , some additional code must be added in order to be able to serve the application interrupts. A solution will be to relocate by software the vector table to the internal SRAM, at the initialization phase: Copy the vector table from the Flash (mapped at the base of the application load address) to the base address of the SRAM at 0x20000000 Remap SRAM at address 0x00000000 , using SYSCFG configuration register 1 Embedded boot loader The embedded boot loader is located in the System memory, programmed by ST during production. It is used to reprogram the Flash memory using one of the following serial interfaces: USART on pins PA14 / PA15 or PA9 / PA10 I2C on pins PB6 / PB7 (STM32F04xxx, STM32F07xxx and STM32F09xxx devices only) USB DFU interface (STM32F04xxx and STM32F07xxx devices only) Debug pin During and just after reset, the alternate functions are not active and most of the I/O ports are configured in input floating mode, except the debug pins are in AF mode immediately: PA14 : SWCLK in pull-down PA13 : SWDIO in pull-up The clock paths Example code USART transmitter configuration: /* (1) Oversampling by 16, 9600 baud */ /* (2) 8 data bit, 1 start bit, 1 stop bit, no parity */ USART1 -> BRR = 480000 / 96 ; /* (1) */ USART1 -> CR1 = USART_CR1_TE | USART_CR1_UE ; /* (2) */ USART transfer: if (( USART1 -> ISR & USART_ISR_TC ) == USART_ISR_TC ) { if ( send == sizeof ( stringtosend )) { send = 0 ; USART1 -> ICR |= USART_ICR_TCCF ; /* Clear transfer complete flag */ } else { /* clear transfer complete flag and fill TDR with a new char */ USART1 -> TDR = stringtosend [ send ++ ]; } } The structure of an IO pin 3. Programming Manual \u2693\ufe0e This programming manual provides information for application and system-level software developers. It gives a full description of the STM32 Cortex\u2122-M0 processor programming model, instruction set and core peripherals. Programming Manual provides the following: Processor Modes, Stacks Memory model Exception model, the Vector table and the interrupt service routines Fault handling Power management: enter Sleep mode, Wake up The Instruction Set CMSIS intrinsic functions Core Peripherals: Memory Protection Unit (MPU) Nested vectored interrupt controller (NVIC) System control block (SCB) SysTick timer (STK) Excerpt from PM0215 - STM32F0xxx Cortex-M0 programming manual Processor modes Thread mode: Used to execute application software. The processor enters Thread mode when it comes out of reset Handler mode: Used to handle exceptions. The processor returns to Thread mode when it has finished exception processing. Registers Stacks The processor uses a full descending stack. This means the stack pointer indicates the last stacked item on the stack memory. The processor implements two stacks, with independent copies of the stack pointer: The main stack and The process stack In Thread mode, the CONTROL register controls whether the processor uses the main stack or the process stack: 0 : Main Stack Pointer (MSP)(reset value). On reset, the processor loads the MSP with the value from address 0x00000000 . 1 : Process Stack Pointer (PSP). In Handler mode, the processor always uses the main stack. Memory endianness The processor views memory in little-endian format. It stores the least significant byte (lsbyte) of a word at the lowest-numbered byte, and the most significant byte (msbyte) at the highest-numbered byte. The Little-Endian memory layout The exception types Vector table On system reset, the vector table is fixed at address 0x00000000 . The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code. The exception vector table 4. Application Note \u2693\ufe0e There many Application Note documents provided by ST. Each document present the usage, design, and advice for a specific application or feature. Application Note provides the following: Peripherals architecture in hardware and software Operation characteristic Excerpt from AN2548 - Using the STM32F0/F1/F3/Gx/Lx Series DMA controller DMA transfer timing For the case where only one DMA channel is active, a new hardware back-to-back request can not be handled by the DMA before the completion of the previous one, adding one AHB clock cycle for the final idle phase of the DMA request-acknowledge handshake protocol. DMA Block diagram When more than one channel is requesting a DMA transfer, the DMA request arbitration can be performed meanwhile the two last cycles of when the AHB bus is accessed by the DMA. Request arbitration overhead is then masked by the AHB bus transfer time. In case not only two channels, but two DMA controllers are used (in products that offer this possibility), two DMA transfers can be processed in parallel, as long as they are not conflicting within the bus matrix, not accessing the same slave device. Timing of Two DMA channel on AHB Bus Excerpt from AN2834 - How to get the best ADC accuracy in STM32 microcontrollers SAR ADC internal structure The ADC embedded in STM32 microcontrollers uses the SAR (successive approximation register) principle, by which the conversion is performed in several steps. The number of conversion steps is equal to the number of bits in the ADC converter. Each step is driven by the ADC clock. Each ADC clock produces one bit from result to output. The ADC internal design is based on the switched-capacitor technique. Basic schematic of SAR switched-capacitor ADC How to get the best ADC accuracy Reduce the effects of ADC-related ADC errors Offset and gain errors can be easily compensated using the STM32 ADC self-calibration feature or by microcontroller firmware. Minimize ADC errors related to external environment of ADC It is recommended to connect capacitors with good high-frequency characteristics between the power and ground lines. That is, a 0.1 \u00b5F and a 1 to 10 \u00b5F capacitor should be placed close to the power source. In most STM32 microcontrollers, the VDD and VSS pins are placed close to each other. So are the VREF+ and VSSA pins. A capacitor can therefore be connected very close to the microcontroller with very short leads. For multiple VDD and VSS pins, use separate decoupling capacitors. 5. Platform API Manual \u2693\ufe0e When using a software platform as a base for application development, the API manual document provides the usage and use case of available functions, settings, and parameters. STM32 MCUs come with Hardware Abstract Layer (HAL) and Low-Layer (LL) library which are used in code generation from CubeMX. Excerpt from UM1785 - Description of STM32F0 HAL and low-layer drivers GPIO Firmware driver API description Enable the GPIO AHB clock using the following function __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using \u201cMode\u201d member from GPIO_InitTypeDef structure Activate Pull-up, Pull-down resistor using \u201cPull\u201d member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through \u201cSpeed\u201d member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through \u201cAlternate\u201d member from GPIO_InitTypeDef structure. Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event selection the \u201cMode\u201d member from GPIO_InitTypeDef structure select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit() allows to set register values to their reset value. It\u2019s also recommended to use it to un-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() / HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG/SWD pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 , respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function. 6. Mainboard schematic \u2693\ufe0e It is better to get a schematic of the board which is under the development, to know the correct signal level and characteristic. Mainboard schematic provides the following: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors, test point) Working conditions (Power level, Voltage Level tolerance) When downloading schematic from ST, please check the version of hardware on the board, such as MB1034B . In old Manual Document, there is a section for schematic. Excerpt from MB1034 - STM32F0DISCOVERY schematic STMF0DISCOVERY schematic 7. Board-specific document \u2693\ufe0e When using an official board from ST, there are some board-specific documents provided to users: Peripheral firmware example Migration and compatibility guidelines 8. Application integration \u2693\ufe0e When using RTOS or other application later, it is recommended to read their guides and API documents. For example: UM1722 - Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process. 9. Source Code \u2693\ufe0e Reading a source code and understanding how it works is one of a good way to know about the target system. There are comments in the source code too, and they usually explain about a corner case, issue, or the particular purpose of the implementation. 10. Website \u2693\ufe0e Yep, search on the internet, read them all, sometime ask people, and try to answer other\u2019s question. All those actions can help in learning not only programming but also other fields.","title":"Documents"},{"location":"blog/stm32/docs/#1-the-datasheet","text":"This document contains highlight of the target microprocessor with main features and capabilities. Many people are confused with Reference Manual, but when comparing the content, they are written for different purpose. This document is helpful when designing a PCB. It gives recommended layout for things like signal characteristic, NRST pin, ADC pins, Boot mode, etc. Datasheet provides the following: General description including product line, speed, memory, operating voltage, temperature range Device overview with block diagram, available peripherals and functions Pinouts and pin descriptions Memory map and memory ranges Electrical Characteristics Package information, for modeling PCB footprints Ordering Information Excerpt from DS8668 - STM32F051x4 STM32F051x6 STM32F051x8 Datasheet The block diagram of STM32F051xx Boot modes At startup, the boot pin and boot selector option bit are used to select one of the three boot options: boot from User Flash memory boot from System Memory boot from embedded SRAM The boot loader is located in System Memory. It is used to reprogram the Flash memory by using USART on pins PA14 / PA15 or PA9 / PA10 . Pinout table I/O structure with marker FT for 5V-tolerant I/O, TT or TC for 3.3V-only I/O. Unless otherwise specified by a note, all I/Os are set as floating inputs during and after reset. The pinout description Alternate functions Memory map and boundary address Operation condition Speed modes on IO","title":"1. The Datasheet"},{"location":"blog/stm32/docs/#2-the-reference-manual","text":"This is by far the most important document in order to program the target device. It defines all information about the core and peripheral at register level with bit-by-bit description. By using only this document, developer still can program the chip without any higher level API - usually called Bare-metal programming. Reference Manual provides the following: System Architecture with bus, peripherals, and connections Memory map and boundary address Boot configuration and vector table relocation Peripheral with details features, descriptions, and structure Register name and bit-fields for all accessible registers Code examples using CMSIS header files Excerpt from RM0091 - STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM\u00ae-based 32-bit MCUs System architecture for STM32F0x Boot modes The boot mode configuration is latched on the 4 th rising edge of SYSCLK after a reset, and is also re-sampled when exiting from Standby mode. After this startup delay has elapsed, the CPU always fetches the top-of-stack value from address 0x00000000 , then starts code execution from the boot memory at 0x00000004 . Depending on the selected boot mode, main Flash memory, system memory or SRAM is accessible as follows: Boot from main Flash memory: the main Flash memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space 0x08000000 . Boot from system memory: the system memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space ( 0x1FFFEC00 on STM32F03x and STM32F05x devices, 0x1FFFC400 on STM32F04x devices, 0x1FFFC800 on STM32F07x and 0x1FFFD800 on STM32F09x devices). Boot from the embedded SRAM: the SRAM is aliased in the boot memory space 0x00000000 , but it is still accessible from its original memory space 0x20000000 . Physical remap For application code which is located in a different address than 0x08000000 , some additional code must be added in order to be able to serve the application interrupts. A solution will be to relocate by software the vector table to the internal SRAM, at the initialization phase: Copy the vector table from the Flash (mapped at the base of the application load address) to the base address of the SRAM at 0x20000000 Remap SRAM at address 0x00000000 , using SYSCFG configuration register 1 Embedded boot loader The embedded boot loader is located in the System memory, programmed by ST during production. It is used to reprogram the Flash memory using one of the following serial interfaces: USART on pins PA14 / PA15 or PA9 / PA10 I2C on pins PB6 / PB7 (STM32F04xxx, STM32F07xxx and STM32F09xxx devices only) USB DFU interface (STM32F04xxx and STM32F07xxx devices only) Debug pin During and just after reset, the alternate functions are not active and most of the I/O ports are configured in input floating mode, except the debug pins are in AF mode immediately: PA14 : SWCLK in pull-down PA13 : SWDIO in pull-up The clock paths Example code USART transmitter configuration: /* (1) Oversampling by 16, 9600 baud */ /* (2) 8 data bit, 1 start bit, 1 stop bit, no parity */ USART1 -> BRR = 480000 / 96 ; /* (1) */ USART1 -> CR1 = USART_CR1_TE | USART_CR1_UE ; /* (2) */ USART transfer: if (( USART1 -> ISR & USART_ISR_TC ) == USART_ISR_TC ) { if ( send == sizeof ( stringtosend )) { send = 0 ; USART1 -> ICR |= USART_ICR_TCCF ; /* Clear transfer complete flag */ } else { /* clear transfer complete flag and fill TDR with a new char */ USART1 -> TDR = stringtosend [ send ++ ]; } } The structure of an IO pin","title":"2. The Reference Manual"},{"location":"blog/stm32/docs/#3-programming-manual","text":"This programming manual provides information for application and system-level software developers. It gives a full description of the STM32 Cortex\u2122-M0 processor programming model, instruction set and core peripherals. Programming Manual provides the following: Processor Modes, Stacks Memory model Exception model, the Vector table and the interrupt service routines Fault handling Power management: enter Sleep mode, Wake up The Instruction Set CMSIS intrinsic functions Core Peripherals: Memory Protection Unit (MPU) Nested vectored interrupt controller (NVIC) System control block (SCB) SysTick timer (STK) Excerpt from PM0215 - STM32F0xxx Cortex-M0 programming manual Processor modes Thread mode: Used to execute application software. The processor enters Thread mode when it comes out of reset Handler mode: Used to handle exceptions. The processor returns to Thread mode when it has finished exception processing. Registers Stacks The processor uses a full descending stack. This means the stack pointer indicates the last stacked item on the stack memory. The processor implements two stacks, with independent copies of the stack pointer: The main stack and The process stack In Thread mode, the CONTROL register controls whether the processor uses the main stack or the process stack: 0 : Main Stack Pointer (MSP)(reset value). On reset, the processor loads the MSP with the value from address 0x00000000 . 1 : Process Stack Pointer (PSP). In Handler mode, the processor always uses the main stack. Memory endianness The processor views memory in little-endian format. It stores the least significant byte (lsbyte) of a word at the lowest-numbered byte, and the most significant byte (msbyte) at the highest-numbered byte. The Little-Endian memory layout The exception types Vector table On system reset, the vector table is fixed at address 0x00000000 . The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code. The exception vector table","title":"3. Programming Manual"},{"location":"blog/stm32/docs/#4-application-note","text":"There many Application Note documents provided by ST. Each document present the usage, design, and advice for a specific application or feature. Application Note provides the following: Peripherals architecture in hardware and software Operation characteristic Excerpt from AN2548 - Using the STM32F0/F1/F3/Gx/Lx Series DMA controller DMA transfer timing For the case where only one DMA channel is active, a new hardware back-to-back request can not be handled by the DMA before the completion of the previous one, adding one AHB clock cycle for the final idle phase of the DMA request-acknowledge handshake protocol. DMA Block diagram When more than one channel is requesting a DMA transfer, the DMA request arbitration can be performed meanwhile the two last cycles of when the AHB bus is accessed by the DMA. Request arbitration overhead is then masked by the AHB bus transfer time. In case not only two channels, but two DMA controllers are used (in products that offer this possibility), two DMA transfers can be processed in parallel, as long as they are not conflicting within the bus matrix, not accessing the same slave device. Timing of Two DMA channel on AHB Bus Excerpt from AN2834 - How to get the best ADC accuracy in STM32 microcontrollers SAR ADC internal structure The ADC embedded in STM32 microcontrollers uses the SAR (successive approximation register) principle, by which the conversion is performed in several steps. The number of conversion steps is equal to the number of bits in the ADC converter. Each step is driven by the ADC clock. Each ADC clock produces one bit from result to output. The ADC internal design is based on the switched-capacitor technique. Basic schematic of SAR switched-capacitor ADC How to get the best ADC accuracy Reduce the effects of ADC-related ADC errors Offset and gain errors can be easily compensated using the STM32 ADC self-calibration feature or by microcontroller firmware. Minimize ADC errors related to external environment of ADC It is recommended to connect capacitors with good high-frequency characteristics between the power and ground lines. That is, a 0.1 \u00b5F and a 1 to 10 \u00b5F capacitor should be placed close to the power source. In most STM32 microcontrollers, the VDD and VSS pins are placed close to each other. So are the VREF+ and VSSA pins. A capacitor can therefore be connected very close to the microcontroller with very short leads. For multiple VDD and VSS pins, use separate decoupling capacitors.","title":"4. Application Note"},{"location":"blog/stm32/docs/#5-platform-api-manual","text":"When using a software platform as a base for application development, the API manual document provides the usage and use case of available functions, settings, and parameters. STM32 MCUs come with Hardware Abstract Layer (HAL) and Low-Layer (LL) library which are used in code generation from CubeMX. Excerpt from UM1785 - Description of STM32F0 HAL and low-layer drivers GPIO Firmware driver API description Enable the GPIO AHB clock using the following function __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using \u201cMode\u201d member from GPIO_InitTypeDef structure Activate Pull-up, Pull-down resistor using \u201cPull\u201d member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through \u201cSpeed\u201d member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through \u201cAlternate\u201d member from GPIO_InitTypeDef structure. Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event selection the \u201cMode\u201d member from GPIO_InitTypeDef structure select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit() allows to set register values to their reset value. It\u2019s also recommended to use it to un-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() / HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG/SWD pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 , respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.","title":"5. Platform API Manual"},{"location":"blog/stm32/docs/#6-mainboard-schematic","text":"It is better to get a schematic of the board which is under the development, to know the correct signal level and characteristic. Mainboard schematic provides the following: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors, test point) Working conditions (Power level, Voltage Level tolerance) When downloading schematic from ST, please check the version of hardware on the board, such as MB1034B . In old Manual Document, there is a section for schematic. Excerpt from MB1034 - STM32F0DISCOVERY schematic STMF0DISCOVERY schematic","title":"6. Mainboard schematic"},{"location":"blog/stm32/docs/#7-board-specific-document","text":"When using an official board from ST, there are some board-specific documents provided to users: Peripheral firmware example Migration and compatibility guidelines","title":"7. Board-specific document"},{"location":"blog/stm32/docs/#8-application-integration","text":"When using RTOS or other application later, it is recommended to read their guides and API documents. For example: UM1722 - Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS - Cortex Microcontroller Software Interface Standard ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or toolchain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process.","title":"8. Application integration"},{"location":"blog/stm32/docs/#9-source-code","text":"Reading a source code and understanding how it works is one of a good way to know about the target system. There are comments in the source code too, and they usually explain about a corner case, issue, or the particular purpose of the implementation.","title":"9. Source Code"},{"location":"blog/stm32/docs/#10-website","text":"Yep, search on the internet, read them all, sometime ask people, and try to answer other\u2019s question. All those actions can help in learning not only programming but also other fields.","title":"10. Website"},{"location":"blog/stm32/gpio/","text":"Blink LED with Button Button interrupt GPIO notes Enable clock source on GPIO port when use it APB2 bus speed determines the sampling rate of all GPIO inputs Can select mode, speed, alternative function on a GPIO pin Can have external interruption Can lock a GPIO after initializing Disconnect a GPIO pin by setting it into input floating mode Save power by setting GPIO pins to Analog mode ( Schmitt trigger is disabled) 1. Hardware \u2693\ufe0e Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt trigger to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure 1.1. Voltage and Current \u2693\ufe0e Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet. 1.2. Input mode \u2693\ufe0e Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins. 1.3. Output mode \u2693\ufe0e Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions. 1.4. Output Speed \u2693\ufe0e GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes 1.5. Bit atomic operation \u2693\ufe0e There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register (BSRR) to select individual bit operation. 1.6. Input interrupt \u2693\ufe0e When in input mode, all ports have external interrupt capability. Read more about Interrupt . 1.7. Alternate function \u2693\ufe0e Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF). 1.8. Analog input/output \u2693\ufe0e In analog mode, pin is directly wired to a analog module (ADC, DAC) 1.9. Locking pin \u2693\ufe0e The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset. 2. STM32Cube HAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows to set register values to their reset value. It\u2019s also recommended to use it to unconfigure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function. 3. Lab 1: Blink Led \u2693\ufe0e Requirement An LED and a Push button Blink the LED every 100ms when press and hold a button Blink the LED every 500ms when the button is released Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board will be used, the schematic shows below connection: STM32F051R8 Mode External peripheral PC8 Output Push Pull, No Pull-up and No Pull-down Blue LED PA0 Input, No Pull-up and No Pull-down Push button, active High The Blue LED and the Push button on STM32F0 Discovery board 3.1. Setup new project \u2693\ufe0e Before starting to write code to blink the LED, there are some steps need to be done to set up the MCU. It is easy to do with support from CubeMX. Select the MCU The STM32F0 Discovery board has STM32F051R8 MCU. Set up clocks Under the Clock Configuration tab: PLL Source is HSI , with PLL Multiplier is 12 Set HCLK to 48 MHz Set up debugger To program code to the target MCU, go to the System Core under the Pinout & Configuration tab to select SYS module: Enable Debug Serial Wire This will automatically assign PA14 to SWCLK and PA13 to SWDIO, which are pins to communicate with debugger on SWD interface 3.2. Setup LED and Button \u2693\ufe0e Under the Pinout View, Left-click on PC8 and set as a GPIO_Output , on PA0 and set as a GPIO_Input . Right-click on these pins to set new name for them, such as LED and BUTTON . Set GPIO mode for pins 3.3. Generated source code \u2693\ufe0e Save the CubeMX settings by Ctrl + S ,and then press Alt + K to start generating source code. Custom defines Any custom name for a pin will be defined in main.h : main.h #define BUTTON_Pin GPIO_PIN_0 #define BUTTON_GPIO_Port GPIOA #define LED_Pin GPIO_PIN_8 #define LED_GPIO_Port GPIOC Init functions In the main.c , IDE generates SystemClock_Config() to setup system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_INPUT ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pin : LED_Pin */ GPIO_InitStruct . Pin = LED_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( LED_GPIO_Port , & GPIO_InitStruct ); } 3.4. User code \u2693\ufe0e Add some lines of code to implement the application requirements in the main while loop. Note that, the button is active high, it means if the button is pressed, it pulls the input pin to a High logic level. int main ( void ) { while ( 1 ) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 100 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 100 ); } else { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 500 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 500 ); } } } 3.5. Download to the board \u2693\ufe0e After compiling, download the firmware to the board and observe the LED in action with the button. There is some delay between the blink pattern (500ms to 100ms), because in current source code, the delay function prevents MCU to react immediately to user\u2019s action. 4. Lab 2: Button interrupt \u2693\ufe0e Requirement An LED and A Push button Press on the button to toggle and print out the number of raising edges Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board with the connection being the same as the previous lab. 4.1. Setup new project \u2693\ufe0e Start a new project in the same steps described in the previous section. 4.2. Setup external interrupt \u2693\ufe0e To detect the raising edge, button has to be configured as an External Interrupt Mode with Raising Edge trigger detection . To enable interrupt, under the NVIC tab, check on the EXTI line 0 and line 1 interrupt option. Enable External Interrupt mode on the button pin 4.3. Generated code \u2693\ufe0e Note that the generated function to setup GPIO has changed to configure Button pin to interrupt mode, and enable the external interrupt line. Read more in Interrupt . static void MX_GPIO_Init ( void ) { ... /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); ... HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } In the file stm32f0xx_it.c , there is an implementation of the interrupt handler EXTI0_1_IRQHandler() which calls to HAL function HAL_GPIO_EXTI_IRQHandler() to clear the pending interrupt flag and finally transfer the work to user\u2019s application if there is an overridden function HAL_GPIO_EXTI_Callback() . 4.4. Handler interrupt \u2693\ufe0e As mentioned above, the HAL_GPIO_EXTI_Callback() will be called to transfer the right to user\u2019s application to handle the interrupt. Firstly, whenever the rasing edge is detected, the callback will be called to increase a counter: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } Inside the main while loop, just repeatedly delay in 1000ms. int main () { while ( 1 ) { HAL_Delay ( 1000 ); } } Run the program, and slowly press the button, the LED sometimes does not toggle the state. Using a logic analyser to see that The logic level is unstable during the transition, it causes multiple rasing and falling edge before coming to stable. This is called Bouncing input . To eliminate it, debounce the input by additional hardware or an internal timer. Bouncing input on button","title":"GPIO"},{"location":"blog/stm32/gpio/#1-hardware","text":"Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt trigger to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure","title":"1. Hardware"},{"location":"blog/stm32/gpio/#11-voltage-and-current","text":"Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet.","title":"1.1. Voltage and Current"},{"location":"blog/stm32/gpio/#12-input-mode","text":"Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins.","title":"1.2. Input mode"},{"location":"blog/stm32/gpio/#13-output-mode","text":"Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions.","title":"1.3. Output mode"},{"location":"blog/stm32/gpio/#14-output-speed","text":"GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes","title":"1.4. Output Speed"},{"location":"blog/stm32/gpio/#15-bit-atomic-operation","text":"There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register (BSRR) to select individual bit operation.","title":"1.5. Bit atomic operation"},{"location":"blog/stm32/gpio/#16-input-interrupt","text":"When in input mode, all ports have external interrupt capability. Read more about Interrupt .","title":"1.6. Input interrupt"},{"location":"blog/stm32/gpio/#17-alternate-function","text":"Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF).","title":"1.7. Alternate function"},{"location":"blog/stm32/gpio/#18-analog-inputoutput","text":"In analog mode, pin is directly wired to a analog module (ADC, DAC)","title":"1.8. Analog input/output"},{"location":"blog/stm32/gpio/#19-locking-pin","text":"The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset.","title":"1.9. Locking pin"},{"location":"blog/stm32/gpio/#2-stm32cube-hal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows to set register values to their reset value. It\u2019s also recommended to use it to unconfigure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.","title":"2. STM32Cube HAL Usage"},{"location":"blog/stm32/gpio/#3-lab-1-blink-led","text":"Requirement An LED and a Push button Blink the LED every 100ms when press and hold a button Blink the LED every 500ms when the button is released Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board will be used, the schematic shows below connection: STM32F051R8 Mode External peripheral PC8 Output Push Pull, No Pull-up and No Pull-down Blue LED PA0 Input, No Pull-up and No Pull-down Push button, active High The Blue LED and the Push button on STM32F0 Discovery board","title":"3. Lab 1: Blink Led"},{"location":"blog/stm32/gpio/#31-setup-new-project","text":"Before starting to write code to blink the LED, there are some steps need to be done to set up the MCU. It is easy to do with support from CubeMX. Select the MCU The STM32F0 Discovery board has STM32F051R8 MCU. Set up clocks Under the Clock Configuration tab: PLL Source is HSI , with PLL Multiplier is 12 Set HCLK to 48 MHz Set up debugger To program code to the target MCU, go to the System Core under the Pinout & Configuration tab to select SYS module: Enable Debug Serial Wire This will automatically assign PA14 to SWCLK and PA13 to SWDIO, which are pins to communicate with debugger on SWD interface","title":"3.1. Setup new project"},{"location":"blog/stm32/gpio/#32-setup-led-and-button","text":"Under the Pinout View, Left-click on PC8 and set as a GPIO_Output , on PA0 and set as a GPIO_Input . Right-click on these pins to set new name for them, such as LED and BUTTON . Set GPIO mode for pins","title":"3.2. Setup LED and Button"},{"location":"blog/stm32/gpio/#33-generated-source-code","text":"Save the CubeMX settings by Ctrl + S ,and then press Alt + K to start generating source code. Custom defines Any custom name for a pin will be defined in main.h : main.h #define BUTTON_Pin GPIO_PIN_0 #define BUTTON_GPIO_Port GPIOA #define LED_Pin GPIO_PIN_8 #define LED_GPIO_Port GPIOC Init functions In the main.c , IDE generates SystemClock_Config() to setup system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_INPUT ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pin : LED_Pin */ GPIO_InitStruct . Pin = LED_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( LED_GPIO_Port , & GPIO_InitStruct ); }","title":"3.3. Generated source code"},{"location":"blog/stm32/gpio/#34-user-code","text":"Add some lines of code to implement the application requirements in the main while loop. Note that, the button is active high, it means if the button is pressed, it pulls the input pin to a High logic level. int main ( void ) { while ( 1 ) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 100 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 100 ); } else { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 500 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 500 ); } } }","title":"3.4. User code"},{"location":"blog/stm32/gpio/#35-download-to-the-board","text":"After compiling, download the firmware to the board and observe the LED in action with the button. There is some delay between the blink pattern (500ms to 100ms), because in current source code, the delay function prevents MCU to react immediately to user\u2019s action.","title":"3.5. Download to the board"},{"location":"blog/stm32/gpio/#4-lab-2-button-interrupt","text":"Requirement An LED and A Push button Press on the button to toggle and print out the number of raising edges Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board with the connection being the same as the previous lab.","title":"4. Lab 2: Button interrupt"},{"location":"blog/stm32/gpio/#41-setup-new-project","text":"Start a new project in the same steps described in the previous section.","title":"4.1. Setup new project"},{"location":"blog/stm32/gpio/#42-setup-external-interrupt","text":"To detect the raising edge, button has to be configured as an External Interrupt Mode with Raising Edge trigger detection . To enable interrupt, under the NVIC tab, check on the EXTI line 0 and line 1 interrupt option. Enable External Interrupt mode on the button pin","title":"4.2. Setup external interrupt"},{"location":"blog/stm32/gpio/#43-generated-code","text":"Note that the generated function to setup GPIO has changed to configure Button pin to interrupt mode, and enable the external interrupt line. Read more in Interrupt . static void MX_GPIO_Init ( void ) { ... /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); ... HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } In the file stm32f0xx_it.c , there is an implementation of the interrupt handler EXTI0_1_IRQHandler() which calls to HAL function HAL_GPIO_EXTI_IRQHandler() to clear the pending interrupt flag and finally transfer the work to user\u2019s application if there is an overridden function HAL_GPIO_EXTI_Callback() .","title":"4.3. Generated code"},{"location":"blog/stm32/gpio/#44-handler-interrupt","text":"As mentioned above, the HAL_GPIO_EXTI_Callback() will be called to transfer the right to user\u2019s application to handle the interrupt. Firstly, whenever the rasing edge is detected, the callback will be called to increase a counter: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } Inside the main while loop, just repeatedly delay in 1000ms. int main () { while ( 1 ) { HAL_Delay ( 1000 ); } } Run the program, and slowly press the button, the LED sometimes does not toggle the state. Using a logic analyser to see that The logic level is unstable during the transition, it causes multiple rasing and falling edge before coming to stable. This is called Bouncing input . To eliminate it, debounce the input by additional hardware or an internal timer. Bouncing input on button","title":"4.4. Handler interrupt"},{"location":"blog/stm32/interrupt/","text":"1. NVIC Controller \u2693\ufe0e Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines External Interrupt lines External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIOs, an EXTI line is shared by multiple pins. In one line (group), only one pin can be set to generate interrupt, and software must be able to discriminate which lines generated the interrupt. The external interrupt can be fired on rising edge , or falling edge , or both . Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC) . Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU startup_*.s . startup_stm32f051r8tx.s g_pfnVectors : . word _estack . word Reset_Handler . word NMI_Handler . word HardFault_Handler . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word SVC_Handler . word 0 . word 0 . word PendSV_Handler . word SysTick_Handler . word WWDG_IRQHandler /* Window WatchDog */ . word PVD_IRQHandler /* PVD through EXTI Line detect */ . word RTC_IRQHandler /* RTC through the EXTI line */ . word FLASH_IRQHandler /* FLASH */ . word RCC_CRS_IRQHandler /* RCC and CRS */ . word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ . word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ . word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ . word TSC_IRQHandler /* TSC */ . word DMA1_Channel1_IRQHandler /* DMA1 Channel 1 */ . word DMA1_Channel2_3_IRQHandler /* DMA1 Channel 2 and Channel 3 */ . word DMA1_Channel4_5_IRQHandler /* DMA1 Channel 4 and Channel 5 */ . word ADC1_COMP_IRQHandler /* ADC1, COMP1 and COMP2 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break/Update/Trigger/Commutation */ . word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ . word TIM2_IRQHandler /* TIM2 */ . word TIM3_IRQHandler /* TIM3 */ . word TIM6_DAC_IRQHandler /* TIM6 and DAC */ . word 0 /* Reserved */ . word TIM14_IRQHandler /* TIM14 */ . word TIM15_IRQHandler /* TIM15 */ . word TIM16_IRQHandler /* TIM16 */ . word TIM17_IRQHandler /* TIM17 */ . word I2C1_IRQHandler /* I2C1 */ . word I2C2_IRQHandler /* I2C2 */ . word SPI1_IRQHandler /* SPI1 */ . word SPI2_IRQHandler /* SPI2 */ . word USART1_IRQHandler /* USART1 */ . word USART2_IRQHandler /* USART2 */ . word 0 /* Reserved */ . word CEC_CAN_IRQHandler /* CEC and CAN */ . word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x00000000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x08000000 address, it is placed starting from the 0x08000000 address, which is aliased to 0x00000000 when the CPU boots up. Read about the Boot mode in the Reference Manual Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores 2. Processor Mode \u2693\ufe0e The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode : Which is entered on reset, and application run on this mode. Handler Mode : Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context (registers, flags) Allows late determination of highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining) 3. Preemption \u2693\ufe0e The Preemption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be Preempted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can Preempt it. Lower priority level has higher priority of execution. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 Preempted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 Preempted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Preemption allow IRQ1 to be executed 4. Interrupts Tail-Chaining \u2693\ufe0e When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing 5. Interrupt Late Arrival \u2693\ufe0e The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception. 6. Interrupt Lifecycle \u2693\ufe0e An interrupt can: either be disabled (default behavior) or enabled ; either be pending (a request is waiting to be served) or not pending ; either be in an active (being served) or inactive state. When an interrupt fires, it is marked as pending until the processor can serve it. If no other interrupts are currently being processed, its pending state is automatically cleared by the processor, then it starts get served. ISR A then ISR B The lower priority ISR has to wait in pending state until no higher priority ISR is being processed. It can be put into inactive state when it is Preemptied by a higher priority ISR. ISR A Preemp ISR B An interrupt can be forced to fire again during its execution, simply setting its pending bit again. In the same way, the execution of an interrupt can be canceled clearing its pending bit while it is in pending state ISR A then ISR A ISR B canceled 7. Reset Behavior \u2693\ufe0e When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00000000 which contains the end address of RAM _estack The reset handler address is loaded from address 0x00000004 . The reset handler gets executed in thread mode. The reset handler branches to the main program. 8. Exception Behavior \u2693\ufe0e When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns back to main (assuming no further nesting). Here is more details: 1. Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. 2. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers 3. Return From ISR (Context Restoration) Detect tail-chaining interrupt, if have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles 9. The Peripheral Pending bit \u2693\ufe0e When an interrupt takes place, the most of STM32 peripherals assert a specific signal connected to the NVIC, which is mapped in the peripheral memory through a dedicated bit. This Peripheral Pending bit will be held high until it is manually cleared by the application code. The ISR Pending bit is different to the Peripheral Pending bit. When the processor starts servicing the ISR, the ISR pending bit is cleared automatically, but the peripheral IRQ pending bit will be held high until it is cleared by the application code. If the Peripheral Pending bit is not clear, the interrupt will be fired again and the ISR will run again It is able to manually set the Peripheral Pending bit to force the ISR run External Peripheral Pending set Manually Peripheral Pending set 10. Configure Interrupts \u2693\ufe0e After a reset: When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. When configuring a peripheral to work in Interrupt mode, the user application has to: Enable interrupt on the interrupt line, e.g. pin PA0 on the EXTI0 line Implement the interrupt handler which is declared in the startup file, e.g. EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed 11. CubeMX Usage \u2693\ufe0e NVIC can be configured using CubeMX, in the Pinout & Configuration tab. This screen list all interrupts in the system and provides options to setup interrupts: Enable or Disable an interrupt: as mentioned above, some interrupts are always enabled, such as NMI, Hard fault, SVC. Note that CubeMX forces to enable SysTick because HAL needs it to handle delay functions Set Preemption Priority for each interrupt Generate IRQ handlers (in *_it.c ) and call to HAL callbacks those will clear the pending bit, do something, and finally will call to a weak callback which can be overridden by users. Interrupt can be configured in each peripheral setting screen. For example, if user enables an external interrupt on a pin, NVIC tab will be available to quickly enable or disable the peripheral interrupt. NVIC configuration in CubeMX 12. STM32Cube HAL Usage \u2693\ufe0e To enable an IRQ, the CubeHAL provides the following function: void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ); where the IRQn_Type is an enumeration of all exceptions and interrupts defined for that specific MCU. The IRQn_Type enum is part of the ST Device HAL, and it is defined inside a header file specific for the given STM32 MCU named stm32fxxxx.h . For example, for an STM32F030R8 MCU the right filename is stm32f030x8.h (the pattern name of these files is the same of start-up files). The corresponding function to disable an IRQ is the: void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ); Note that the above function enable the interrupt line at the NVIC level. A single peripheral must be properly configured to work in interrupt mode to cause it assert the corresponding peripheral interrupt level. Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping() function if using Group Priority, then use HAL_NVIC_SetPriority() to set the priority of the selected IRQ. When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. The pending IRQ priority will be managed only by the sub priority. Since the presence of the IRQ pending bit is peripheral dependent, it is a good design practice to clear peripherals IRQ pending status bit as their ISR start to be serviced. The processor core does not keep track of multiple interrupts (it does not queue interrupts), so if clearing the peripheral pending bit at the end of an ISR may lose important IRQs that fire in the middle. To see if an interrupt is pending (that is, fired but not running): uint32_t HAL_NVIC_GetPendingIRQ ( IRQn_Type IRQn ); To programmatically set the pending bit of an IRQ which causes the interrupt to fire, as it would be generated by the hardware: void HAL_NVIC_SetPendingIRQ ( IRQn_Type IRQn ); Instead, to programmatically clear the pending bit of an IRQ void HAL_NVIC_ClearPendingIRQ ( IRQn_Type IRQn ); To check if an ISR is active (IRQ being serviced): uint32_t HAL_NVIC_GetActive ( IRQn_Type IRQn );","title":"Interrupt"},{"location":"blog/stm32/interrupt/#1-nvic-controller","text":"Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines External Interrupt lines External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIOs, an EXTI line is shared by multiple pins. In one line (group), only one pin can be set to generate interrupt, and software must be able to discriminate which lines generated the interrupt. The external interrupt can be fired on rising edge , or falling edge , or both . Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC) . Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU startup_*.s . startup_stm32f051r8tx.s g_pfnVectors : . word _estack . word Reset_Handler . word NMI_Handler . word HardFault_Handler . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word SVC_Handler . word 0 . word 0 . word PendSV_Handler . word SysTick_Handler . word WWDG_IRQHandler /* Window WatchDog */ . word PVD_IRQHandler /* PVD through EXTI Line detect */ . word RTC_IRQHandler /* RTC through the EXTI line */ . word FLASH_IRQHandler /* FLASH */ . word RCC_CRS_IRQHandler /* RCC and CRS */ . word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ . word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ . word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ . word TSC_IRQHandler /* TSC */ . word DMA1_Channel1_IRQHandler /* DMA1 Channel 1 */ . word DMA1_Channel2_3_IRQHandler /* DMA1 Channel 2 and Channel 3 */ . word DMA1_Channel4_5_IRQHandler /* DMA1 Channel 4 and Channel 5 */ . word ADC1_COMP_IRQHandler /* ADC1, COMP1 and COMP2 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break/Update/Trigger/Commutation */ . word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ . word TIM2_IRQHandler /* TIM2 */ . word TIM3_IRQHandler /* TIM3 */ . word TIM6_DAC_IRQHandler /* TIM6 and DAC */ . word 0 /* Reserved */ . word TIM14_IRQHandler /* TIM14 */ . word TIM15_IRQHandler /* TIM15 */ . word TIM16_IRQHandler /* TIM16 */ . word TIM17_IRQHandler /* TIM17 */ . word I2C1_IRQHandler /* I2C1 */ . word I2C2_IRQHandler /* I2C2 */ . word SPI1_IRQHandler /* SPI1 */ . word SPI2_IRQHandler /* SPI2 */ . word USART1_IRQHandler /* USART1 */ . word USART2_IRQHandler /* USART2 */ . word 0 /* Reserved */ . word CEC_CAN_IRQHandler /* CEC and CAN */ . word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x00000000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x08000000 address, it is placed starting from the 0x08000000 address, which is aliased to 0x00000000 when the CPU boots up. Read about the Boot mode in the Reference Manual Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores","title":"1. NVIC Controller"},{"location":"blog/stm32/interrupt/#2-processor-mode","text":"The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode : Which is entered on reset, and application run on this mode. Handler Mode : Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context (registers, flags) Allows late determination of highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining)","title":"2. Processor Mode"},{"location":"blog/stm32/interrupt/#3-preemption","text":"The Preemption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be Preempted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can Preempt it. Lower priority level has higher priority of execution. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 Preempted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 Preempted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Preemption allow IRQ1 to be executed","title":"3. Preemption"},{"location":"blog/stm32/interrupt/#4-interrupts-tail-chaining","text":"When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing","title":"4. Interrupts Tail-Chaining"},{"location":"blog/stm32/interrupt/#5-interrupt-late-arrival","text":"The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception.","title":"5. Interrupt Late Arrival"},{"location":"blog/stm32/interrupt/#6-interrupt-lifecycle","text":"An interrupt can: either be disabled (default behavior) or enabled ; either be pending (a request is waiting to be served) or not pending ; either be in an active (being served) or inactive state. When an interrupt fires, it is marked as pending until the processor can serve it. If no other interrupts are currently being processed, its pending state is automatically cleared by the processor, then it starts get served. ISR A then ISR B The lower priority ISR has to wait in pending state until no higher priority ISR is being processed. It can be put into inactive state when it is Preemptied by a higher priority ISR. ISR A Preemp ISR B An interrupt can be forced to fire again during its execution, simply setting its pending bit again. In the same way, the execution of an interrupt can be canceled clearing its pending bit while it is in pending state ISR A then ISR A ISR B canceled","title":"6. Interrupt Lifecycle"},{"location":"blog/stm32/interrupt/#7-reset-behavior","text":"When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00000000 which contains the end address of RAM _estack The reset handler address is loaded from address 0x00000004 . The reset handler gets executed in thread mode. The reset handler branches to the main program.","title":"7. Reset Behavior"},{"location":"blog/stm32/interrupt/#8-exception-behavior","text":"When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns back to main (assuming no further nesting). Here is more details: 1. Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. 2. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers 3. Return From ISR (Context Restoration) Detect tail-chaining interrupt, if have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles","title":"8. Exception Behavior"},{"location":"blog/stm32/interrupt/#9-the-peripheral-pending-bit","text":"When an interrupt takes place, the most of STM32 peripherals assert a specific signal connected to the NVIC, which is mapped in the peripheral memory through a dedicated bit. This Peripheral Pending bit will be held high until it is manually cleared by the application code. The ISR Pending bit is different to the Peripheral Pending bit. When the processor starts servicing the ISR, the ISR pending bit is cleared automatically, but the peripheral IRQ pending bit will be held high until it is cleared by the application code. If the Peripheral Pending bit is not clear, the interrupt will be fired again and the ISR will run again It is able to manually set the Peripheral Pending bit to force the ISR run External Peripheral Pending set Manually Peripheral Pending set","title":"9. The Peripheral Pending bit"},{"location":"blog/stm32/interrupt/#10-configure-interrupts","text":"After a reset: When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. When configuring a peripheral to work in Interrupt mode, the user application has to: Enable interrupt on the interrupt line, e.g. pin PA0 on the EXTI0 line Implement the interrupt handler which is declared in the startup file, e.g. EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed","title":"10. Configure Interrupts"},{"location":"blog/stm32/interrupt/#11-cubemx-usage","text":"NVIC can be configured using CubeMX, in the Pinout & Configuration tab. This screen list all interrupts in the system and provides options to setup interrupts: Enable or Disable an interrupt: as mentioned above, some interrupts are always enabled, such as NMI, Hard fault, SVC. Note that CubeMX forces to enable SysTick because HAL needs it to handle delay functions Set Preemption Priority for each interrupt Generate IRQ handlers (in *_it.c ) and call to HAL callbacks those will clear the pending bit, do something, and finally will call to a weak callback which can be overridden by users. Interrupt can be configured in each peripheral setting screen. For example, if user enables an external interrupt on a pin, NVIC tab will be available to quickly enable or disable the peripheral interrupt. NVIC configuration in CubeMX","title":"11. CubeMX Usage"},{"location":"blog/stm32/interrupt/#12-stm32cube-hal-usage","text":"To enable an IRQ, the CubeHAL provides the following function: void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ); where the IRQn_Type is an enumeration of all exceptions and interrupts defined for that specific MCU. The IRQn_Type enum is part of the ST Device HAL, and it is defined inside a header file specific for the given STM32 MCU named stm32fxxxx.h . For example, for an STM32F030R8 MCU the right filename is stm32f030x8.h (the pattern name of these files is the same of start-up files). The corresponding function to disable an IRQ is the: void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ); Note that the above function enable the interrupt line at the NVIC level. A single peripheral must be properly configured to work in interrupt mode to cause it assert the corresponding peripheral interrupt level. Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping() function if using Group Priority, then use HAL_NVIC_SetPriority() to set the priority of the selected IRQ. When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. The pending IRQ priority will be managed only by the sub priority. Since the presence of the IRQ pending bit is peripheral dependent, it is a good design practice to clear peripherals IRQ pending status bit as their ISR start to be serviced. The processor core does not keep track of multiple interrupts (it does not queue interrupts), so if clearing the peripheral pending bit at the end of an ISR may lose important IRQs that fire in the middle. To see if an interrupt is pending (that is, fired but not running): uint32_t HAL_NVIC_GetPendingIRQ ( IRQn_Type IRQn ); To programmatically set the pending bit of an IRQ which causes the interrupt to fire, as it would be generated by the hardware: void HAL_NVIC_SetPendingIRQ ( IRQn_Type IRQn ); Instead, to programmatically clear the pending bit of an IRQ void HAL_NVIC_ClearPendingIRQ ( IRQn_Type IRQn ); To check if an ISR is active (IRQ being serviced): uint32_t HAL_NVIC_GetActive ( IRQn_Type IRQn );","title":"12. STM32Cube HAL Usage"},{"location":"blog/stm32/intro/","text":"1. ARM Cortex-M processors \u2693\ufe0e .red { color: red; } ARM (Advanced RISC Machines) processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revisions. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded 1.1. Core Registers \u2693\ufe0e Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations Processor register set on ARM Cortex-M Microprocessor R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode ( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register. 1.2. Memory Map \u2693\ufe0e ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4GB wide (due to 32-bit address line), and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x00000000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x08000000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x00000000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x08000000 and 0x00000000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512MB is mapped to Internal SRAM: It starts at address 0x20000000 and can potentially extend to 0x3FFFFFFF . This area also can be aliased to the start up address at 0x00000000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different core variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area 1.3. Bit-Banding \u2693\ufe0e In embedded applications, it is quite common to work with a single bit of a word using bit masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x20000000 and ends at 0x200FFFFF , and it is aliased from 0x22000000 to 0x23FFFFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x40000000 and ends at 0x400FFFFF , which is dedicated to the memory mapping of peripherals, from 0x42000000 to 0x43FFFFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area 1.4. Thumb Instruction Set \u2693\ufe0e ARM Cortex-M processors provide a 32-bit instructions set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state. 1.5. Instruction pipeline \u2693\ufe0e Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded. 1.6. Memory alignment \u2693\ufe0e Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations. 1.7. Interrupts and Exceptions \u2693\ufe0e Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request 1.8. System Timer \u2693\ufe0e Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen the be Interrupt Table above. 1.9. Clock source and power mode \u2693\ufe0e Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR) . Run mode : full clock speed, all using peripherals are activated Sleep mode : reduced clock speed, some peripherals are suspended Deep sleep mode : clock is stopped, need external event to wake-up 1.10. CMSIS for SW development \u2693\ufe0e Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE : API for the Cortex-M processor core and peripherals CMSIS-Driver : defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP : API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack : a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD : System View Description for Peripherals CMSIS-DAP : Debug Access Port 2. STM32 Microcontrollers \u2693\ufe0e STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs have a large community, supported by free tool-chain, and is written in many shared knowledge articles The Pin-to-Pin compatibility for most of STM32 MCUs helps to change the MCU while keeping pin assignments Almost pins are 5V tolerant, that means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated boot loader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards 2.1. Cortex-M comparison \u2693\ufe0e A table excerpted from ARM website. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes 2.2. STM32 MCUs comparison \u2693\ufe0e Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 / Corte -M4 480 MHz / 240 MHz 1 to 2 Mbytes STM32F7 Cortex-M7 216 MHz 256 Kbytes to 2 Mbytes STM32F4 Cortex-M4 180 MHz 64 Kbytes to 2 Mbytes STM32F2 Cortex-M3 120 MHz 128 Kbytes to 1 Mbyte Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 Kbytes STM32F3 Cortex-M4 72 MHz 16 to 512 Kbytes STM32F1 Cortex-M3 72 MHz 16 Kbytes to 1 Mbyte STM32G0 Cortex-M0+ 64 MHz 16 to 512 Kbytes STM32F0 Cortex-M0 48 MHz 16 to 256 Kbytes Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 Kbytes STM32L4+ Cortex-M4 120 MHz 512 Kbytes to 2 Mbytes STM32L4 Cortex-M4 80 MHz 64 Kbytes to 1 Mbyte STM32L1 Cortex-M3 32 MHz 32 to 512 Kbytes STM32L0 Cortex-M0+ 32 MHz 8 to 192 Kbytes Wireless STM32WB Cortex-M4 / Cortex-M0+ 64 MHz / 32 MHz 256 Kbytes to 1 Mbyte STM32WL Cortex-M4 48 MHz 64 Kbytes to 256 Kbytes","title":"Introduction"},{"location":"blog/stm32/intro/#1-arm-cortex-m-processors","text":".red { color: red; } ARM (Advanced RISC Machines) processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revisions. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded","title":"1. ARM Cortex-M processors"},{"location":"blog/stm32/intro/#11-core-registers","text":"Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations Processor register set on ARM Cortex-M Microprocessor R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode ( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register.","title":"1.1. Core Registers"},{"location":"blog/stm32/intro/#12-memory-map","text":"ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4GB wide (due to 32-bit address line), and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x00000000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x08000000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x00000000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x08000000 and 0x00000000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512MB is mapped to Internal SRAM: It starts at address 0x20000000 and can potentially extend to 0x3FFFFFFF . This area also can be aliased to the start up address at 0x00000000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different core variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area","title":"1.2. Memory Map"},{"location":"blog/stm32/intro/#13-bit-banding","text":"In embedded applications, it is quite common to work with a single bit of a word using bit masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x20000000 and ends at 0x200FFFFF , and it is aliased from 0x22000000 to 0x23FFFFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x40000000 and ends at 0x400FFFFF , which is dedicated to the memory mapping of peripherals, from 0x42000000 to 0x43FFFFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area","title":"1.3. Bit-Banding"},{"location":"blog/stm32/intro/#14-thumb-instruction-set","text":"ARM Cortex-M processors provide a 32-bit instructions set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state.","title":"1.4. Thumb Instruction Set"},{"location":"blog/stm32/intro/#15-instruction-pipeline","text":"Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded.","title":"1.5. Instruction pipeline"},{"location":"blog/stm32/intro/#16-memory-alignment","text":"Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations.","title":"1.6. Memory alignment"},{"location":"blog/stm32/intro/#17-interrupts-and-exceptions","text":"Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved - Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved - Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request","title":"1.7. Interrupts and Exceptions"},{"location":"blog/stm32/intro/#18-system-timer","text":"Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen the be Interrupt Table above.","title":"1.8. System Timer"},{"location":"blog/stm32/intro/#19-clock-source-and-power-mode","text":"Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR) . Run mode : full clock speed, all using peripherals are activated Sleep mode : reduced clock speed, some peripherals are suspended Deep sleep mode : clock is stopped, need external event to wake-up","title":"1.9. Clock source and power mode"},{"location":"blog/stm32/intro/#110-cmsis-for-sw-development","text":"Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE : API for the Cortex-M processor core and peripherals CMSIS-Driver : defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP : API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack : a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD : System View Description for Peripherals CMSIS-DAP : Debug Access Port","title":"1.10. CMSIS for SW development"},{"location":"blog/stm32/intro/#2-stm32-microcontrollers","text":"STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs have a large community, supported by free tool-chain, and is written in many shared knowledge articles The Pin-to-Pin compatibility for most of STM32 MCUs helps to change the MCU while keeping pin assignments Almost pins are 5V tolerant, that means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated boot loader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards","title":"2. STM32 Microcontrollers"},{"location":"blog/stm32/intro/#21-cortex-m-comparison","text":"A table excerpted from ARM website. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes","title":"2.1. Cortex-M comparison"},{"location":"blog/stm32/intro/#22-stm32-mcus-comparison","text":"Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 / Corte -M4 480 MHz / 240 MHz 1 to 2 Mbytes STM32F7 Cortex-M7 216 MHz 256 Kbytes to 2 Mbytes STM32F4 Cortex-M4 180 MHz 64 Kbytes to 2 Mbytes STM32F2 Cortex-M3 120 MHz 128 Kbytes to 1 Mbyte Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 Kbytes STM32F3 Cortex-M4 72 MHz 16 to 512 Kbytes STM32F1 Cortex-M3 72 MHz 16 Kbytes to 1 Mbyte STM32G0 Cortex-M0+ 64 MHz 16 to 512 Kbytes STM32F0 Cortex-M0 48 MHz 16 to 256 Kbytes Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 Kbytes STM32L4+ Cortex-M4 120 MHz 512 Kbytes to 2 Mbytes STM32L4 Cortex-M4 80 MHz 64 Kbytes to 1 Mbyte STM32L1 Cortex-M3 32 MHz 32 to 512 Kbytes STM32L0 Cortex-M0+ 32 MHz 8 to 192 Kbytes Wireless STM32WB Cortex-M4 / Cortex-M0+ 64 MHz / 32 MHz 256 Kbytes to 1 Mbyte STM32WL Cortex-M4 48 MHz 64 Kbytes to 256 Kbytes","title":"2.2. STM32 MCUs comparison"},{"location":"blog/stm32/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Terminal application \u2693\ufe0e Terminal application Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm Use float with printf and scanf \u2693\ufe0e Use float with printf and scanf The newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project \u00bb Properties menu, then go to C/C++ Build \u00bb Settings \u00bb Cross ARM C++ Linker \u00bb Miscellaneous and check Use float with nano printf/scanf . DMA Polling in a infinite loop \u2693\ufe0e DMA Polling in a infinite loop The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. Force turning off DMA interrupt If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clear the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK . Computer architecture \u2693\ufe0e Computer architecture The most of STM32 MCUs share the same computer architecture except for STM32F0 and STM32L0 that are based on the Cortex-M0/0+ cores. They, in fact, are the only Cortex-M cores based on the von Neumann architecture , compared to the other Cortex-M cores that are based on the (modified) Harvard architecture 1 . The fundamental distinction between the two architectures is that: Cortex-M0/0+ cores access to Flash, SRAM and peripherals using one common bus The other Cortex-M cores have: two separated bus lines for the access to the flash (one for the fetch of instructions called instruction bus, or simply I-Bus or even I-Code, and one for the access to const data called data bus, or simply D-Bus or even D-Code) one dedicated line for the access to SRAM and peripherals (also called system bus, or simply S-Bus). Windows 10 USB to Serial driver \u2693\ufe0e Windows 10 USB to Serial driver Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips. https://en.wikipedia.org/wiki/Modified_Harvard_architecture \u21a9","title":"Notes"},{"location":"blog/stm32/notes/#terminal-application","text":"Terminal application Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm","title":"Terminal application"},{"location":"blog/stm32/notes/#use-float-with-printf-and-scanf","text":"Use float with printf and scanf The newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project \u00bb Properties menu, then go to C/C++ Build \u00bb Settings \u00bb Cross ARM C++ Linker \u00bb Miscellaneous and check Use float with nano printf/scanf .","title":"Use float with printf and scanf"},{"location":"blog/stm32/notes/#dma-polling-in-a-infinite-loop","text":"DMA Polling in a infinite loop The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. Force turning off DMA interrupt If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clear the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK .","title":"DMA Polling in a infinite loop"},{"location":"blog/stm32/notes/#computer-architecture","text":"Computer architecture The most of STM32 MCUs share the same computer architecture except for STM32F0 and STM32L0 that are based on the Cortex-M0/0+ cores. They, in fact, are the only Cortex-M cores based on the von Neumann architecture , compared to the other Cortex-M cores that are based on the (modified) Harvard architecture 1 . The fundamental distinction between the two architectures is that: Cortex-M0/0+ cores access to Flash, SRAM and peripherals using one common bus The other Cortex-M cores have: two separated bus lines for the access to the flash (one for the fetch of instructions called instruction bus, or simply I-Bus or even I-Code, and one for the access to const data called data bus, or simply D-Bus or even D-Code) one dedicated line for the access to SRAM and peripherals (also called system bus, or simply S-Bus).","title":"Computer architecture"},{"location":"blog/stm32/notes/#windows-10-usb-to-serial-driver","text":"Windows 10 USB to Serial driver Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips. https://en.wikipedia.org/wiki/Modified_Harvard_architecture \u21a9","title":"Windows 10 USB to Serial driver"},{"location":"blog/stm32/prepare/","text":"Always use original products when you can afford to buy! 1. Development boards \u2693\ufe0e There are many boards available in the market, which are from the ST, or from a 3 rd party company, or just from a seller. Here are the list of some popular boards for beginners, as they are cheap and easy to buy from a retailer. 1.1. STM32 Nucleo boards \u2693\ufe0e These boards come with a cheap price and an integrated ST-LINK debugger. The advantages of this Nucleo board line is to have access directly to all GPIOs, and to have compliant Arduino connector. Many users who are familiar with Arduino like to use Nucleo boards, because they can keep using these STM32 boards as an Arduino. Starter boards can be: Nucleo-F103RB Nucleo-F401RE/F411RE Nucleo-F103RB Nucleo-H743 1.2. STM32 Discovery kits \u2693\ufe0e This line of board allows either for beginner or for experienced users to get started on new projects. These boards are cheap, and have complete solutions for demonstrating the capabilities of the devices. Some boards come with many peripherals such as LCD, MEM sensors, touch pad. They also have integrated ST-LINK debugger/ programmer. Starter boards can be: STM32F072-Discovery STM32F429-Discovery STM32F072-Discovery STM32F429-Discovery 1.3. Evaluation board \u2693\ufe0e The STM32 Eval boards have been designed as a complete demonstration and development platform for the STM32 MCUs and MPUs. They are meant to be used to execute a comprehensive evaluation of STMicroelectronics solutions. These boards have integrated ST-LINK debugger/ programmer. They carry external circuitry, such as transceivers, sensors, memory interfaces, displays and many more. The evaluation boards can be considered as a reference design for application development. Starter boards can be: STM32L476-EVAL STM32F407-EVAL STM32L476-EVAL STM32F407-EVAL 1.4. Custom board \u2693\ufe0e Many users still find that the price of original boards is still high. There are many clones which use either authorized MCUs or even fake ones, with reduced peripherals. They usually are customized to different starter boards in small size and just USB and debugging pins. The popular custom boards are \u201cBlue Pills\u201d STM32F103, and \u201cBlack Pills\u201d STM32F4x1. They are cheap and have many exposed pins. There is no debugger or programmer in these custom board. Users have to use an external one, such as ST-LINK or J-LINK. A blue pill STM32F103 A black pill STM32Fx1 Power conflict On a custom board, there may be no power protection circuit added, therefore, do not connect 3.3V power pin of the debugger if the USB port is plugged because the USB port already powers the board with 5V. Counterfeit chip There are counterfeit chips on the market that are blocked to work with ST-Link/ J-Link to flash and debug. Please make sure to not buy them, even there is a method to workaround with OpenOCD. 2. Programmer & Debugger \u2693\ufe0e Programmer is used to write application code into MCU. It can read the application and make a copy of the firmware. Debugger is used to read CPU registers, memory, and logging data to help developers see how application runs. It can halt the CPU too. In monitoring mode, it lets CPU run and read memory in background through some special channels to gather information of application and system in real-time. 2.1. ST-LINK \u2693\ufe0e All official boards from ST have integrated ST-Link debugger / programmer in version 2 or 3. They work on a Serial Wire Debug (SWD) interface. ST-Link comes with good performance and some extra feature such as Serial Wire Output (SWO), Virtual COM port, Mass-storage for drag-and-drop programming. On custom boards, there is no on-board debugger, so that an external debugger is needed. There are both original and clone version in the market. Original ST-LINK/V2 A clone of ST-LINK/V2 Missing SWO pin on ST-LINK clones Many ST-LINK clones only expose SWD interface (SWCLK and SWDIO). The pin for SWO is not exposed. There is a quick fix for this problem: wire the PA10 of the on-board STM32 chip to a pin on the header. Read more in Add SWO pin . 2.2. J-LINK \u2693\ufe0e One of a popular debugger manufacturer is SEGGER . They provide many tools for embedded systems. Their J-Link is quite expensive but comes with a lot of high performance features beside standard ones in ST-LINK, such as Real-time logging, system view, profiling. There are also cloned J-Link devices which are actually an STM32F0 MCU running a SEGGER firmware but have limitation in features due to missing hardware component and license. One interesting thing is SEGGER provides a tool to convert ST-LINK/V2 to a J-LINK OB model with some small limitations. J-Link Pro Cloned J-Link OB 3. Power Supplier \u2693\ufe0e There are many ways to power the board. Always check the Voltage and the Maximum Current of the power source. During the development, the board should be powered through the debugger which connects to PC via an USB port. If there is another on-board USB port connecting to PC, do not use power pin on the debugger. In the final production, the board will run without a debugger connected to a host PC, the power can be connected to the USB port or the power pins directly. A portable power source can be a Power bank, or a Li-Po battery. Also keep in mind that if the board would occasionally go to sleep state and the consumption current drops below 50 - 70 mA, many power banks would drop the supply, so the system will shut down catastrophically. 4. Logic Analyser (optional) \u2693\ufe0e A Logic Analyser can captures (and display) multiple signals on a system. The output can be visualized in timing diagrams, and then analyzed or decoded to get detailed information about the signal or the protocol and data. There are small portable Logic Analysers which just do capturing data, and then the captured data is transferred to a host PC via USB. Finally, the data is visualized by an application. Saleae Logic Cloned Logic","title":"Preparation"},{"location":"blog/stm32/prepare/#1-development-boards","text":"There are many boards available in the market, which are from the ST, or from a 3 rd party company, or just from a seller. Here are the list of some popular boards for beginners, as they are cheap and easy to buy from a retailer.","title":"1. Development boards"},{"location":"blog/stm32/prepare/#11-stm32-nucleo-boards","text":"These boards come with a cheap price and an integrated ST-LINK debugger. The advantages of this Nucleo board line is to have access directly to all GPIOs, and to have compliant Arduino connector. Many users who are familiar with Arduino like to use Nucleo boards, because they can keep using these STM32 boards as an Arduino. Starter boards can be: Nucleo-F103RB Nucleo-F401RE/F411RE Nucleo-F103RB Nucleo-H743","title":"1.1. STM32 Nucleo boards"},{"location":"blog/stm32/prepare/#12-stm32-discovery-kits","text":"This line of board allows either for beginner or for experienced users to get started on new projects. These boards are cheap, and have complete solutions for demonstrating the capabilities of the devices. Some boards come with many peripherals such as LCD, MEM sensors, touch pad. They also have integrated ST-LINK debugger/ programmer. Starter boards can be: STM32F072-Discovery STM32F429-Discovery STM32F072-Discovery STM32F429-Discovery","title":"1.2. STM32 Discovery kits"},{"location":"blog/stm32/prepare/#13-evaluation-board","text":"The STM32 Eval boards have been designed as a complete demonstration and development platform for the STM32 MCUs and MPUs. They are meant to be used to execute a comprehensive evaluation of STMicroelectronics solutions. These boards have integrated ST-LINK debugger/ programmer. They carry external circuitry, such as transceivers, sensors, memory interfaces, displays and many more. The evaluation boards can be considered as a reference design for application development. Starter boards can be: STM32L476-EVAL STM32F407-EVAL STM32L476-EVAL STM32F407-EVAL","title":"1.3. Evaluation board"},{"location":"blog/stm32/prepare/#14-custom-board","text":"Many users still find that the price of original boards is still high. There are many clones which use either authorized MCUs or even fake ones, with reduced peripherals. They usually are customized to different starter boards in small size and just USB and debugging pins. The popular custom boards are \u201cBlue Pills\u201d STM32F103, and \u201cBlack Pills\u201d STM32F4x1. They are cheap and have many exposed pins. There is no debugger or programmer in these custom board. Users have to use an external one, such as ST-LINK or J-LINK. A blue pill STM32F103 A black pill STM32Fx1 Power conflict On a custom board, there may be no power protection circuit added, therefore, do not connect 3.3V power pin of the debugger if the USB port is plugged because the USB port already powers the board with 5V. Counterfeit chip There are counterfeit chips on the market that are blocked to work with ST-Link/ J-Link to flash and debug. Please make sure to not buy them, even there is a method to workaround with OpenOCD.","title":"1.4. Custom board"},{"location":"blog/stm32/prepare/#2-programmer--debugger","text":"Programmer is used to write application code into MCU. It can read the application and make a copy of the firmware. Debugger is used to read CPU registers, memory, and logging data to help developers see how application runs. It can halt the CPU too. In monitoring mode, it lets CPU run and read memory in background through some special channels to gather information of application and system in real-time.","title":"2. Programmer &amp; Debugger"},{"location":"blog/stm32/prepare/#21-st-link","text":"All official boards from ST have integrated ST-Link debugger / programmer in version 2 or 3. They work on a Serial Wire Debug (SWD) interface. ST-Link comes with good performance and some extra feature such as Serial Wire Output (SWO), Virtual COM port, Mass-storage for drag-and-drop programming. On custom boards, there is no on-board debugger, so that an external debugger is needed. There are both original and clone version in the market. Original ST-LINK/V2 A clone of ST-LINK/V2 Missing SWO pin on ST-LINK clones Many ST-LINK clones only expose SWD interface (SWCLK and SWDIO). The pin for SWO is not exposed. There is a quick fix for this problem: wire the PA10 of the on-board STM32 chip to a pin on the header. Read more in Add SWO pin .","title":"2.1. ST-LINK"},{"location":"blog/stm32/prepare/#22-j-link","text":"One of a popular debugger manufacturer is SEGGER . They provide many tools for embedded systems. Their J-Link is quite expensive but comes with a lot of high performance features beside standard ones in ST-LINK, such as Real-time logging, system view, profiling. There are also cloned J-Link devices which are actually an STM32F0 MCU running a SEGGER firmware but have limitation in features due to missing hardware component and license. One interesting thing is SEGGER provides a tool to convert ST-LINK/V2 to a J-LINK OB model with some small limitations. J-Link Pro Cloned J-Link OB","title":"2.2. J-LINK"},{"location":"blog/stm32/prepare/#3-power-supplier","text":"There are many ways to power the board. Always check the Voltage and the Maximum Current of the power source. During the development, the board should be powered through the debugger which connects to PC via an USB port. If there is another on-board USB port connecting to PC, do not use power pin on the debugger. In the final production, the board will run without a debugger connected to a host PC, the power can be connected to the USB port or the power pins directly. A portable power source can be a Power bank, or a Li-Po battery. Also keep in mind that if the board would occasionally go to sleep state and the consumption current drops below 50 - 70 mA, many power banks would drop the supply, so the system will shut down catastrophically.","title":"3. Power Supplier"},{"location":"blog/stm32/prepare/#4-logic-analyser-optional","text":"A Logic Analyser can captures (and display) multiple signals on a system. The output can be visualized in timing diagrams, and then analyzed or decoded to get detailed information about the signal or the protocol and data. There are small portable Logic Analysers which just do capturing data, and then the captured data is transferred to a host PC via USB. Finally, the data is visualized by an application. Saleae Logic Cloned Logic","title":"4. Logic Analyser (optional)"},{"location":"blog/stm32/semihosting/","text":"Semihosting Semihosting setup Connect a debugger via SWD interface Include semihosting lib in GCC linker -l rdimon --specs=rdimon.specs Exclude the default syscall.c implementation Initialize in the startup of the application with initialise_monitor_handles(); Run OpenOCD with command monitor arm semihosting enable Semihosting notes Semihosting implementation in OpenOCD is designed so that every string must be terminated with the newline character \\n before the string appears on the OpenOCD console. Semihosting only works during a debug session, and it\u2019s slow and affects the system performance. CPU is halt when semihosting is executing in host machine, therefore semihosting is not suitable for realtime application. 1. Debugging \u2693\ufe0e There are some debug techniques used to inspect the firmware running on ARM-based MCUs: Semihosting : build-in to every ARM chips, need adding additional library and running in debug mode Redirection : forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need an USB peripheral Serial Wire View (SWV) : fast output over dedicated Single Wire Output (SWO) pin, but it\u2019s only available on Cortex-M3+, and this is uni-direction communucation. Real Time Transfer (RTT) : extremely fast but only work with Segger Debugger, can have a realtime bi-direction communication. Ways to print debug 2. Semihosting \u2693\ufe0e ARM semihosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . Semihosting is implemented by a set of defined software instructions, for example, SVC , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting overview 2.1. Hardware setup \u2693\ufe0e Semihosting need to be run under a debug session to communicate with semihosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO in the SWD interface. In the CubeMX, under the Pinout and Configuration tab, select the SYS module and check on the Debug Serial Wire option to assign the Debug function on pins PA14 and PA13 . Enable Serial Wire Debug pins 2.2. Software setup \u2693\ufe0e To use semihosting, it has to be set in linker options, and initialized in the main program. 2.2.1. Linker options \u2693\ufe0e GNU ARM libs use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options in generated project. There is an rdimon library that implements interrupt for some special system calls, which pauses the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the the newlib-nano specs. The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using GUI config: Open Project Properties \u00bb C/C++ Build \u00bb Settings \u00bb Tool Settings tab \u00bb MCU GCC Linker : Libraries: add rdimon Miscellaneous flags: add --specs=rdimon.specs 2.2.2. Exclude user system calls \u2693\ufe0e In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . Must exclude syscalls.c from build to avoid compilation error of multiple definitions . Add semihosting in GCC Linker Exclude syscalls.c 2.2.3. Initialize semihosting \u2693\ufe0e The rdimon library has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { initialise_monitor_handles (); } After that, the application can use printf() , scanf() , or gets() . 2.3. Debugger option \u2693\ufe0e The final thing is to enable semihosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. In some cases, it has to use Software Reset method to help debugger reset the target MCU. Use ST-LINK over OpenOCD with the start up command: monitor arm semihosting enable Enable semihosting in debugger 3. Debug with Semihosting \u2693\ufe0e Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> uint8_t counter = 0 ; char buffer [ 255 ]; extern void initialise_monitor_handles ( void ); int main ( void ) { initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out on Linux or D:\\\\test.out on Windows , if not, the target file will be created in the folder containing the openocd.exe program. Interact with semihosting","title":"Semihosting"},{"location":"blog/stm32/semihosting/#1-debugging","text":"There are some debug techniques used to inspect the firmware running on ARM-based MCUs: Semihosting : build-in to every ARM chips, need adding additional library and running in debug mode Redirection : forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need an USB peripheral Serial Wire View (SWV) : fast output over dedicated Single Wire Output (SWO) pin, but it\u2019s only available on Cortex-M3+, and this is uni-direction communucation. Real Time Transfer (RTT) : extremely fast but only work with Segger Debugger, can have a realtime bi-direction communication. Ways to print debug","title":"1. Debugging"},{"location":"blog/stm32/semihosting/#2-semihosting","text":"ARM semihosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . Semihosting is implemented by a set of defined software instructions, for example, SVC , that generate exceptions from program control. The application invokes the appropriate semihosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make semihosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, semihosting is implemented using the BKPT instruction. Semihosting overview","title":"2. Semihosting"},{"location":"blog/stm32/semihosting/#21-hardware-setup","text":"Semihosting need to be run under a debug session to communicate with semihosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO in the SWD interface. In the CubeMX, under the Pinout and Configuration tab, select the SYS module and check on the Debug Serial Wire option to assign the Debug function on pins PA14 and PA13 . Enable Serial Wire Debug pins","title":"2.1. Hardware setup"},{"location":"blog/stm32/semihosting/#22-software-setup","text":"To use semihosting, it has to be set in linker options, and initialized in the main program.","title":"2.2. Software setup"},{"location":"blog/stm32/semihosting/#221-linker-options","text":"GNU ARM libs use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options in generated project. There is an rdimon library that implements interrupt for some special system calls, which pauses the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the the newlib-nano specs. The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using GUI config: Open Project Properties \u00bb C/C++ Build \u00bb Settings \u00bb Tool Settings tab \u00bb MCU GCC Linker : Libraries: add rdimon Miscellaneous flags: add --specs=rdimon.specs","title":"2.2.1. Linker options"},{"location":"blog/stm32/semihosting/#222-exclude-user-system-calls","text":"In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . Must exclude syscalls.c from build to avoid compilation error of multiple definitions . Add semihosting in GCC Linker Exclude syscalls.c","title":"2.2.2. Exclude user system calls"},{"location":"blog/stm32/semihosting/#223-initialize-semihosting","text":"The rdimon library has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { initialise_monitor_handles (); } After that, the application can use printf() , scanf() , or gets() .","title":"2.2.3. Initialize semihosting"},{"location":"blog/stm32/semihosting/#23-debugger-option","text":"The final thing is to enable semihosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. In some cases, it has to use Software Reset method to help debugger reset the target MCU. Use ST-LINK over OpenOCD with the start up command: monitor arm semihosting enable Enable semihosting in debugger","title":"2.3. Debugger option"},{"location":"blog/stm32/semihosting/#3-debug-with-semihosting","text":"Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> uint8_t counter = 0 ; char buffer [ 255 ]; extern void initialise_monitor_handles ( void ); int main ( void ) { initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out on Linux or D:\\\\test.out on Windows , if not, the target file will be created in the folder containing the openocd.exe program. Interact with semihosting","title":"3. Debug with Semihosting"},{"location":"blog/stm32/swv/","text":"Serial Wire Viewer 1. Serial Wire Viewer \u2693\ufe0e Cortex-M based microcontrollers integrate several debugging and tracing technologies, including JTAG and SWD. Tracing allows to export in real-time internal activities performed by the CPU. The Instrumentation Trace Macrocell (ITM) allows sending software-generated debug messages through a specific signal I/O named Serial Wire Output (SWO). The protocol used by the SWO pin to exchange data with the debugger probe is called Serial Wire Viewer (SWV). The ITM support is available in Cortex-M3/M4/M7 microcontrollers Compared to other \u201cdebugging-alike\u201d peripherals like UART/VCOM redirection or the ARM semihosting , SWV is really fast. Its communication speed is proportional to the MCU speed. To properly decode the bytes sent over the SWO port, the host debugger needs to know the frequencies of CPU and SWO port. SWV protocol defines 32 different stimulus ports: a port is a \u201ctag\u201d on the SWV message used to enable/disable messages selectively. These channels allow for separating the diagnostic data into different categories. For instance, ARM recommends channel 0 for text data (e.g., from printf) and channel 31 for RTOS events, while the other channels can be used for any other purposes. 2. ITM Functions \u2693\ufe0e The ITM stimulus registers are standardized by ARM and found on address 0xE0000000 (port 0) through 0xE000007C (port 31). To write data, enable ITM tracing and write data to the corresponding register. The CMSIS-Core package for Cortex-M3/M4/M7 cores provides necessary glue to handle SWV protocol. For example, the ITM_SendChar() routines allows to send a character using the SWO pin. core_cm4.h __STATIC_INLINE int32_t ITM_ReceiveChar ( void ) { int32_t ch = -1 ; /* no character available */ if ( ITM_RxBuffer != ITM_RXBUFFER_EMPTY ) { ch = ITM_RxBuffer ; ITM_RxBuffer = ITM_RXBUFFER_EMPTY ; /* ready for next character */ } return ( ch ); } __STATIC_INLINE uint32_t ITM_SendChar ( uint32_t ch ) { if ((( ITM -> TCR & ITM_TCR_ITMENA_Msk ) != 0UL ) && /* ITM enabled */ (( ITM -> TER & 1UL ) != 0UL )) { /* ITM Port #0 enabled */ while ( ITM -> PORT [ 0U ]. u32 == 0UL ) { __NOP (); } ITM -> PORT [ 0U ]. u8 = ( uint8_t ) ch ; } return ( ch ); } 3. Print on SWO \u2693\ufe0e Let\u2019s start a Black pill board which has STM32F411CE MCU featured by Cortex-M4 running at 100 MHz. A Blue Pill can be used in this lab too. Find the differences between then in Blue Pill Vs Black Pill: Transitioning From STM32F103 to STMF411 . A blue pill STM32F103 A black pill STM32F411 3.1. Setup project \u2693\ufe0e Start a new project with STM32F411CE, and configure it under CubeMX as below: Enable HSE and LSE crystal inputs Set the HCLK to 100 MHz by select HSE input for PLL and feed PLLCLK to HCLK Set Debug mode to Trace Asynchronous SW under the System Core configuration to enable the SWO function on the pin PB3 . Set PC13 as a GPIO Output as it is connected to an LED on the board Pin map STM32F411CE Description PA14 SWCLK PA13 SWDIO PB3 SWO PC13 LED 3.2. Print out on SWO \u2693\ufe0e After generating code from CubeMX, there is a file syscalls.c containing implementation for standard input/output calls of the system, such as _write() function is used by printf() . newlib-nano library GNU ARM libs use newlib to provide standard implementation of C libraries.However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as printf() or scanf() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. STM32CubeMX generates syscalls.c to provide low-level implementation for C libraries. syscalls.c __attribute__ (( weak )) int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { __io_putchar ( * ptr ++ ); } return len ; } Redirect to ITM To redirect the output to the ITM, override this function in main.c and replace the call to __io_putchar by ITM_SendChar : main.c int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { ITM_SendChar ( * ptr ++ ); } return len ; } Print a counter variable Create a variable char counter = 0 ; and in the main while loop, increase it by 1 and print out its value using standard function printf() every second. main.c char counter = 0 ; int main ( void ) { while ( 1 ) { counter ++ ; printf ( \"counter = %d \\n \" , counter ); HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 1000 ); } } 3.3. Open SWV View \u2693\ufe0e To enable the SWV function, in the Debugger Configuration screen, select below settings: Interface: SWD Serial Wire Viewer: Enable: true Core Clock: 100 MHz, should match the real CPU clock Setup Debugger to use SWV The next step is to add SWV Windows into the Debug perspective of IDE: Select Windows \u00bb Show View \u00bb SWV and select one of available windows type. For displaying ITM Print data, select the SWV ITM Data Console window. Add SWV windows Click on the Config icon in the SWV ITM Data Console tab, enable the ITM 0 and apply. Press on the Red button to start reading the SWV data. Configure ITM channel and start reading Resume the execution and observe the text appears on the ITM Data console: counter is printed in the ITM Data Console 4. Inspect variables \u2693\ufe0e The Debug IDE can inspect a variable in real-time using the Live Expression feature. For example, add uwTick to see the instant system time in milliseconds, add counter to show the its instant value. Live Expression SWV also has an useful graph mode to monitor variables. Open the SWV Data Trace Timeline Graph and open its configuration to enable Comparator 0 to trace the counter variable. Enable tracing variable in SWV Press on the Red button to start reading the SWV data. Resume the execution and observe the data is drawn in the graph: counter is drawn on the graph 5. Trace events \u2693\ufe0e SWV can be used to trace different types of events as it can sample Program Counter (PC) register and access some special registers to calculate some statistics. Trace configuration for SWV 5.1. Events \u2693\ufe0e CPI - Cycles per instruction For each cycle beyond the first one that an instruction uses, an internal counter is increased with one. The counter (DWT CPI count) can count up to 256 and is then set to 0. Each time that happens, one of these packets are sent. This is one aspect of the processors performance and used to calculate instructions per seconds. The lower the value, the better the performance. SLEEP - Sleep cycles The number of cycles the CPU is in sleep mode. Counted in DWT Sleep count register. Each time the CPU has been in sleep mode for 256 cycles, one of these packets is sent. This is used when debugging for power consumption or waiting for external devices. FOLD - Folded instructions A counter for how many instructions are folded (removed). Every 256 instruction folded (taken zero cycles) will receive one of these events. Counted in DWT Fold count register. Branch folding is a technique where, on the prediction of most branches, the branch instruction is completely removed from the instruction stream presented to the execution pipeline. Branch folding can significantly improve the performance of branches, taking the CPI for branches below 1. EXC - Exception overhead The DWT Exception count register keeps track of the number of CPU cycles spent in exception overhead. This includes stack operations and returns but not the time spent processing the exception code. When the timer overflows, one of these events is sent. Used to calculate the actual exception handling cost to the program. LSU - Load Store Unit Cycles The DWT LSU count register counts the total number of cycles the processor is processing an LSU operation beyond the first cycle. When the timer overflows, one of these events is sent. With this measurement, it is possible to track the amount of time spent in memory operations. EXETRC - Trace Exceptions Whenever an exception occurs, exception entry, exception exit and exception return events are sent. These events can be monitored in the SWV Exception Trace Log view. From this view, it is possible to jump to the exception handler code for that exception. PC Sampling Enabling this starts sampling the Program Counter at some cycle interval. Since the SWO pin has a limited bandwidth, it is not advised to sample to fast. Experiment with the Resolution (cycles/ sample setting) to be able to sample often enough. The results from the sampling are used, among other things, for the SWV Statistical Profiling view. 5.2. Statistical Profiling \u2693\ufe0e When enable PC Sampling , the IDE can It show the amount of execution time spent within various functions. This is useful when optimizing code. When pause the execution, the SWV Statistical Profiling view will display a table with calculated information. Clear the collected data to start a new profiling session. Statistical profiling of function execution 5.3. Exception Trace \u2693\ufe0e Every event sent when CPU handles an exception will be recorded and these data is used to calculate some information about exceptions. There are two tabs, but the useful information is in the statistic tab. Statistic of exception execution 6. Receive data using scanf \u2693\ufe0e In above section, the _write function is overridden to redirect printf to ITM 0. The same method can be applied to override _read function to receive data for the function scanf . int _read ( int file , char * ptr , int len ) { for ( int DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { * ptr ++ = ITM_ReceiveChar (); } return len ; } However, when compile this code, an error will be raised due to undefined reference to the ITM_RxBuffer . This special variable is left to be defined by Debugger which support SWV input functions, such as Keil ARM. STM32CubeIDE does not support. There are ideas to use either Semihosting or SWD to write data into the ITM_RxBuffer as mentioned in here . Segger RTT is well done when combining the advantages of SWO for print and semihosting for scanf .","title":"SWV"},{"location":"blog/stm32/swv/#1-serial-wire-viewer","text":"Cortex-M based microcontrollers integrate several debugging and tracing technologies, including JTAG and SWD. Tracing allows to export in real-time internal activities performed by the CPU. The Instrumentation Trace Macrocell (ITM) allows sending software-generated debug messages through a specific signal I/O named Serial Wire Output (SWO). The protocol used by the SWO pin to exchange data with the debugger probe is called Serial Wire Viewer (SWV). The ITM support is available in Cortex-M3/M4/M7 microcontrollers Compared to other \u201cdebugging-alike\u201d peripherals like UART/VCOM redirection or the ARM semihosting , SWV is really fast. Its communication speed is proportional to the MCU speed. To properly decode the bytes sent over the SWO port, the host debugger needs to know the frequencies of CPU and SWO port. SWV protocol defines 32 different stimulus ports: a port is a \u201ctag\u201d on the SWV message used to enable/disable messages selectively. These channels allow for separating the diagnostic data into different categories. For instance, ARM recommends channel 0 for text data (e.g., from printf) and channel 31 for RTOS events, while the other channels can be used for any other purposes.","title":"1. Serial Wire Viewer"},{"location":"blog/stm32/swv/#2-itm-functions","text":"The ITM stimulus registers are standardized by ARM and found on address 0xE0000000 (port 0) through 0xE000007C (port 31). To write data, enable ITM tracing and write data to the corresponding register. The CMSIS-Core package for Cortex-M3/M4/M7 cores provides necessary glue to handle SWV protocol. For example, the ITM_SendChar() routines allows to send a character using the SWO pin. core_cm4.h __STATIC_INLINE int32_t ITM_ReceiveChar ( void ) { int32_t ch = -1 ; /* no character available */ if ( ITM_RxBuffer != ITM_RXBUFFER_EMPTY ) { ch = ITM_RxBuffer ; ITM_RxBuffer = ITM_RXBUFFER_EMPTY ; /* ready for next character */ } return ( ch ); } __STATIC_INLINE uint32_t ITM_SendChar ( uint32_t ch ) { if ((( ITM -> TCR & ITM_TCR_ITMENA_Msk ) != 0UL ) && /* ITM enabled */ (( ITM -> TER & 1UL ) != 0UL )) { /* ITM Port #0 enabled */ while ( ITM -> PORT [ 0U ]. u32 == 0UL ) { __NOP (); } ITM -> PORT [ 0U ]. u8 = ( uint8_t ) ch ; } return ( ch ); }","title":"2. ITM Functions"},{"location":"blog/stm32/swv/#3-print-on-swo","text":"Let\u2019s start a Black pill board which has STM32F411CE MCU featured by Cortex-M4 running at 100 MHz. A Blue Pill can be used in this lab too. Find the differences between then in Blue Pill Vs Black Pill: Transitioning From STM32F103 to STMF411 . A blue pill STM32F103 A black pill STM32F411","title":"3. Print on SWO"},{"location":"blog/stm32/swv/#31-setup-project","text":"Start a new project with STM32F411CE, and configure it under CubeMX as below: Enable HSE and LSE crystal inputs Set the HCLK to 100 MHz by select HSE input for PLL and feed PLLCLK to HCLK Set Debug mode to Trace Asynchronous SW under the System Core configuration to enable the SWO function on the pin PB3 . Set PC13 as a GPIO Output as it is connected to an LED on the board Pin map STM32F411CE Description PA14 SWCLK PA13 SWDIO PB3 SWO PC13 LED","title":"3.1. Setup project"},{"location":"blog/stm32/swv/#32-print-out-on-swo","text":"After generating code from CubeMX, there is a file syscalls.c containing implementation for standard input/output calls of the system, such as _write() function is used by printf() . newlib-nano library GNU ARM libs use newlib to provide standard implementation of C libraries.However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as printf() or scanf() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. STM32CubeMX generates syscalls.c to provide low-level implementation for C libraries. syscalls.c __attribute__ (( weak )) int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { __io_putchar ( * ptr ++ ); } return len ; } Redirect to ITM To redirect the output to the ITM, override this function in main.c and replace the call to __io_putchar by ITM_SendChar : main.c int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { ITM_SendChar ( * ptr ++ ); } return len ; } Print a counter variable Create a variable char counter = 0 ; and in the main while loop, increase it by 1 and print out its value using standard function printf() every second. main.c char counter = 0 ; int main ( void ) { while ( 1 ) { counter ++ ; printf ( \"counter = %d \\n \" , counter ); HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 1000 ); } }","title":"3.2. Print out on SWO"},{"location":"blog/stm32/swv/#33-open-swv-view","text":"To enable the SWV function, in the Debugger Configuration screen, select below settings: Interface: SWD Serial Wire Viewer: Enable: true Core Clock: 100 MHz, should match the real CPU clock Setup Debugger to use SWV The next step is to add SWV Windows into the Debug perspective of IDE: Select Windows \u00bb Show View \u00bb SWV and select one of available windows type. For displaying ITM Print data, select the SWV ITM Data Console window. Add SWV windows Click on the Config icon in the SWV ITM Data Console tab, enable the ITM 0 and apply. Press on the Red button to start reading the SWV data. Configure ITM channel and start reading Resume the execution and observe the text appears on the ITM Data console: counter is printed in the ITM Data Console","title":"3.3. Open SWV View"},{"location":"blog/stm32/swv/#4-inspect-variables","text":"The Debug IDE can inspect a variable in real-time using the Live Expression feature. For example, add uwTick to see the instant system time in milliseconds, add counter to show the its instant value. Live Expression SWV also has an useful graph mode to monitor variables. Open the SWV Data Trace Timeline Graph and open its configuration to enable Comparator 0 to trace the counter variable. Enable tracing variable in SWV Press on the Red button to start reading the SWV data. Resume the execution and observe the data is drawn in the graph: counter is drawn on the graph","title":"4. Inspect variables"},{"location":"blog/stm32/swv/#5-trace-events","text":"SWV can be used to trace different types of events as it can sample Program Counter (PC) register and access some special registers to calculate some statistics. Trace configuration for SWV","title":"5. Trace events"},{"location":"blog/stm32/swv/#51-events","text":"CPI - Cycles per instruction For each cycle beyond the first one that an instruction uses, an internal counter is increased with one. The counter (DWT CPI count) can count up to 256 and is then set to 0. Each time that happens, one of these packets are sent. This is one aspect of the processors performance and used to calculate instructions per seconds. The lower the value, the better the performance. SLEEP - Sleep cycles The number of cycles the CPU is in sleep mode. Counted in DWT Sleep count register. Each time the CPU has been in sleep mode for 256 cycles, one of these packets is sent. This is used when debugging for power consumption or waiting for external devices. FOLD - Folded instructions A counter for how many instructions are folded (removed). Every 256 instruction folded (taken zero cycles) will receive one of these events. Counted in DWT Fold count register. Branch folding is a technique where, on the prediction of most branches, the branch instruction is completely removed from the instruction stream presented to the execution pipeline. Branch folding can significantly improve the performance of branches, taking the CPI for branches below 1. EXC - Exception overhead The DWT Exception count register keeps track of the number of CPU cycles spent in exception overhead. This includes stack operations and returns but not the time spent processing the exception code. When the timer overflows, one of these events is sent. Used to calculate the actual exception handling cost to the program. LSU - Load Store Unit Cycles The DWT LSU count register counts the total number of cycles the processor is processing an LSU operation beyond the first cycle. When the timer overflows, one of these events is sent. With this measurement, it is possible to track the amount of time spent in memory operations. EXETRC - Trace Exceptions Whenever an exception occurs, exception entry, exception exit and exception return events are sent. These events can be monitored in the SWV Exception Trace Log view. From this view, it is possible to jump to the exception handler code for that exception. PC Sampling Enabling this starts sampling the Program Counter at some cycle interval. Since the SWO pin has a limited bandwidth, it is not advised to sample to fast. Experiment with the Resolution (cycles/ sample setting) to be able to sample often enough. The results from the sampling are used, among other things, for the SWV Statistical Profiling view.","title":"5.1. Events"},{"location":"blog/stm32/swv/#52-statistical-profiling","text":"When enable PC Sampling , the IDE can It show the amount of execution time spent within various functions. This is useful when optimizing code. When pause the execution, the SWV Statistical Profiling view will display a table with calculated information. Clear the collected data to start a new profiling session. Statistical profiling of function execution","title":"5.2. Statistical Profiling"},{"location":"blog/stm32/swv/#53-exception-trace","text":"Every event sent when CPU handles an exception will be recorded and these data is used to calculate some information about exceptions. There are two tabs, but the useful information is in the statistic tab. Statistic of exception execution","title":"5.3. Exception Trace"},{"location":"blog/stm32/swv/#6-receive-data-using-scanf","text":"In above section, the _write function is overridden to redirect printf to ITM 0. The same method can be applied to override _read function to receive data for the function scanf . int _read ( int file , char * ptr , int len ) { for ( int DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { * ptr ++ = ITM_ReceiveChar (); } return len ; } However, when compile this code, an error will be raised due to undefined reference to the ITM_RxBuffer . This special variable is left to be defined by Debugger which support SWV input functions, such as Keil ARM. STM32CubeIDE does not support. There are ideas to use either Semihosting or SWD to write data into the ITM_RxBuffer as mentioned in here . Segger RTT is well done when combining the advantages of SWO for print and semihosting for scanf .","title":"6. Receive data using scanf"},{"location":"blog/stm32/timer/","text":"Basic Timer - Blinking LED PWM - LED Brightness 1. Timer overview \u2693\ufe0e A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as a \u201cmaster\u201d. The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, and then go back to count again from 0. Let\u2019s see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms Main groups of Timers : Basic timers : 16-bit timers used as time base generator; do not have output/input pins; used as a master of other timers or used to feed the DAC peripherals. General purpose timers : 16/32-bit timers with multiple purposes; have four-programmable input/output channels; used in any application for output compare (timing and delay generation), One-Pulse Mode, input capture (for external signal frequency measurement), sensor interface (encoder, hall sensor), etc. This type has sub-groups: 1-channel/2-channels, or 1-channel/2-channels with one complimentary output ( a dead time generator on one channel). Advanced timers : have more features than General purpose timers such as features related to motor control and digital power conversion applications: three complementary signals with dead time insertion, emergency shut-down input. High resolution timer : a timer allows generating digital signals with high-accuracy timings, such as PWM or phase-shifted pulses. It has Delay lines with closed loop control guarantee a very small resolution whatever the voltage, temperature or chip-to-chip manufacturing process deviation. Low-power timers : have a diversity of clock sources to run in low frequencies, or from external clock-like inputs, and have the capability to wake up the system from low-power modes. 2. Timer modes \u2693\ufe0e An STM32 timer module can operate in any of the following modes, however, have to check the datasheet to figure out which modes are supported by which timers. Timer Mode In timer mode, the timer module gets clocked from an internal clock source with a known frequency. Hence the clocking frequency is known, the overflow time can also be calculated and controlled by the pre-load register to get any arbitrarily chosen time interval. Each timer overflow, the timer signals the CPU with an interrupt that indicates the end of the specified time interval. This mode of operation is usually used to get a specific operation done at each specific time interval, and to achieve timing & synchronization between various tasks and events in the system. It can also replace delays in various situations for better system response. Counter Mode In counter mode, the timer module gets clocked from an external source (timer input pin). So the timer counts up or down on each rising or falling edge of the external input. This mode is really helpful in numerous situations when need to implement a digital counter without polling input pins or periodically reading a GPIO or continuously interrupt the CPU when hooking with an EXTI pin. If using another timer as an interval, this mode can be used to measure frequency. PWM Mode In Pulse-Width Modulation (PWM) mode, the timer module is clocked from an internal clock source and produces a digital waveform on the output channel pin called the PWM signal. By using output compare registers OCR , the incrementing timer\u2019s register value is constantly compared against this OCR register. When a match occurs the output pin state is flipped until the end of the period and the whole process is repeated. Advanced PWM Mode The advanced PWM signal generation refers to the hardware ability to control more parameters and add some hardware circuitry to support extra features for the PWM signal generation. Which includes: The ability to produce a complementary PWM signal that is typically the same as the PWM on the main channel but logically inverted The ability to inject dead-time band in the PWM signal for motor driving applications to prevent shoot-through currents that result from PWM signals overlapping The ability to perform auto-shutdown for the PWM signal, it\u2019s also called \u201cauto brake\u201d which an important feature for safety-critical applications The ability to phase-adjust the PWM signal Output Compare Mode In output compare mode, a timer module controls an output waveform or indicates when a period of time has elapsed. When a match is detected between the output compare register OCR and the counter, the output compare function assigns the corresponding output pin to a programmable value. One-Pulse Mode One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay. Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Input Capture Mode In Input capture mode, the Capture/Compare Registers TIMx_CCRx are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag ( TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. This mode is extremely important for external signal measurement or external event timing detection. The current value of the timer counts is captured when an external event occurs and an interrupt is fired. Encoder Mode In the encoder interface mode, the timer module operates as a digital counter with two inputs. The counter is clocked by each valid transition on both input pins. The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence, the counter will count up or down. Timer Gate Mode In timer gated mode, a timer module is also said to be working in \u201cslave mode\u201d. Where it only counts as long as an external input pin is held high or low. This input pin is said to be the timer gate that allows the timer to count or not at all. Timer DMA Burst Mode The STM32 timers, not all of them, have the capability to generate multiple DMA requests upon a single event. The main purpose is to be able to re-program part of the timer multiple times without software overhead, but it can also be used to read several registers in a row, at regular intervals. Infrared Mode An infrared interface ( IRTIM ) for remote control can be used with an infrared LED to perform remote control functions. It uses internal connections with TIM15 and TIM16 as shown in the diagram down below. To generate the infrared remote control signals, the IR interface must be enabled and TIM15 channel 1 ( TIM15_OC1 ) and TIM16 channel 1 ( TIM16_OC1 ) must be properly configured to generate correct waveforms. The infrared receiver can be implemented easily through a basic input capture mode. 3. STM32Cube HAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use TIM HAL Initialize the TIM low level resources by implementing the following functions depending from feature to be used : Time Base : HAL_TIM_Base_MspInit() Input Capture : HAL_TIM_IC_MspInit() Output Compare : HAL_TIM_OC_MspInit() PWM generation : HAL_TIM_PWM_MspInit() One-pulse mode output : HAL_TIM_OnePulse_MspInit() Encoder mode output : HAL_TIM_Encoder_MspInit() Initialize the TIM low level resources : Use __HAL_RCC_TIMx_CLK_ENABLE() to enable the TIM interface clock TIM pins configuration Use __HAL_RCC_GPIOx_CLK_ENABLE() to enable the clock for the TIM GPIOs Configure these TIM pins in Alternate function mode using HAL_GPIO_Init() The external Clock can be configured, if needed (the default clock is the internal clock from the APBx), using the following function: HAL_TIM_ConfigClockSource , the clock configuration should be done before any start function. Configure the TIM in the desired functioning mode using one of the Initialization function of this driver: HAL_TIM_Base_Init : to use the Timer to generate a simple time base HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel : to use the Timer to generate an Output Compare signal. HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel : to use the Timer to generate a PWM signal. HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel : to use the Timer to measure an external signal. HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel : to use the Timer in One Pulse Mode. HAL_TIM_Encoder_Init : to use the Timer Encoder Interface. Activate the TIM peripheral using one of the start functions depending from the feature used: Time Base : HAL_TIM_Base_Start() , HAL_TIM_Base_Start_DMA() , HAL_TIM_Base_Start_IT() Input Capture : HAL_TIM_IC_Start() , HAL_TIM_IC_Start_DMA() , HAL_TIM_IC_Start_IT() Output Compare : HAL_TIM_OC_Start() , HAL_TIM_OC_Start_DMA() , HAL_TIM_OC_Start_IT() PWM generation : HAL_TIM_PWM_Start() , HAL_TIM_PWM_Start_DMA() , HAL_TIM_PWM_Start_IT() One-pulse mode output : HAL_TIM_OnePulse_Start() , HAL_TIM_OnePulse_Start_IT() Encoder mode output : HAL_TIM_Encoder_Start() , HAL_TIM_Encoder_Start_DMA() , HAL_TIM_Encoder_Start_IT() . The DMA Burst is managed with the two following functions: HAL_TIM_DMABurst_WriteStart() and HAL_TIM_DMABurst_ReadStart() 4. Lab 1: Blink LED with Timer \u2693\ufe0e This is a basic usage of a timer. Application will enable a basic timer with a pre-scaler and a pre-load value and let the timer run. Then the timer will keep counting and fire up an interrupt to application to do something. Requirements : Use a Timer to toggle an LED every 250ms Target board : Any board as a basic timer and a GPIO are always available. 4.1. Create a new project \u2693\ufe0e This tutorial will use the STM32F0 Discovery board which features an STM32F051R8 MCU. Starting a new project with below starting configs: System Clock set to 48 MHz, which also drives the Timers on the APB bus. Set PC9 as the output for the on-board Blue LED Setup clock for Timers 4.2. Enable a Timer \u2693\ufe0e For this simple lab, a basic timer will be used. Look at the Datasheet of the MCU to know how many timers are in the MCU and their types, and read the Reference Manual to get details about a specific timer. Note that a specific timer TIMx is the same in all STM32 MCUs to guarantee the compatibility and portability of the timer on different target. STM32F051xx Timers The STM32F051xx devices include up to six general-purpose timers, one basic timer and an advanced control timer. Timer features in STM32F051xx The basic timer TIM6 is mainly used for DAC trigger generation. It can also be used as a generic 16-bit time base. TIM6/TIM7 main features 16-bit auto-reload up-counter 16-bit programmable pre-scaler used to divide (also \u201con the fly\u201d) the counter clock frequency Synchronization circuit to trigger the DAC Interrupt/DMA generation on the update event: counter overflow In the CubeMX, activate TIM6 module and then calculate the pre-scaler and auto reload register values: Toggle every 250ms, meaning the rate is 4 Hz Timer frequency is 48 MHz, so it should be reduced 12.000.000 times. Choose any combination of pre-scaler and auto-reload whose multiplication result is 12.000.000. Because these values are counted from zero, therefore, the filled number should be decreased by one. One Pulse mode will make timer run once, do not select this to put timer in repeat mode. Enable the Interrupt for this timer Setting a basic timer Do NOT use Polling mode on Timer Polling mode on Timer is just keep reading the timer\u2019s counter to compare with a given counter. However, please note that the timer is an independent asynchronous peripheral which may run at higher frequency of the CPU core. This line of code if ( __HAL_TIM_GET_COUNTER ( & tim ) == value ){...} does not guarantee that the CPU accesses to the counter register exactly at the same time the timer reaches the given value. 4.3. Generated code \u2693\ufe0e After code generation, there is a function MX_TIM6_Init() to initialize the activated timers. static void MX_TIM6_Init ( void ) { TIM_MasterConfigTypeDef sMasterConfig = { 0 }; htim6 . Instance = TIM6 ; htim6 . Init . Prescaler = 3000-1 ; htim6 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim6 . Init . Period = 4000-1 ; htim6 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim6 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim6 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } } The clock and interrupt of the selected timer is configured in HAL_TIM_Base_MspInit() function: void HAL_TIM_Base_MspInit ( TIM_HandleTypeDef * htim_base ) { __HAL_RCC_TIM6_CLK_ENABLE (); HAL_NVIC_SetPriority ( TIM6_DAC_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( TIM6_DAC_IRQn ); } Because the timer has enabled its interrupt, HAL calls to HAL_TIM_IRQHandler() in the interrupt handler, then finally informs to application via different callback. In this lab, application only need to know when a full period is done through the callback of HAL_TIM_PeriodElapsedCallback() and toggle the LED. 4.4. User code \u2693\ufe0e This simple lab only needs to override the callback when a full period elapses. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } And then start the timer in Interrupt mode in the main application: int main () { HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ){...} } 5. Lab 2: PWM on LED brightness \u2693\ufe0e 5.1. PWM Duty \u2693\ufe0e The square waves has a common characteristic: they have a T ON period equal to the T OFF one. For this reason they are also said to have a 50% duty cycle. A duty cycle is the percentage of one period of time (for example, 1s) in which a signal is active. As a formula, a duty cycle is expressed as the T ON /Period. Pulse-width modulation (PWM) is a technique used to generate several pulses with different duty cycles in a given period of time at a given frequency. PWM has many applications in digital electronics, but all of them can be grouped in two main categories: PWM output and its average voltage control the output voltage (and hence the current); encoding (that is, modulate) a message (that is, a series of bytes in digital electronics) on a carrier wave (which runs at a given frequency). Those two categories can be expanded in several practical usages of the PWM technique. If only focusing on the control of the output voltage, here are several applications: generation of an output voltage ranging from 0V up to VDD (that is, the maximum allowed voltage for an I/O, which in an STM32 is 3.3V); dimming of LEDs; motor control; power conversion; generation of an output wave running at a given frequency (sine wave, triangle, square, and so on); sound output; There are two PWM modes available: PWM mode 1 : in up-counting, the channel is active as long as Counter < Period , else inactive. In down-counting, the channel is inactive as long as Counter > Period , else active. PWM mode 2 : in up-counting, channel is inactive as long as Counter < Period , else active. In down-counting, channel 1 is active as long as Counter > Period , else inactive. 5.2. Drive the brightness \u2693\ufe0e This lab will generate changeable-duty PWM signal on pin PC8 which connected to the blue LED on the STM32F0 Discovery board. If the duty goes up to 100%, the LED will have the highest brightness, and it becomes off when the duty goes down to 0%. The target application should slowly change the duty of the generated PWM. 5.3. Setup PWM on a Timer \u2693\ufe0e The Blue LED on PC8 is connected to Timer 3 - Channel 3 Output . Therefore, select the Alternate Function of PC8 as TIM3_CH3 firstly. After that, when configuring the TIM3 , select Channel 3 as PWM Generation CH3 . Setup PWM on the Timer 3 Channel 3 Next step is configure the PWM frequency and duty: Use the internal clock source, which is 48 MHz in this lab PWM Frequency = 100 Hz, let\u2019s use Pre-scaler = 480-1, and Counter period = 1000-1. PWM Duty: the Counter period is set to 1000, the if duty is 25%, the Pulse counter must be set at 250-1 5.4. Setup delay on a Timer \u2693\ufe0e Do the same thing as it\u2019s done in the previous lab to setup an 100 Hz interrupt on a basic timer TIM6. The period is now only 10 ms 5.5. Generated code \u2693\ufe0e Let\u2019s see how TIM3 is configured in the generated function MX_TIM3_Init() which setups the timer\u2019s params and setup PWM mode. Note that PWM is Output Compare register to mark the point where pulse is inverted. PWM output based on Output Compare and Period registers static void MX_TIM3_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_OC_InitTypeDef sConfigOC = { 0 }; /* Setup base */ htim3 . Instance = TIM3 ; htim3 . Init . Prescaler = 480-1 ; htim3 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim3 . Init . Period = 1000-1 ; htim3 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim3 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } /* Setup clock source */ sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim3 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } /* Init PWM */ if ( HAL_TIM_PWM_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim3 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } /* Setup PWM params*/ sConfigOC . OCMode = TIM_OCMODE_PWM1 ; sConfigOC . Pulse = 250-1 ; sConfigOC . OCPolarity = TIM_OCPOLARITY_HIGH ; sConfigOC . OCFastMode = TIM_OCFAST_DISABLE ; if ( HAL_TIM_PWM_ConfigChannel ( & htim3 , & sConfigOC , TIM_CHANNEL_3 ) != HAL_OK ) { Error_Handler (); } /* Setup GPIO for PWM Output */ HAL_TIM_MspPostInit ( & htim3 ); } 5.6. User code \u2693\ufe0e The Counter period (aka. Auto Reload ) is stored in the register ARR of the timer. And the duty of the PWM is set in the Compare Control register named CRx . In the main application, save the PWM duty and use it to control PWM duty later. All timers must be started exclusively. uint16_t dutyCycle = 0 ; int main () { dutyCycle = __HAL_TIM_GET_AUTORELOAD ( & htim3 ); HAL_TIM_PWM_Start ( & htim3 , TIM_CHANNEL_3 ); HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ) { HAL_Delay ( 1000 ); } } To change the duty of the output PWM inside the 100 Hz basic timer\u2019s interrupt, override the callback and set the Output Compare value with changed duty. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( dutyCycle >= __HAL_TIM_GET_AUTORELOAD ( & htim3 )) { dutyInc = -1 ; } else if ( dutyCycle == 0 ) { dutyInc = + 1 ; } dutyCycle += dutyInc ; __HAL_TIM_SET_COMPARE ( & htim3 , TIM_CHANNEL_3 , dutyCycle ); } PWM at 100Hz with changing duty - video LED brightness with changing PWM 6. Other modes \u2693\ufe0e Other modes of timers will be covered in some examples in up coming posts.","title":"Timers"},{"location":"blog/stm32/timer/#1-timer-overview","text":"A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as a \u201cmaster\u201d. The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, and then go back to count again from 0. Let\u2019s see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms Main groups of Timers : Basic timers : 16-bit timers used as time base generator; do not have output/input pins; used as a master of other timers or used to feed the DAC peripherals. General purpose timers : 16/32-bit timers with multiple purposes; have four-programmable input/output channels; used in any application for output compare (timing and delay generation), One-Pulse Mode, input capture (for external signal frequency measurement), sensor interface (encoder, hall sensor), etc. This type has sub-groups: 1-channel/2-channels, or 1-channel/2-channels with one complimentary output ( a dead time generator on one channel). Advanced timers : have more features than General purpose timers such as features related to motor control and digital power conversion applications: three complementary signals with dead time insertion, emergency shut-down input. High resolution timer : a timer allows generating digital signals with high-accuracy timings, such as PWM or phase-shifted pulses. It has Delay lines with closed loop control guarantee a very small resolution whatever the voltage, temperature or chip-to-chip manufacturing process deviation. Low-power timers : have a diversity of clock sources to run in low frequencies, or from external clock-like inputs, and have the capability to wake up the system from low-power modes.","title":"1. Timer overview"},{"location":"blog/stm32/timer/#2-timer-modes","text":"An STM32 timer module can operate in any of the following modes, however, have to check the datasheet to figure out which modes are supported by which timers. Timer Mode In timer mode, the timer module gets clocked from an internal clock source with a known frequency. Hence the clocking frequency is known, the overflow time can also be calculated and controlled by the pre-load register to get any arbitrarily chosen time interval. Each timer overflow, the timer signals the CPU with an interrupt that indicates the end of the specified time interval. This mode of operation is usually used to get a specific operation done at each specific time interval, and to achieve timing & synchronization between various tasks and events in the system. It can also replace delays in various situations for better system response. Counter Mode In counter mode, the timer module gets clocked from an external source (timer input pin). So the timer counts up or down on each rising or falling edge of the external input. This mode is really helpful in numerous situations when need to implement a digital counter without polling input pins or periodically reading a GPIO or continuously interrupt the CPU when hooking with an EXTI pin. If using another timer as an interval, this mode can be used to measure frequency. PWM Mode In Pulse-Width Modulation (PWM) mode, the timer module is clocked from an internal clock source and produces a digital waveform on the output channel pin called the PWM signal. By using output compare registers OCR , the incrementing timer\u2019s register value is constantly compared against this OCR register. When a match occurs the output pin state is flipped until the end of the period and the whole process is repeated. Advanced PWM Mode The advanced PWM signal generation refers to the hardware ability to control more parameters and add some hardware circuitry to support extra features for the PWM signal generation. Which includes: The ability to produce a complementary PWM signal that is typically the same as the PWM on the main channel but logically inverted The ability to inject dead-time band in the PWM signal for motor driving applications to prevent shoot-through currents that result from PWM signals overlapping The ability to perform auto-shutdown for the PWM signal, it\u2019s also called \u201cauto brake\u201d which an important feature for safety-critical applications The ability to phase-adjust the PWM signal Output Compare Mode In output compare mode, a timer module controls an output waveform or indicates when a period of time has elapsed. When a match is detected between the output compare register OCR and the counter, the output compare function assigns the corresponding output pin to a programmable value. One-Pulse Mode One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay. Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Input Capture Mode In Input capture mode, the Capture/Compare Registers TIMx_CCRx are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag ( TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. This mode is extremely important for external signal measurement or external event timing detection. The current value of the timer counts is captured when an external event occurs and an interrupt is fired. Encoder Mode In the encoder interface mode, the timer module operates as a digital counter with two inputs. The counter is clocked by each valid transition on both input pins. The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence, the counter will count up or down. Timer Gate Mode In timer gated mode, a timer module is also said to be working in \u201cslave mode\u201d. Where it only counts as long as an external input pin is held high or low. This input pin is said to be the timer gate that allows the timer to count or not at all. Timer DMA Burst Mode The STM32 timers, not all of them, have the capability to generate multiple DMA requests upon a single event. The main purpose is to be able to re-program part of the timer multiple times without software overhead, but it can also be used to read several registers in a row, at regular intervals. Infrared Mode An infrared interface ( IRTIM ) for remote control can be used with an infrared LED to perform remote control functions. It uses internal connections with TIM15 and TIM16 as shown in the diagram down below. To generate the infrared remote control signals, the IR interface must be enabled and TIM15 channel 1 ( TIM15_OC1 ) and TIM16 channel 1 ( TIM16_OC1 ) must be properly configured to generate correct waveforms. The infrared receiver can be implemented easily through a basic input capture mode.","title":"2. Timer modes"},{"location":"blog/stm32/timer/#3-stm32cube-hal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use TIM HAL Initialize the TIM low level resources by implementing the following functions depending from feature to be used : Time Base : HAL_TIM_Base_MspInit() Input Capture : HAL_TIM_IC_MspInit() Output Compare : HAL_TIM_OC_MspInit() PWM generation : HAL_TIM_PWM_MspInit() One-pulse mode output : HAL_TIM_OnePulse_MspInit() Encoder mode output : HAL_TIM_Encoder_MspInit() Initialize the TIM low level resources : Use __HAL_RCC_TIMx_CLK_ENABLE() to enable the TIM interface clock TIM pins configuration Use __HAL_RCC_GPIOx_CLK_ENABLE() to enable the clock for the TIM GPIOs Configure these TIM pins in Alternate function mode using HAL_GPIO_Init() The external Clock can be configured, if needed (the default clock is the internal clock from the APBx), using the following function: HAL_TIM_ConfigClockSource , the clock configuration should be done before any start function. Configure the TIM in the desired functioning mode using one of the Initialization function of this driver: HAL_TIM_Base_Init : to use the Timer to generate a simple time base HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel : to use the Timer to generate an Output Compare signal. HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel : to use the Timer to generate a PWM signal. HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel : to use the Timer to measure an external signal. HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel : to use the Timer in One Pulse Mode. HAL_TIM_Encoder_Init : to use the Timer Encoder Interface. Activate the TIM peripheral using one of the start functions depending from the feature used: Time Base : HAL_TIM_Base_Start() , HAL_TIM_Base_Start_DMA() , HAL_TIM_Base_Start_IT() Input Capture : HAL_TIM_IC_Start() , HAL_TIM_IC_Start_DMA() , HAL_TIM_IC_Start_IT() Output Compare : HAL_TIM_OC_Start() , HAL_TIM_OC_Start_DMA() , HAL_TIM_OC_Start_IT() PWM generation : HAL_TIM_PWM_Start() , HAL_TIM_PWM_Start_DMA() , HAL_TIM_PWM_Start_IT() One-pulse mode output : HAL_TIM_OnePulse_Start() , HAL_TIM_OnePulse_Start_IT() Encoder mode output : HAL_TIM_Encoder_Start() , HAL_TIM_Encoder_Start_DMA() , HAL_TIM_Encoder_Start_IT() . The DMA Burst is managed with the two following functions: HAL_TIM_DMABurst_WriteStart() and HAL_TIM_DMABurst_ReadStart()","title":"3. STM32Cube HAL Usage"},{"location":"blog/stm32/timer/#4-lab-1-blink-led-with-timer","text":"This is a basic usage of a timer. Application will enable a basic timer with a pre-scaler and a pre-load value and let the timer run. Then the timer will keep counting and fire up an interrupt to application to do something. Requirements : Use a Timer to toggle an LED every 250ms Target board : Any board as a basic timer and a GPIO are always available.","title":"4. Lab 1: Blink LED with Timer"},{"location":"blog/stm32/timer/#41-create-a-new-project","text":"This tutorial will use the STM32F0 Discovery board which features an STM32F051R8 MCU. Starting a new project with below starting configs: System Clock set to 48 MHz, which also drives the Timers on the APB bus. Set PC9 as the output for the on-board Blue LED Setup clock for Timers","title":"4.1. Create a new project"},{"location":"blog/stm32/timer/#42-enable-a-timer","text":"For this simple lab, a basic timer will be used. Look at the Datasheet of the MCU to know how many timers are in the MCU and their types, and read the Reference Manual to get details about a specific timer. Note that a specific timer TIMx is the same in all STM32 MCUs to guarantee the compatibility and portability of the timer on different target. STM32F051xx Timers The STM32F051xx devices include up to six general-purpose timers, one basic timer and an advanced control timer. Timer features in STM32F051xx The basic timer TIM6 is mainly used for DAC trigger generation. It can also be used as a generic 16-bit time base. TIM6/TIM7 main features 16-bit auto-reload up-counter 16-bit programmable pre-scaler used to divide (also \u201con the fly\u201d) the counter clock frequency Synchronization circuit to trigger the DAC Interrupt/DMA generation on the update event: counter overflow In the CubeMX, activate TIM6 module and then calculate the pre-scaler and auto reload register values: Toggle every 250ms, meaning the rate is 4 Hz Timer frequency is 48 MHz, so it should be reduced 12.000.000 times. Choose any combination of pre-scaler and auto-reload whose multiplication result is 12.000.000. Because these values are counted from zero, therefore, the filled number should be decreased by one. One Pulse mode will make timer run once, do not select this to put timer in repeat mode. Enable the Interrupt for this timer Setting a basic timer Do NOT use Polling mode on Timer Polling mode on Timer is just keep reading the timer\u2019s counter to compare with a given counter. However, please note that the timer is an independent asynchronous peripheral which may run at higher frequency of the CPU core. This line of code if ( __HAL_TIM_GET_COUNTER ( & tim ) == value ){...} does not guarantee that the CPU accesses to the counter register exactly at the same time the timer reaches the given value.","title":"4.2. Enable a Timer"},{"location":"blog/stm32/timer/#43-generated-code","text":"After code generation, there is a function MX_TIM6_Init() to initialize the activated timers. static void MX_TIM6_Init ( void ) { TIM_MasterConfigTypeDef sMasterConfig = { 0 }; htim6 . Instance = TIM6 ; htim6 . Init . Prescaler = 3000-1 ; htim6 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim6 . Init . Period = 4000-1 ; htim6 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim6 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim6 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } } The clock and interrupt of the selected timer is configured in HAL_TIM_Base_MspInit() function: void HAL_TIM_Base_MspInit ( TIM_HandleTypeDef * htim_base ) { __HAL_RCC_TIM6_CLK_ENABLE (); HAL_NVIC_SetPriority ( TIM6_DAC_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( TIM6_DAC_IRQn ); } Because the timer has enabled its interrupt, HAL calls to HAL_TIM_IRQHandler() in the interrupt handler, then finally informs to application via different callback. In this lab, application only need to know when a full period is done through the callback of HAL_TIM_PeriodElapsedCallback() and toggle the LED.","title":"4.3. Generated code"},{"location":"blog/stm32/timer/#44-user-code","text":"This simple lab only needs to override the callback when a full period elapses. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } And then start the timer in Interrupt mode in the main application: int main () { HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ){...} }","title":"4.4. User code"},{"location":"blog/stm32/timer/#5-lab-2-pwm-on-led-brightness","text":"","title":"5. Lab 2: PWM on LED brightness"},{"location":"blog/stm32/timer/#51-pwm-duty","text":"The square waves has a common characteristic: they have a T ON period equal to the T OFF one. For this reason they are also said to have a 50% duty cycle. A duty cycle is the percentage of one period of time (for example, 1s) in which a signal is active. As a formula, a duty cycle is expressed as the T ON /Period. Pulse-width modulation (PWM) is a technique used to generate several pulses with different duty cycles in a given period of time at a given frequency. PWM has many applications in digital electronics, but all of them can be grouped in two main categories: PWM output and its average voltage control the output voltage (and hence the current); encoding (that is, modulate) a message (that is, a series of bytes in digital electronics) on a carrier wave (which runs at a given frequency). Those two categories can be expanded in several practical usages of the PWM technique. If only focusing on the control of the output voltage, here are several applications: generation of an output voltage ranging from 0V up to VDD (that is, the maximum allowed voltage for an I/O, which in an STM32 is 3.3V); dimming of LEDs; motor control; power conversion; generation of an output wave running at a given frequency (sine wave, triangle, square, and so on); sound output; There are two PWM modes available: PWM mode 1 : in up-counting, the channel is active as long as Counter < Period , else inactive. In down-counting, the channel is inactive as long as Counter > Period , else active. PWM mode 2 : in up-counting, channel is inactive as long as Counter < Period , else active. In down-counting, channel 1 is active as long as Counter > Period , else inactive.","title":"5.1. PWM Duty"},{"location":"blog/stm32/timer/#52-drive-the-brightness","text":"This lab will generate changeable-duty PWM signal on pin PC8 which connected to the blue LED on the STM32F0 Discovery board. If the duty goes up to 100%, the LED will have the highest brightness, and it becomes off when the duty goes down to 0%. The target application should slowly change the duty of the generated PWM.","title":"5.2. Drive the brightness"},{"location":"blog/stm32/timer/#53-setup-pwm-on-a-timer","text":"The Blue LED on PC8 is connected to Timer 3 - Channel 3 Output . Therefore, select the Alternate Function of PC8 as TIM3_CH3 firstly. After that, when configuring the TIM3 , select Channel 3 as PWM Generation CH3 . Setup PWM on the Timer 3 Channel 3 Next step is configure the PWM frequency and duty: Use the internal clock source, which is 48 MHz in this lab PWM Frequency = 100 Hz, let\u2019s use Pre-scaler = 480-1, and Counter period = 1000-1. PWM Duty: the Counter period is set to 1000, the if duty is 25%, the Pulse counter must be set at 250-1","title":"5.3. Setup PWM on a Timer"},{"location":"blog/stm32/timer/#54-setup-delay-on-a-timer","text":"Do the same thing as it\u2019s done in the previous lab to setup an 100 Hz interrupt on a basic timer TIM6. The period is now only 10 ms","title":"5.4. Setup delay on a Timer"},{"location":"blog/stm32/timer/#55-generated-code","text":"Let\u2019s see how TIM3 is configured in the generated function MX_TIM3_Init() which setups the timer\u2019s params and setup PWM mode. Note that PWM is Output Compare register to mark the point where pulse is inverted. PWM output based on Output Compare and Period registers static void MX_TIM3_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_OC_InitTypeDef sConfigOC = { 0 }; /* Setup base */ htim3 . Instance = TIM3 ; htim3 . Init . Prescaler = 480-1 ; htim3 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim3 . Init . Period = 1000-1 ; htim3 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim3 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } /* Setup clock source */ sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim3 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } /* Init PWM */ if ( HAL_TIM_PWM_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim3 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } /* Setup PWM params*/ sConfigOC . OCMode = TIM_OCMODE_PWM1 ; sConfigOC . Pulse = 250-1 ; sConfigOC . OCPolarity = TIM_OCPOLARITY_HIGH ; sConfigOC . OCFastMode = TIM_OCFAST_DISABLE ; if ( HAL_TIM_PWM_ConfigChannel ( & htim3 , & sConfigOC , TIM_CHANNEL_3 ) != HAL_OK ) { Error_Handler (); } /* Setup GPIO for PWM Output */ HAL_TIM_MspPostInit ( & htim3 ); }","title":"5.5. Generated code"},{"location":"blog/stm32/timer/#56-user-code","text":"The Counter period (aka. Auto Reload ) is stored in the register ARR of the timer. And the duty of the PWM is set in the Compare Control register named CRx . In the main application, save the PWM duty and use it to control PWM duty later. All timers must be started exclusively. uint16_t dutyCycle = 0 ; int main () { dutyCycle = __HAL_TIM_GET_AUTORELOAD ( & htim3 ); HAL_TIM_PWM_Start ( & htim3 , TIM_CHANNEL_3 ); HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ) { HAL_Delay ( 1000 ); } } To change the duty of the output PWM inside the 100 Hz basic timer\u2019s interrupt, override the callback and set the Output Compare value with changed duty. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( dutyCycle >= __HAL_TIM_GET_AUTORELOAD ( & htim3 )) { dutyInc = -1 ; } else if ( dutyCycle == 0 ) { dutyInc = + 1 ; } dutyCycle += dutyInc ; __HAL_TIM_SET_COMPARE ( & htim3 , TIM_CHANNEL_3 , dutyCycle ); } PWM at 100Hz with changing duty - video LED brightness with changing PWM","title":"5.6. User code"},{"location":"blog/stm32/timer/#6-other-modes","text":"Other modes of timers will be covered in some examples in up coming posts.","title":"6. Other modes"},{"location":"blog/stm32/tools/","text":"1. STM32 Ecosystem \u2693\ufe0e A tool-chain is a set of programming tools that allow developers to: Configure the settings on the target MCU Write code and navigate inside source files of the project Inspect the code to show additional information about variables, function definitions, etc. Compile the source code to an executable application Program the target MCU Debug the application running on the target MCU Monitor the application on the target MCU The STM32Cube ecosystem is a complete software solution for STM32 microcontrollers and microprocessors. It has a complete toolchain and extended packages to well support developers on STM32 MCUs. STM32 Ecosystem STM32CubeMX , a configuration tool for any STM32 device. This easy-to-use graphical user interface generates initialization C code for Cortex-M cores and generates the Linux device tree source for Cortex-A cores. STM32CubeIDE , an Integrated Development Environment. Based on open-source solutions like Eclipse or the GNU C/C++ toolchain, this IDE includes compilation reporting features and advanced debug features. It also integrate additional features present in other tools from the ecosystem, such as the HW and SW initialization and code generation from STM32CubeMX. This software includes: Eclipse IDE - an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build scripts. GNU ARM Cross-compiler with ST patch for STM32 MCUs - a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex). GDB for inspecting, debugging the target application. STM32CubeProgrammer , a programming tool. It provides an easy-to-use and efficient environment for reading, writing and verifying devices and external memories via a wide variety of available communication media (JTAG, SWD, UART, USB DFU, I2C, SPI, CAN, etc.). STM32CubeMonitor , a monitoring tool. Powerful monitoring tools that help developers fine-tune the behavior and performance of their applications in real time. STM32Cube MCU and MPU packages , dedicated to each STM32 series. Packages offer all the required embedded software bricks to operate the available set of STM32 peripherals. They include drivers (HAL, low-layer, etc.), middleware, and lots of example code used in a wide variety of real-world use cases. STM32Cube expansion packages , for application-oriented solutions. Complementing and expanding the STM32Cube MCU Package offer with additional embedded software bricks, STM32 expansion packages come either from ST or approved partners to create an extensive and scalable embedded software offer around the STM32. 4 steps of an interactive development process 2. STMCubeIDE \u2693\ufe0e STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration, code generation, code compilation, and debug features for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC toolchain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. This tool includes the STM32CubeMX for code generation. At any time during the development, the user can return to the initialization and configuration of the peripherals or middleware and regenerate the initialization code with no impact on the user code written in the user blocks. STM32CubeIDE includes build and stack analyzers that provide the user with useful information about project status and memory requirements. STM32CubeIDE also includes standard and advanced debugging features including views of CPU core registers, memories, and peripheral registers, as well as live variable watch, Serial Wire Viewer interface, or fault analyzer. Other IDEs that support ARM Cortex: ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license 2.1. Installation \u2693\ufe0e Download STM32CubeIDE STM32CubeIDE User Manual During the installation, please be suare to install ST-LINK and SEGGER J-Link drivers. 2.2. Create a workspace \u2693\ufe0e When start the program, it will ask to select a directory as a workspace - the location to save projects. Consider to make new workspaces for different big projects. Select a workspace Each workspace has its own Preferences settings under the Windows menu. Some personal settings Due to the generated code from CubeMX is 2-space tab width, it is better to configure the Text Editor to adapt with the tab width behavior in General \u2192 Editor \u2192 Text Editor : Displayed tab width: 2 Insert spaces for tabs: Checked Remove multiple spaces on backspace/delete: Checked There are some options for Code Analysis under the C/C++ \u2192 Build . I recommended to enable some check for Potential Programming Problems : Assignment in condition if ( a = b ) No return in a function which is declared to return a value int func (){} Return without value int func(){ return;} Return the address of a local variable int* func(){int a; return &a;} Virtual method call in constructor/ destructor Next is the formatting style under the option C/C++ \u2192 Code Style \u2192 Formatter : Create a new profile from K&R In the Indentation , change Tab Policy to Space Only; then set Indentation size and Tab size both to 2. Finally, it should increase the buffer for terminals in Terminal option to 1000 or more. 2.3. Create a project \u2693\ufe0e It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. When start a new STM32 project, IDE shows up the Device Finder screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. The first project I am using a STM32F0-Discovery board (STM32F051R8) to make an example project for this post. This project does not require any knowledge about the target microprocessor, as it will be written like a normal C application. Select the target MCU by name After selecting the microprocessor, it\u2019s time to name the project, and select the STM32Cube MCU packages version for the selected target. In this example, it is STM32Cube FW F0 v1.11.2 . Set name and select firmware package for a new project Press on Finish then IDE will run a screen named Device Configuration Tool from the CubeMX tool, in there, it\u2019s easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board - usually including ST-Link pins, on-board buttons, LEDs, USB connect. 2.4. STM32CubeMX \u2693\ufe0e STM32CubeMX is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\u00ae Cortex\u00ae-M cores. STM32CubeMX User Manual STM32CubeMX allows the user to create, save and load previously saved projects. MCU configuration .ioc file is saved in the project folder, and user can open it in CubeMX for editing. 2.4.1. Pinout Configuration \u2693\ufe0e This tab shows available Components in categories or in A-Z list. Select on a component will show its Configuration screen. The large Pinout view show a graphic representation of the pin assignment. Left-click to select the function, and Right-click to do extra actions such as assigning a custom name. The Pinout config screen 2.4.2. Clock Configuration \u2693\ufe0e This tab provides a schematic overview of the clock paths, clock sources, dividers, and multipliers. Drop-down menus and buttons can be used to modify the actual clock tree configuration, to meet the application requirements. IDE has ability to automatically calculate multipliers and dividers to provide requested frequency, user can set a desired frequency in the clock node, and press enter, then IDE will re-configure the PLL, pre-scaler. The frequency on each node can be locked via the right-click menu. The Clock config screen 2.4.3. Project Manager \u2693\ufe0e This tab provides information about general project setting: to specify the project name, location, toolchain, and firmware version. It also has configs for code generation options such as the location of peripheral initialization code, library copy/link options, and to select templates for customized code. The Project config view 2.4.4. Code generation \u2693\ufe0e After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing Alt + K or choosing menu Project \u2192 Generate Code . The tool will create sub-folders and add necessary files into project. The general file structure is: \u2514\u2500\u2500\u2500Core \u2502 \u251c\u2500\u2500\u2500Inc \u2502 \u251c\u2500\u2500\u2500Src \u2502 \u2514\u2500\u2500\u2500Startup \u2514\u2500\u2500\u2500Drivers \u2514\u2500\u2500\u2500CMSIS \u2502 \u2514\u2500\u2500\u2500Device \u2502 \u2502 \u2514\u2500\u2500\u2500ST \u2502 \u2502 \u2514\u2500\u2500\u2500STM32F0xx \u2502 \u2502 \u2514\u2500\u2500\u2500Include \u2502 \u2502 \u2514\u2500\u2500\u2500Source \u2502 \u2502 \u2514\u2500\u2500\u2500Templates \u2502 \u2514\u2500\u2500\u2500Include \u2514\u2500\u2500\u2500STM32F0xx_HAL_Driver \u2514\u2500\u2500\u2500Inc \u2502 \u2514\u2500\u2500\u2500Legacy \u2514\u2500\u2500\u2500Src When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor and peripherals. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor\u2019s registers. In the Project Manager tab, it can change to use Low-Level (LL) library instead of HAL. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. The main function is called from the startup file startup_*.s . Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library).This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR.The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 set system clock configuration \u2022 declare peripheral HAL initialization \u2022 user application code. 2.5. Add user code \u2693\ufe0e User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. I am going to add a variable counter with type of char , then inside the main while loop in the main() function, increase it by 1 after 100ms. Don\u2019t mind the HAL function at this time. main.c /* USER CODE BEGIN PV */ char counter = 0 ; /* USER CODE END PV */ int main ( void ) { /* other setup function */ /* USER CODE BEGIN WHILE */ while ( 1 ) { counter ++ ; HAL_Delay ( 100 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 2.6. Compiler options \u2693\ufe0e Project has options for the compiler under its properties. Right-click on the project name in the right panel, then select Properties menu. The default included folders are all the folders created in the project by the CubeMX tool. There are also some symbols created for the project build, such DEBUG mode, or the MCU name STM32F051x8 . The including paths and symbols Then in the Build Options, there are options to be used by GCC complier, GNU Linker, GNU Assembler. Build options 2.7. Build Project \u2693\ufe0e Build the application by pressing Ctrl + B , or in menu Project \u2192 Build All . There are some reports about the resource usage to check after the compilation. The first thing it reports is the memory usage, in term of RAM and FLASH free space. 2.8. Setup debugger \u2693\ufe0e Before Run or Debug on the target chip, it is needed to configure the programming/ debugging interface. By default, the application code can be programmed through the debugger interface, therefore, in Run Config or Debug Config, there is a tab named Debugger to select: Debug Probe: ST-LINK GDB, ST-LINK OpenOCD, SEGGER J-LINK, or other available probes Interface: SWD or JTAG. If there are multiple boards connected, use debugger board Serial Number to choose the correct target Advanced features: Serial Wire Viewer: read data from MCU in a dedicated SW0 pin, available on Cortext-M3 and above Live Expression: read out the value at a memory address without halting the CPU Setup Debugger 2.9. Run Mode \u2693\ufe0e In the Run Mode, IDE flashes the firmware via the Debugging interface, and then disconnect the debugger to make the target board run freely. Just use the menu Run \u2192 Run . 2.10. Debug Mode \u2693\ufe0e Putting the target under the Debug Mode is to control its execution, step by step. Breakpoint is where the CPU will be halted and debugger will inspect its current status: registers, memory values. By default, the first breakpoint is right after entering the main function. The start address and the first break point can be set in the Startup tab in Debug Configurations. Startup option for debug When CPU is halted at a breakpoint, user can control the execution step by step, through the commands or buttons: Debug controls 3. STM32CubeProgrammer \u2693\ufe0e STM32CubeProgrammer (previous name was ST-Link Utility) provides an easy-to-use and efficient environment for reading, writing and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART, USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as Flash, RAM, and OTP) as well as external memories. Download STM32CubeProgrammer STM32CubeProgrammer User Manual STM32 Programmer 3.1. Target connection \u2693\ufe0e On the original development boards, please select ST-LINK interface, and then select either SWD or JTAG port. If the custom board has an USB port with Device Firmware Update mode, it can be connected on the USB interface. Before pressing Connect on the software, find on the board to press and hold the Boot button (Boot0 or Boot1) and press Reset button (NRST) to make device run into DFU mode. Different connections 3.2. Erase and Program \u2693\ufe0e Once connected to a target, the memory sectors are displayed in the right-hand panel showing the start address and the size of each sector. To erase one or more sectors, select them in the first column and then click on the Erase selected sectors button. To download firmware to the target chip, select the Erasing & Programming tab. Click on the browse button and select the file to be programmed. The file format supported are binary files (.bin), ELF files (.elf, .axf, .out), Intel hex files (.hex) and Motorola S-record files (.Srec). In case of programming a binary file, the address must be set. 3.3. Other features \u2693\ufe0e Other advanced features will be covered in other posts. Here is the list of those features: Option Bytes CPU Instruction debug Serial Wire View Fault Analyzer External Flash programming Program a binary file 4. STM32CubeMonitor \u2693\ufe0e The STM32CubeMonitor helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. It provides a flow-based graphical editor to build custom dashboards simply, and quickly add widgets such as gauges, bar graphs and plots. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling. Download STM32CubeMonitor STM32CubeMonitor Guide This tool use SWD/JTAG interface to access the memory addresses and read their value. The block editor When start the tool, there is a basic flow created with: Start/ Stop/ Clear buttons myVariables block holds the addresses under monitoring myProbe_Out block has configs to connect to the target device through debug interface myProbe_In block has script to read the value of the addresses listed in the myVariables block myVariables processing block read the captured value and process it myChart displays the dashboard which visualizes the processed data To configure a block, double click on it, and follow the guide. The steps go through file selection, variable list, connect probe, and assign probe. To demonstrate how it works, add a counter variable of type char as a global variable in the main.c file. In the main loop, increase the counter value every 100ms. This variable will be shown in the list of variables after selecting the compiled .elf firmware file. Configure the variable block Connect the target board via ST-LINK or other SWD/ JTAG compatible debugger. The debugger will be shown a probe in Cube Monitor. Select the protocol and assign to the in or out probe. Configure the probe block The chart can be drawn in line or bar chart. At this time, just use a default one. Finally, press on Deploy to configure the probes, and then click on Dashboard to show the graphical interface. Start button will send start message to the probe and variable processing block. The captured data will be drawn on the chart. The interactive dashboard 5. Other tools \u2693\ufe0e There are many other tools that work on ARM cores. I will have other posts to share about those tools such as Cross Compiler, Config File, Make File, or System View.","title":"Toolchain"},{"location":"blog/stm32/tools/#1-stm32-ecosystem","text":"A tool-chain is a set of programming tools that allow developers to: Configure the settings on the target MCU Write code and navigate inside source files of the project Inspect the code to show additional information about variables, function definitions, etc. Compile the source code to an executable application Program the target MCU Debug the application running on the target MCU Monitor the application on the target MCU The STM32Cube ecosystem is a complete software solution for STM32 microcontrollers and microprocessors. It has a complete toolchain and extended packages to well support developers on STM32 MCUs. STM32 Ecosystem STM32CubeMX , a configuration tool for any STM32 device. This easy-to-use graphical user interface generates initialization C code for Cortex-M cores and generates the Linux device tree source for Cortex-A cores. STM32CubeIDE , an Integrated Development Environment. Based on open-source solutions like Eclipse or the GNU C/C++ toolchain, this IDE includes compilation reporting features and advanced debug features. It also integrate additional features present in other tools from the ecosystem, such as the HW and SW initialization and code generation from STM32CubeMX. This software includes: Eclipse IDE - an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross Compiler, GDB Hardware Debugger, Make and build scripts. GNU ARM Cross-compiler with ST patch for STM32 MCUs - a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex). GDB for inspecting, debugging the target application. STM32CubeProgrammer , a programming tool. It provides an easy-to-use and efficient environment for reading, writing and verifying devices and external memories via a wide variety of available communication media (JTAG, SWD, UART, USB DFU, I2C, SPI, CAN, etc.). STM32CubeMonitor , a monitoring tool. Powerful monitoring tools that help developers fine-tune the behavior and performance of their applications in real time. STM32Cube MCU and MPU packages , dedicated to each STM32 series. Packages offer all the required embedded software bricks to operate the available set of STM32 peripherals. They include drivers (HAL, low-layer, etc.), middleware, and lots of example code used in a wide variety of real-world use cases. STM32Cube expansion packages , for application-oriented solutions. Complementing and expanding the STM32Cube MCU Package offer with additional embedded software bricks, STM32 expansion packages come either from ST or approved partners to create an extensive and scalable embedded software offer around the STM32. 4 steps of an interactive development process","title":"1. STM32 Ecosystem"},{"location":"blog/stm32/tools/#2-stmcubeide","text":"STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration, code generation, code compilation, and debug features for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC toolchain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. This tool includes the STM32CubeMX for code generation. At any time during the development, the user can return to the initialization and configuration of the peripherals or middleware and regenerate the initialization code with no impact on the user code written in the user blocks. STM32CubeIDE includes build and stack analyzers that provide the user with useful information about project status and memory requirements. STM32CubeIDE also includes standard and advanced debugging features including views of CPU core registers, memories, and peripheral registers, as well as live variable watch, Serial Wire Viewer interface, or fault analyzer. Other IDEs that support ARM Cortex: ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license","title":"2. STMCubeIDE"},{"location":"blog/stm32/tools/#21-installation","text":"Download STM32CubeIDE STM32CubeIDE User Manual During the installation, please be suare to install ST-LINK and SEGGER J-Link drivers.","title":"2.1. Installation"},{"location":"blog/stm32/tools/#22-create-a-workspace","text":"When start the program, it will ask to select a directory as a workspace - the location to save projects. Consider to make new workspaces for different big projects. Select a workspace Each workspace has its own Preferences settings under the Windows menu. Some personal settings Due to the generated code from CubeMX is 2-space tab width, it is better to configure the Text Editor to adapt with the tab width behavior in General \u2192 Editor \u2192 Text Editor : Displayed tab width: 2 Insert spaces for tabs: Checked Remove multiple spaces on backspace/delete: Checked There are some options for Code Analysis under the C/C++ \u2192 Build . I recommended to enable some check for Potential Programming Problems : Assignment in condition if ( a = b ) No return in a function which is declared to return a value int func (){} Return without value int func(){ return;} Return the address of a local variable int* func(){int a; return &a;} Virtual method call in constructor/ destructor Next is the formatting style under the option C/C++ \u2192 Code Style \u2192 Formatter : Create a new profile from K&R In the Indentation , change Tab Policy to Space Only; then set Indentation size and Tab size both to 2. Finally, it should increase the buffer for terminals in Terminal option to 1000 or more.","title":"2.2. Create a workspace"},{"location":"blog/stm32/tools/#23-create-a-project","text":"It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. When start a new STM32 project, IDE shows up the Device Finder screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. The first project I am using a STM32F0-Discovery board (STM32F051R8) to make an example project for this post. This project does not require any knowledge about the target microprocessor, as it will be written like a normal C application. Select the target MCU by name After selecting the microprocessor, it\u2019s time to name the project, and select the STM32Cube MCU packages version for the selected target. In this example, it is STM32Cube FW F0 v1.11.2 . Set name and select firmware package for a new project Press on Finish then IDE will run a screen named Device Configuration Tool from the CubeMX tool, in there, it\u2019s easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board - usually including ST-Link pins, on-board buttons, LEDs, USB connect.","title":"2.3. Create a project"},{"location":"blog/stm32/tools/#24-stm32cubemx","text":"STM32CubeMX is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\u00ae Cortex\u00ae-M cores. STM32CubeMX User Manual STM32CubeMX allows the user to create, save and load previously saved projects. MCU configuration .ioc file is saved in the project folder, and user can open it in CubeMX for editing.","title":"2.4. STM32CubeMX"},{"location":"blog/stm32/tools/#241-pinout-configuration","text":"This tab shows available Components in categories or in A-Z list. Select on a component will show its Configuration screen. The large Pinout view show a graphic representation of the pin assignment. Left-click to select the function, and Right-click to do extra actions such as assigning a custom name. The Pinout config screen","title":"2.4.1. Pinout Configuration"},{"location":"blog/stm32/tools/#242-clock-configuration","text":"This tab provides a schematic overview of the clock paths, clock sources, dividers, and multipliers. Drop-down menus and buttons can be used to modify the actual clock tree configuration, to meet the application requirements. IDE has ability to automatically calculate multipliers and dividers to provide requested frequency, user can set a desired frequency in the clock node, and press enter, then IDE will re-configure the PLL, pre-scaler. The frequency on each node can be locked via the right-click menu. The Clock config screen","title":"2.4.2. Clock Configuration"},{"location":"blog/stm32/tools/#243-project-manager","text":"This tab provides information about general project setting: to specify the project name, location, toolchain, and firmware version. It also has configs for code generation options such as the location of peripheral initialization code, library copy/link options, and to select templates for customized code. The Project config view","title":"2.4.3. Project Manager"},{"location":"blog/stm32/tools/#244-code-generation","text":"After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing Alt + K or choosing menu Project \u2192 Generate Code . The tool will create sub-folders and add necessary files into project. The general file structure is: \u2514\u2500\u2500\u2500Core \u2502 \u251c\u2500\u2500\u2500Inc \u2502 \u251c\u2500\u2500\u2500Src \u2502 \u2514\u2500\u2500\u2500Startup \u2514\u2500\u2500\u2500Drivers \u2514\u2500\u2500\u2500CMSIS \u2502 \u2514\u2500\u2500\u2500Device \u2502 \u2502 \u2514\u2500\u2500\u2500ST \u2502 \u2502 \u2514\u2500\u2500\u2500STM32F0xx \u2502 \u2502 \u2514\u2500\u2500\u2500Include \u2502 \u2502 \u2514\u2500\u2500\u2500Source \u2502 \u2502 \u2514\u2500\u2500\u2500Templates \u2502 \u2514\u2500\u2500\u2500Include \u2514\u2500\u2500\u2500STM32F0xx_HAL_Driver \u2514\u2500\u2500\u2500Inc \u2502 \u2514\u2500\u2500\u2500Legacy \u2514\u2500\u2500\u2500Src When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor and peripherals. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor\u2019s registers. In the Project Manager tab, it can change to use Low-Level (LL) library instead of HAL. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. The main function is called from the startup file startup_*.s . Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Toolchain specific file that contains reset handler and exception vectors. For some toolchains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library).This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and de-initialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL timebase. By default, this function is called each 1ms in Systick ISR.The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 set system clock configuration \u2022 declare peripheral HAL initialization \u2022 user application code.","title":"2.4.4. Code generation"},{"location":"blog/stm32/tools/#25-add-user-code","text":"User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. I am going to add a variable counter with type of char , then inside the main while loop in the main() function, increase it by 1 after 100ms. Don\u2019t mind the HAL function at this time. main.c /* USER CODE BEGIN PV */ char counter = 0 ; /* USER CODE END PV */ int main ( void ) { /* other setup function */ /* USER CODE BEGIN WHILE */ while ( 1 ) { counter ++ ; HAL_Delay ( 100 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ }","title":"2.5. Add user code"},{"location":"blog/stm32/tools/#26-compiler-options","text":"Project has options for the compiler under its properties. Right-click on the project name in the right panel, then select Properties menu. The default included folders are all the folders created in the project by the CubeMX tool. There are also some symbols created for the project build, such DEBUG mode, or the MCU name STM32F051x8 . The including paths and symbols Then in the Build Options, there are options to be used by GCC complier, GNU Linker, GNU Assembler. Build options","title":"2.6. Compiler options"},{"location":"blog/stm32/tools/#27-build-project","text":"Build the application by pressing Ctrl + B , or in menu Project \u2192 Build All . There are some reports about the resource usage to check after the compilation. The first thing it reports is the memory usage, in term of RAM and FLASH free space.","title":"2.7. Build Project"},{"location":"blog/stm32/tools/#28-setup-debugger","text":"Before Run or Debug on the target chip, it is needed to configure the programming/ debugging interface. By default, the application code can be programmed through the debugger interface, therefore, in Run Config or Debug Config, there is a tab named Debugger to select: Debug Probe: ST-LINK GDB, ST-LINK OpenOCD, SEGGER J-LINK, or other available probes Interface: SWD or JTAG. If there are multiple boards connected, use debugger board Serial Number to choose the correct target Advanced features: Serial Wire Viewer: read data from MCU in a dedicated SW0 pin, available on Cortext-M3 and above Live Expression: read out the value at a memory address without halting the CPU Setup Debugger","title":"2.8. Setup debugger"},{"location":"blog/stm32/tools/#29-run-mode","text":"In the Run Mode, IDE flashes the firmware via the Debugging interface, and then disconnect the debugger to make the target board run freely. Just use the menu Run \u2192 Run .","title":"2.9. Run Mode"},{"location":"blog/stm32/tools/#210-debug-mode","text":"Putting the target under the Debug Mode is to control its execution, step by step. Breakpoint is where the CPU will be halted and debugger will inspect its current status: registers, memory values. By default, the first breakpoint is right after entering the main function. The start address and the first break point can be set in the Startup tab in Debug Configurations. Startup option for debug When CPU is halted at a breakpoint, user can control the execution step by step, through the commands or buttons: Debug controls","title":"2.10. Debug Mode"},{"location":"blog/stm32/tools/#3-stm32cubeprogrammer","text":"STM32CubeProgrammer (previous name was ST-Link Utility) provides an easy-to-use and efficient environment for reading, writing and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART, USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as Flash, RAM, and OTP) as well as external memories. Download STM32CubeProgrammer STM32CubeProgrammer User Manual STM32 Programmer","title":"3. STM32CubeProgrammer"},{"location":"blog/stm32/tools/#31-target-connection","text":"On the original development boards, please select ST-LINK interface, and then select either SWD or JTAG port. If the custom board has an USB port with Device Firmware Update mode, it can be connected on the USB interface. Before pressing Connect on the software, find on the board to press and hold the Boot button (Boot0 or Boot1) and press Reset button (NRST) to make device run into DFU mode. Different connections","title":"3.1. Target connection"},{"location":"blog/stm32/tools/#32-erase-and-program","text":"Once connected to a target, the memory sectors are displayed in the right-hand panel showing the start address and the size of each sector. To erase one or more sectors, select them in the first column and then click on the Erase selected sectors button. To download firmware to the target chip, select the Erasing & Programming tab. Click on the browse button and select the file to be programmed. The file format supported are binary files (.bin), ELF files (.elf, .axf, .out), Intel hex files (.hex) and Motorola S-record files (.Srec). In case of programming a binary file, the address must be set.","title":"3.2. Erase and Program"},{"location":"blog/stm32/tools/#33-other-features","text":"Other advanced features will be covered in other posts. Here is the list of those features: Option Bytes CPU Instruction debug Serial Wire View Fault Analyzer External Flash programming Program a binary file","title":"3.3. Other features"},{"location":"blog/stm32/tools/#4-stm32cubemonitor","text":"The STM32CubeMonitor helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. It provides a flow-based graphical editor to build custom dashboards simply, and quickly add widgets such as gauges, bar graphs and plots. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling. Download STM32CubeMonitor STM32CubeMonitor Guide This tool use SWD/JTAG interface to access the memory addresses and read their value. The block editor When start the tool, there is a basic flow created with: Start/ Stop/ Clear buttons myVariables block holds the addresses under monitoring myProbe_Out block has configs to connect to the target device through debug interface myProbe_In block has script to read the value of the addresses listed in the myVariables block myVariables processing block read the captured value and process it myChart displays the dashboard which visualizes the processed data To configure a block, double click on it, and follow the guide. The steps go through file selection, variable list, connect probe, and assign probe. To demonstrate how it works, add a counter variable of type char as a global variable in the main.c file. In the main loop, increase the counter value every 100ms. This variable will be shown in the list of variables after selecting the compiled .elf firmware file. Configure the variable block Connect the target board via ST-LINK or other SWD/ JTAG compatible debugger. The debugger will be shown a probe in Cube Monitor. Select the protocol and assign to the in or out probe. Configure the probe block The chart can be drawn in line or bar chart. At this time, just use a default one. Finally, press on Deploy to configure the probes, and then click on Dashboard to show the graphical interface. Start button will send start message to the probe and variable processing block. The captured data will be drawn on the chart. The interactive dashboard","title":"4. STM32CubeMonitor"},{"location":"blog/stm32/tools/#5-other-tools","text":"There are many other tools that work on ARM cores. I will have other posts to share about those tools such as Cross Compiler, Config File, Make File, or System View.","title":"5. Other tools"},{"location":"blog/stm32/uart/","text":"UART in Polling mode UART in Interrupt mode UART in DMA mode 1. Hardware \u2693\ufe0e Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire. 1.1. Wires \u2693\ufe0e When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pairs of lines for Transmitter (TX) and Receiver (RX): USART vs UART 1.2. Flow control \u2693\ufe0e The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485, provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send (RTS) and Clear To Send (CTS) : the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line. 1.3. Data frame \u2693\ufe0e The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) least significant bit first A 0.5, 1, 1.5, or 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART 1.4. Clock \u2693\ufe0e The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC)) ). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling 1.5. Baud rate \u2693\ufe0e Baud rate determines the speed of transmitting and receiving, as the speed is depend on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV . When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with core clock frequency at 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value. 1.6. Multiprocessor \u2693\ufe0e In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL , IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master. 2. STM32Cube HAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle Init structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,\u2026) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API. 3. Lab 1: Polling mode \u2693\ufe0e This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the most simple form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Requirements : Increase a counter by 1 and print its value to UART1 every second Get user commands: stop to pause increasing the counter resume to resume increasing the counter Target board : Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC9 GPIO Output Green LED 3.1. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire or Trace Asynchronous SW 3.2. Enable USART1 \u2693\ufe0e Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 bits (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout. 3.3. Generated code \u2693\ufe0e When generate code from configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Init functions The function SystemClock_Config() is included to setup the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() inits the USART1 instance with the values put into the init struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the init params and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will setup the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } } 3.4. Send data \u2693\ufe0e With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let\u2019s create a buffer, a counter variable, and make a message to send every second. #include <stdio.h> // sprintf #include <string.h> // strlen char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r int main ( void ) { while ( 1 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } } 3.5. Connect UART to PC \u2693\ufe0e Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter go get UART data. Connect pins PA9 and PA10 to UART terminal on PC. It\u2019s recommend to check the voltage because MCU board is running at 3.3V while PC USB or COM port might be running at 5V. Another option is to use an Arduino Uno board with RESET pin connected to GND, and use its TX, RX pins which are connected to the Arduino Virtual COM port. Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyser to see raw bits transferred in RX and TX pins. UART output on digital logic analyser UART output in a terminal 3.6. Receive data \u2693\ufe0e Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Use the function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 4, 2000) to read the input, which means: All received data is written into buffer Function will exit if one of the below condition meets: 4 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let\u2019s modify the code to get helper functions and process input in main while loop: char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; const char MSG_OK [] = \"OK \\n\\r \" ; const char MSG_BUSY [] = \"BUSY \\n\\r \" ; const char MSG_ERROR [] = \"ERROR \\n\\r \" ; const char MSG_TIMEOUT [] = \"TIMEOUT \\n\\r \" ; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } HAL_StatusTypeDef Read ( char * buffer , int n ) { HAL_StatusTypeDef ret = HAL_TIMEOUT ; ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , n , 2000 ); if ( ret == HAL_OK ) { Write ( MSG_OK ); } else if ( ret == HAL_BUSY ) { Write ( MSG_BUSY ); } else if ( ret == HAL_ERROR ) { Write ( MSG_ERROR ); } else if ( ret == HAL_TIMEOUT ) { Write ( MSG_TIMEOUT ); } return ret ; } int main ( void ) { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } Read ( buffer , 4 ); if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( buffer , \"resu\" , 4 ) == 0 ) { Read ( buffer , 2 ); if ( strncmp ( buffer , \"me\" , 2 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } } } Receive user\u2019s input Bug: Uncontrollable input It\u2019s hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR). 4. Lab 2: Interrupt Mode \u2693\ufe0e 4.1. Interruptions \u2693\ufe0e Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The CubeHAL is designed to automatically do that job. Then user is warned about the interrupt thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() . From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() functions are designed so that they do not wait for data transmission completion, but the job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated. 4.2. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1. 4.3. Enable interrupt \u2693\ufe0e Go to USART1 module, select NVIC Settings tab and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); } 4.4. Send data with interrupt \u2693\ufe0e As said above, use HAL_UART_Transmit_IT() function to send data. main.c char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( buffer ); } HAL_Delay ( 1000 ); } } Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , strlen ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , strlen ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , strlen ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail as it will see that UART is in the Busy state. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , strings [ i ], strlen ( strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } When all data in the buffer are sent, HAL library will call to a callback function named HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transfered . This function can be overridden to do something after the buffer is transmitted. main.c char uart_tx_done = 0 ; void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_tx_done = 1 ; } } 4.5. Receive data with interrupt \u2693\ufe0e Next step is to read data using interrupt with the function HAL_UART_Receive_IT() . Because it\u2019s unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in the sprinf() function, therefore, should use a new buffer to store received data, e.g. command . When the receiver get enough characters, it will fire an interrupt to run the HAL_UART_RxCpltCallback() function. That function can be overridden to handle received data in the main: char uart_rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } In the main function, process received data only when the flag is on: char uart_rx_int = 0 ; char command [ 16 ] = { 0 }; const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; HAL_StatusTypeDef Read ( char * buffer , int n ) { return HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) buffer , n ); } void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( command , \"resume\" , 6 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } Read ( command , 6 ); HAL_Delay ( 1000 ); } } Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the new line / line feed \\n or carriage return \\r character to to determine input sentences. However, this will lead to run the interrupt handler many times if the incoming data rate is high. Here is an example to handle every byte in the Interrupt mode: Received one byte at a time Check the received by with the new line \\n character to separate strings Call Receive function again to listen to a new character char rx_buffer [ 16 ] = { 0 }; int rx_idx = 0 ; char rx = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( rx == '\\n' ) { rx_buffer [ rx_idx ] = '\\0' ; strncpy ( command , rx_buffer , 16 ); rx_idx = 0 ; uart_rx_int = 1 ; } else { rx_buffer [ rx_idx ++ ] = rx ; } Read ( & rx , 1 ); } int main ( void ) { Read ( & rx , 1 ); while ( 1 ) { if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) {...} } } } This approach can be optimized more by not using the HAL function (both HAL_UART_Receive_IT() and HAL_UART_IRQHandler() ), but by setting up UART_IT_RXNE (Received Data Not Empty) interrupt and then handle this interrupt manually in the USART1_IRQHandler() ISR. __HAL_UART_ENABLE_IT ( & huart1 , UART_IT_RXNE ); void USART1_IRQHandler ( void ) { handle_received_byte (); } 5. Lab 3: DMA mode \u2693\ufe0e The DMA can be used to transfer data in or out through an UART interface. However, DMA still needs to know how many bytes of data should be exchanged. In case of transmitting, it is easy to calculate the length of data, but in case of receiving, it maybe unknown length of data. 5.1. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1. 5.2. Enable DMA \u2693\ufe0e Go to USART1 module, select DMA Settings tab and Add two DMA requests: USART1_TX : This DMA Request has direction of Memory to Peripheral, it means DMA processor will read data from Memory and write to the USART1 Transmit Data Register, therefore, only Memory Address will be increased USART1_RX : This DMA Request has direction of Peripheral to Memory, it means DMA processor will read data from USART1 Receive Data Register and write to Memory, therefore, only Memory Address will be increased DMA only works when the peripheral\u2019s interrupt is enabled, as it needs triggered from the peripheral. Make sure to enable USART1 global / wake-up interrupts through the external interrupt line. Note that CubeMX automatically enable DMA interrupts. To disable it, go to NVIC module under the System Core category. After generating code, there is a new function MX_DMA_Init() added to the main.c file to initialize the DMA module: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* DMA interrupt init */ /* DMA1_Channel2_3_IRQn interrupt configuration */ HAL_NVIC_SetPriority ( DMA1_Channel2_3_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( DMA1_Channel2_3_IRQn ); } Enable DMA requests on USART1 Inside the HAL_UART_MspInit() function, there are calls to init DMA instances for USART1_TX and USART1_RX, and finally links of DMA instances with the USART instance with the function __HAL_LINKDMA . void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { ... /* DMA USART1_RX Init */ hdma_usart1_rx . Instance = DMA1_Channel3 ; hdma_usart1_rx . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_usart1_rx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_rx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_rx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_rx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_rx . Init . Mode = DMA_NORMAL ; hdma_usart1_rx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_rx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmarx , hdma_usart1_rx ); /* DMA USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); /* USART1 interrupt Init */ HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); } There is also an implementation for DMA interrupt in the file stm32f0xx_it.c which calls to the HAL_DMA_IRQHandler() function. There is no default callback for DMA. User has to set the callbacks manually , as described in the DMA Interrupts section. However, HAL functions will assign a callback when they need to handle an interrupt. 5.3. Send data with DMA \u2693\ufe0e Sending data with DMA is quite easy, just provide the tx_buffer and the length of data to the function HAL_UART_Transmit_DMA() . #define DMA_BUFFER_MAX 16 char tx_buffer [ DMA_BUFFER_MAX ] = { 0 }; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( tx_buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( tx_buffer ); } HAL_Delay ( 1000 ); } } There are two interrupts will be fired for transmission, which are helpful when sending a huge amount of data: DMA notifies application to start loading new data into the first half of the buffer afther the TxHalfCpltCallback is fired, while the second half of the buffer is being transmitted by the DMA; then application can load the new data into the second half of the buffer after the TxCpltCallback is fired, while the first half is being transmitted. Using DMA mode can significantly resude the number of UART interrupts, comparing to using Interrupt mode. If there is a variable to keep track of the numbers of UART interrupts, for example in the below code, this number will be increased for every bytes in the transmitting buffer in Interrupt mode (each byte sent causes an interrupt to load the next byte). However, in DMA mode, there is only one interrupt added only when the buffer is completely transfered. size_t uart_irq_counter = 0 ; void USART1_IRQHandler ( void ) { uart_irq_counter ++ ; } 5.4. Receive data with DMA \u2693\ufe0e Nomally, when calling to HAL_UART_Receive_DMA() , the DMA module will stop transfering data when it counts enough bytes set in the params. There is the Circular mode that makes DMA continouses get data and fills into memory like a ring buffer. Go back to the DMA Settings tab of the USART1 module to set the mode of USART1_RX request to Circular. Enable Circular mode for DMA on USART1_RX Then create a buffer for receiving data, and start DMA Request in the main function: #define DMA_BUFFER_MAX 16 char rx_buffer [ DMA_BUFFER_MAX ] = { 0 }; int main ( void ) { HAL_UART_Receive_DMA ( & huart1 , ( uint8_t * ) rx_buffer , DMA_BUFFER_MAX ); while ( 1 ) {...} } By calling the HAL_UART_Receive_DMA() function, USART1_RX DMA instance will get some callback functions assigned to its Half-transfer and Full-Transfer callbacks. Refer to the function UART_Start_Receive_DMA() for more details. It is possible to configure DMA to transfer one byte at a time and call to an interrupt function to hanlde the newly received character like in Interrupt mode, but it wastes of resource and performance. However, if application lets DMA to notify only then it receives enough the required number of characrers, sometimes there is no notification sent. Assume that application expects to receive 20 chars, but UART only receives 14 chars: Application would be notified when 10 bytes received by Half-Transfer event Application would never be notified the rest of 4 bytes has arrived If UART get more chars, application would be nofified by Full-Transfer event but some chars may be left over 5.5. UART IDLE Detection \u2693\ufe0e Most of STM32 series have USARTs with IDLE Line detection. If IDLE Line detection is not available, some of them have Receiver Timeout feature with programmable delay. IDLE line detection (or Receiver Timeout) can trigger USART interrupt when receive line is steady without any communication for at least 1 character for reception. IDLE Detection Right after enable the UART, the IDLE bit in Interrupt Status Register ISR will be set. However, the interrupt for IDLE detection only gets fired when the bit IDLEIE is set on the Control Register CRx . Therefore, the IDLE interrupt always fire up once rigth after the bit IDLEIE is set. To clear the IDLE interrupt status, either set the IDLECF in the Clear Register or do a read sequence on SR and DR registers. Refer to the Reference Manual documents to get more detail. When IDLE dection is enable, make sure the RX line is not floating to prevent the IDLE flag from being set continuously. DMA RX and IDLE Line detection The good combination for using DMA to get unknown length of data is to use DMA in Circular mode, with big enough memory buffer, then use DMA Half-Transfer, Full-Transfer and the IDLE line dectection to notify application to process received data. HAL DMA Receiving function automatically notifies the application by calling HAL_UART_RxHalfCpltCallback() and HAL_UART_RxCpltCallback() . Therefore, it is only needed to override the USART1_IRQHandler() function. To more simple and still left HAL Hanlder processes other cases, it is better to add a small code just to check the IDLE flag and process received data before handing over the interrupt to original HAL_UART_IRQHandler() function. stm32f0xx_it.c void USART1_IRQHandler ( void ) { if ((( & huart1 ) -> Instance -> ISR & UART_FLAG_IDLE ) != 0 && (( & huart1 ) -> Instance -> CR1 & USART_CR1_IDLEIE ) != 0 ) { __HAL_UART_CLEAR_IDLEFLAG ( & huart1 ); HAL_UART_RxCpltCallback ( & huart1 ); } // pass the work to HAL function HAL_UART_IRQHandler ( & huart1 ); } main.c void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } void HAL_UART_RxHalfCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } 5.6. Process continuous received data \u2693\ufe0e Due to DMA buffer is a Ring buffer with small number of bytes, it is necessary to copy received bytes from DMA buffer to a bigger UART buffer. There are 2 indexes to mark the bytes position in DMA buffer: new_pos at the last received byte, and old_pos at last processed byte. There is one index uart_index to mark the last byte in the UART buffer. Visualization of memory copy between DMA buffer and UART buffer In DMA buffer, if the new_pos is bigger than the old_pos , it means there is no roll-over, application can copy bytes [ old_pos : new_pos ] to the UART buffer. In DMA buffer, if the new_pos is less than the old_pos , it means there is a roll-over, application can copy bytes [ old_pos : max ] and [0: new_pos ] to the UART buffer. In UART buffer, when buffer is full, it does not get any more character, only character new line \\n will reset the index to 0 To get the new_pos index, aka. number of received bytes, use the register CNDTR of the DMA instance. Read more about \u201cDMA channel x number of data register ( DMA_CNDTRx and DMA2_CNDTRx )\u201d section in the Reference Manual document. Here is the implementation example for the above solution of processing the received data: #define UART_BUFFER_MAX 64 char uart_buffer [ UART_BUFFER_MAX ] = { 0 }; size_t uart_buffer_idx = 0 ; char uart_new_string = 0 ; void UART_RX_Process ( const void * data , size_t len ) { for ( int i = 0 ; i < len ; i ++ ) { char c = (( char * ) data )[ i ]; if ( uart_buffer_idx < UART_BUFFER_MAX -2 ) { uart_buffer [ uart_buffer_idx ++ ] = c ; uart_buffer [ uart_buffer_idx ] = '\\0' ; } if ( c == '\\n' ) { uart_buffer_idx = 0 ; uart_new_string = 1 ; } } } void UART_RX_Check ( DMA_HandleTypeDef * hdma ) { static size_t old_pos = 0 ; size_t rx_pos = DMA_BUFFER_MAX - hdma -> Instance -> CNDTR ; if ( rx_pos != old_pos ) { // new data if ( rx_pos > old_pos ) { // no overflow UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos - old_pos ); } else { // overflow UART_RX_Process ( & rx_buffer [ old_pos ], DMA_BUFFER_MAX - old_pos ); if ( rx_pos > 0 ) { // run up UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos ); } } old_pos = rx_pos ; } } int main ( void ) { while ( 1 ) { if ( uart_new_string == 1 ) { uart_new_string = 0 ; if ( strncmp ( uart_buffer , \"stop\" , 4 ) == 0 ) {...} } } } This tutorial only show a method to process variale string length in a continuous byte stream. The function UART_RX_Process() should be modified to handle different streaming format. Compile and run with variable string length to find how it work. Below captured image was in a debug section to see how many IDLE interrupts are called, how received bytes are saved into the rx_buffer and to monitor the uart_buffer . Communicate with UART in DMA mode","title":"UART"},{"location":"blog/stm32/uart/#1-hardware","text":"Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire.","title":"1. Hardware"},{"location":"blog/stm32/uart/#11-wires","text":"When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pairs of lines for Transmitter (TX) and Receiver (RX): USART vs UART","title":"1.1. Wires"},{"location":"blog/stm32/uart/#12-flow-control","text":"The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485, provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send (RTS) and Clear To Send (CTS) : the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line.","title":"1.2. Flow control"},{"location":"blog/stm32/uart/#13-data-frame","text":"The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) least significant bit first A 0.5, 1, 1.5, or 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART","title":"1.3. Data frame"},{"location":"blog/stm32/uart/#14-clock","text":"The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC)) ). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling","title":"1.4. Clock"},{"location":"blog/stm32/uart/#15-baud-rate","text":"Baud rate determines the speed of transmitting and receiving, as the speed is depend on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV . When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with core clock frequency at 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value.","title":"1.5. Baud rate"},{"location":"blog/stm32/uart/#16-multiprocessor","text":"In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL , IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master.","title":"1.6. Multiprocessor"},{"location":"blog/stm32/uart/#2-stm32cube-hal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle Init structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,\u2026) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API.","title":"2. STM32Cube HAL Usage"},{"location":"blog/stm32/uart/#3-lab-1-polling-mode","text":"This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the most simple form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Requirements : Increase a counter by 1 and print its value to UART1 every second Get user commands: stop to pause increasing the counter resume to resume increasing the counter Target board : Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC9 GPIO Output Green LED","title":"3. Lab 1: Polling mode"},{"location":"blog/stm32/uart/#31-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire or Trace Asynchronous SW","title":"3.1. Start a new project"},{"location":"blog/stm32/uart/#32-enable-usart1","text":"Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 bits (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout.","title":"3.2. Enable USART1"},{"location":"blog/stm32/uart/#33-generated-code","text":"When generate code from configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Init functions The function SystemClock_Config() is included to setup the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() inits the USART1 instance with the values put into the init struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the init params and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will setup the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } }","title":"3.3. Generated code"},{"location":"blog/stm32/uart/#34-send-data","text":"With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let\u2019s create a buffer, a counter variable, and make a message to send every second. #include <stdio.h> // sprintf #include <string.h> // strlen char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r int main ( void ) { while ( 1 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } }","title":"3.4. Send data"},{"location":"blog/stm32/uart/#35-connect-uart-to-pc","text":"Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter go get UART data. Connect pins PA9 and PA10 to UART terminal on PC. It\u2019s recommend to check the voltage because MCU board is running at 3.3V while PC USB or COM port might be running at 5V. Another option is to use an Arduino Uno board with RESET pin connected to GND, and use its TX, RX pins which are connected to the Arduino Virtual COM port. Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyser to see raw bits transferred in RX and TX pins. UART output on digital logic analyser UART output in a terminal","title":"3.5. Connect UART to PC"},{"location":"blog/stm32/uart/#36-receive-data","text":"Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Use the function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 4, 2000) to read the input, which means: All received data is written into buffer Function will exit if one of the below condition meets: 4 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let\u2019s modify the code to get helper functions and process input in main while loop: char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; const char MSG_OK [] = \"OK \\n\\r \" ; const char MSG_BUSY [] = \"BUSY \\n\\r \" ; const char MSG_ERROR [] = \"ERROR \\n\\r \" ; const char MSG_TIMEOUT [] = \"TIMEOUT \\n\\r \" ; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } HAL_StatusTypeDef Read ( char * buffer , int n ) { HAL_StatusTypeDef ret = HAL_TIMEOUT ; ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , n , 2000 ); if ( ret == HAL_OK ) { Write ( MSG_OK ); } else if ( ret == HAL_BUSY ) { Write ( MSG_BUSY ); } else if ( ret == HAL_ERROR ) { Write ( MSG_ERROR ); } else if ( ret == HAL_TIMEOUT ) { Write ( MSG_TIMEOUT ); } return ret ; } int main ( void ) { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } Read ( buffer , 4 ); if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( buffer , \"resu\" , 4 ) == 0 ) { Read ( buffer , 2 ); if ( strncmp ( buffer , \"me\" , 2 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } } } Receive user\u2019s input Bug: Uncontrollable input It\u2019s hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR).","title":"3.6. Receive data"},{"location":"blog/stm32/uart/#4-lab-2-interrupt-mode","text":"","title":"4. Lab 2: Interrupt Mode"},{"location":"blog/stm32/uart/#41-interruptions","text":"Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The CubeHAL is designed to automatically do that job. Then user is warned about the interrupt thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() . From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() functions are designed so that they do not wait for data transmission completion, but the job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated.","title":"4.1. Interruptions"},{"location":"blog/stm32/uart/#42-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1.","title":"4.2. Start a new project"},{"location":"blog/stm32/uart/#43-enable-interrupt","text":"Go to USART1 module, select NVIC Settings tab and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); }","title":"4.3. Enable interrupt"},{"location":"blog/stm32/uart/#44-send-data-with-interrupt","text":"As said above, use HAL_UART_Transmit_IT() function to send data. main.c char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( buffer ); } HAL_Delay ( 1000 ); } } Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , strlen ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , strlen ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , strlen ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail as it will see that UART is in the Busy state. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , strings [ i ], strlen ( strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } When all data in the buffer are sent, HAL library will call to a callback function named HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transfered . This function can be overridden to do something after the buffer is transmitted. main.c char uart_tx_done = 0 ; void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_tx_done = 1 ; } }","title":"4.4. Send data with interrupt"},{"location":"blog/stm32/uart/#45-receive-data-with-interrupt","text":"Next step is to read data using interrupt with the function HAL_UART_Receive_IT() . Because it\u2019s unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in the sprinf() function, therefore, should use a new buffer to store received data, e.g. command . When the receiver get enough characters, it will fire an interrupt to run the HAL_UART_RxCpltCallback() function. That function can be overridden to handle received data in the main: char uart_rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } In the main function, process received data only when the flag is on: char uart_rx_int = 0 ; char command [ 16 ] = { 0 }; const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; HAL_StatusTypeDef Read ( char * buffer , int n ) { return HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) buffer , n ); } void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( command , \"resume\" , 6 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } Read ( command , 6 ); HAL_Delay ( 1000 ); } } Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the new line / line feed \\n or carriage return \\r character to to determine input sentences. However, this will lead to run the interrupt handler many times if the incoming data rate is high. Here is an example to handle every byte in the Interrupt mode: Received one byte at a time Check the received by with the new line \\n character to separate strings Call Receive function again to listen to a new character char rx_buffer [ 16 ] = { 0 }; int rx_idx = 0 ; char rx = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( rx == '\\n' ) { rx_buffer [ rx_idx ] = '\\0' ; strncpy ( command , rx_buffer , 16 ); rx_idx = 0 ; uart_rx_int = 1 ; } else { rx_buffer [ rx_idx ++ ] = rx ; } Read ( & rx , 1 ); } int main ( void ) { Read ( & rx , 1 ); while ( 1 ) { if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) {...} } } } This approach can be optimized more by not using the HAL function (both HAL_UART_Receive_IT() and HAL_UART_IRQHandler() ), but by setting up UART_IT_RXNE (Received Data Not Empty) interrupt and then handle this interrupt manually in the USART1_IRQHandler() ISR. __HAL_UART_ENABLE_IT ( & huart1 , UART_IT_RXNE ); void USART1_IRQHandler ( void ) { handle_received_byte (); }","title":"4.5. Receive data with interrupt"},{"location":"blog/stm32/uart/#5-lab-3-dma-mode","text":"The DMA can be used to transfer data in or out through an UART interface. However, DMA still needs to know how many bytes of data should be exchanged. In case of transmitting, it is easy to calculate the length of data, but in case of receiving, it maybe unknown length of data.","title":"5. Lab 3: DMA mode"},{"location":"blog/stm32/uart/#51-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1.","title":"5.1. Start a new project"},{"location":"blog/stm32/uart/#52-enable-dma","text":"Go to USART1 module, select DMA Settings tab and Add two DMA requests: USART1_TX : This DMA Request has direction of Memory to Peripheral, it means DMA processor will read data from Memory and write to the USART1 Transmit Data Register, therefore, only Memory Address will be increased USART1_RX : This DMA Request has direction of Peripheral to Memory, it means DMA processor will read data from USART1 Receive Data Register and write to Memory, therefore, only Memory Address will be increased DMA only works when the peripheral\u2019s interrupt is enabled, as it needs triggered from the peripheral. Make sure to enable USART1 global / wake-up interrupts through the external interrupt line. Note that CubeMX automatically enable DMA interrupts. To disable it, go to NVIC module under the System Core category. After generating code, there is a new function MX_DMA_Init() added to the main.c file to initialize the DMA module: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* DMA interrupt init */ /* DMA1_Channel2_3_IRQn interrupt configuration */ HAL_NVIC_SetPriority ( DMA1_Channel2_3_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( DMA1_Channel2_3_IRQn ); } Enable DMA requests on USART1 Inside the HAL_UART_MspInit() function, there are calls to init DMA instances for USART1_TX and USART1_RX, and finally links of DMA instances with the USART instance with the function __HAL_LINKDMA . void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { ... /* DMA USART1_RX Init */ hdma_usart1_rx . Instance = DMA1_Channel3 ; hdma_usart1_rx . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_usart1_rx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_rx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_rx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_rx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_rx . Init . Mode = DMA_NORMAL ; hdma_usart1_rx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_rx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmarx , hdma_usart1_rx ); /* DMA USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); /* USART1 interrupt Init */ HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); } There is also an implementation for DMA interrupt in the file stm32f0xx_it.c which calls to the HAL_DMA_IRQHandler() function. There is no default callback for DMA. User has to set the callbacks manually , as described in the DMA Interrupts section. However, HAL functions will assign a callback when they need to handle an interrupt.","title":"5.2. Enable DMA"},{"location":"blog/stm32/uart/#53-send-data-with-dma","text":"Sending data with DMA is quite easy, just provide the tx_buffer and the length of data to the function HAL_UART_Transmit_DMA() . #define DMA_BUFFER_MAX 16 char tx_buffer [ DMA_BUFFER_MAX ] = { 0 }; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( tx_buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( tx_buffer ); } HAL_Delay ( 1000 ); } } There are two interrupts will be fired for transmission, which are helpful when sending a huge amount of data: DMA notifies application to start loading new data into the first half of the buffer afther the TxHalfCpltCallback is fired, while the second half of the buffer is being transmitted by the DMA; then application can load the new data into the second half of the buffer after the TxCpltCallback is fired, while the first half is being transmitted. Using DMA mode can significantly resude the number of UART interrupts, comparing to using Interrupt mode. If there is a variable to keep track of the numbers of UART interrupts, for example in the below code, this number will be increased for every bytes in the transmitting buffer in Interrupt mode (each byte sent causes an interrupt to load the next byte). However, in DMA mode, there is only one interrupt added only when the buffer is completely transfered. size_t uart_irq_counter = 0 ; void USART1_IRQHandler ( void ) { uart_irq_counter ++ ; }","title":"5.3. Send data with DMA"},{"location":"blog/stm32/uart/#54-receive-data-with-dma","text":"Nomally, when calling to HAL_UART_Receive_DMA() , the DMA module will stop transfering data when it counts enough bytes set in the params. There is the Circular mode that makes DMA continouses get data and fills into memory like a ring buffer. Go back to the DMA Settings tab of the USART1 module to set the mode of USART1_RX request to Circular. Enable Circular mode for DMA on USART1_RX Then create a buffer for receiving data, and start DMA Request in the main function: #define DMA_BUFFER_MAX 16 char rx_buffer [ DMA_BUFFER_MAX ] = { 0 }; int main ( void ) { HAL_UART_Receive_DMA ( & huart1 , ( uint8_t * ) rx_buffer , DMA_BUFFER_MAX ); while ( 1 ) {...} } By calling the HAL_UART_Receive_DMA() function, USART1_RX DMA instance will get some callback functions assigned to its Half-transfer and Full-Transfer callbacks. Refer to the function UART_Start_Receive_DMA() for more details. It is possible to configure DMA to transfer one byte at a time and call to an interrupt function to hanlde the newly received character like in Interrupt mode, but it wastes of resource and performance. However, if application lets DMA to notify only then it receives enough the required number of characrers, sometimes there is no notification sent. Assume that application expects to receive 20 chars, but UART only receives 14 chars: Application would be notified when 10 bytes received by Half-Transfer event Application would never be notified the rest of 4 bytes has arrived If UART get more chars, application would be nofified by Full-Transfer event but some chars may be left over","title":"5.4. Receive data with DMA"},{"location":"blog/stm32/uart/#55-uart-idle-detection","text":"Most of STM32 series have USARTs with IDLE Line detection. If IDLE Line detection is not available, some of them have Receiver Timeout feature with programmable delay. IDLE line detection (or Receiver Timeout) can trigger USART interrupt when receive line is steady without any communication for at least 1 character for reception. IDLE Detection Right after enable the UART, the IDLE bit in Interrupt Status Register ISR will be set. However, the interrupt for IDLE detection only gets fired when the bit IDLEIE is set on the Control Register CRx . Therefore, the IDLE interrupt always fire up once rigth after the bit IDLEIE is set. To clear the IDLE interrupt status, either set the IDLECF in the Clear Register or do a read sequence on SR and DR registers. Refer to the Reference Manual documents to get more detail. When IDLE dection is enable, make sure the RX line is not floating to prevent the IDLE flag from being set continuously. DMA RX and IDLE Line detection The good combination for using DMA to get unknown length of data is to use DMA in Circular mode, with big enough memory buffer, then use DMA Half-Transfer, Full-Transfer and the IDLE line dectection to notify application to process received data. HAL DMA Receiving function automatically notifies the application by calling HAL_UART_RxHalfCpltCallback() and HAL_UART_RxCpltCallback() . Therefore, it is only needed to override the USART1_IRQHandler() function. To more simple and still left HAL Hanlder processes other cases, it is better to add a small code just to check the IDLE flag and process received data before handing over the interrupt to original HAL_UART_IRQHandler() function. stm32f0xx_it.c void USART1_IRQHandler ( void ) { if ((( & huart1 ) -> Instance -> ISR & UART_FLAG_IDLE ) != 0 && (( & huart1 ) -> Instance -> CR1 & USART_CR1_IDLEIE ) != 0 ) { __HAL_UART_CLEAR_IDLEFLAG ( & huart1 ); HAL_UART_RxCpltCallback ( & huart1 ); } // pass the work to HAL function HAL_UART_IRQHandler ( & huart1 ); } main.c void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } void HAL_UART_RxHalfCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); }","title":"5.5. UART IDLE Detection"},{"location":"blog/stm32/uart/#56-process-continuous-received-data","text":"Due to DMA buffer is a Ring buffer with small number of bytes, it is necessary to copy received bytes from DMA buffer to a bigger UART buffer. There are 2 indexes to mark the bytes position in DMA buffer: new_pos at the last received byte, and old_pos at last processed byte. There is one index uart_index to mark the last byte in the UART buffer. Visualization of memory copy between DMA buffer and UART buffer In DMA buffer, if the new_pos is bigger than the old_pos , it means there is no roll-over, application can copy bytes [ old_pos : new_pos ] to the UART buffer. In DMA buffer, if the new_pos is less than the old_pos , it means there is a roll-over, application can copy bytes [ old_pos : max ] and [0: new_pos ] to the UART buffer. In UART buffer, when buffer is full, it does not get any more character, only character new line \\n will reset the index to 0 To get the new_pos index, aka. number of received bytes, use the register CNDTR of the DMA instance. Read more about \u201cDMA channel x number of data register ( DMA_CNDTRx and DMA2_CNDTRx )\u201d section in the Reference Manual document. Here is the implementation example for the above solution of processing the received data: #define UART_BUFFER_MAX 64 char uart_buffer [ UART_BUFFER_MAX ] = { 0 }; size_t uart_buffer_idx = 0 ; char uart_new_string = 0 ; void UART_RX_Process ( const void * data , size_t len ) { for ( int i = 0 ; i < len ; i ++ ) { char c = (( char * ) data )[ i ]; if ( uart_buffer_idx < UART_BUFFER_MAX -2 ) { uart_buffer [ uart_buffer_idx ++ ] = c ; uart_buffer [ uart_buffer_idx ] = '\\0' ; } if ( c == '\\n' ) { uart_buffer_idx = 0 ; uart_new_string = 1 ; } } } void UART_RX_Check ( DMA_HandleTypeDef * hdma ) { static size_t old_pos = 0 ; size_t rx_pos = DMA_BUFFER_MAX - hdma -> Instance -> CNDTR ; if ( rx_pos != old_pos ) { // new data if ( rx_pos > old_pos ) { // no overflow UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos - old_pos ); } else { // overflow UART_RX_Process ( & rx_buffer [ old_pos ], DMA_BUFFER_MAX - old_pos ); if ( rx_pos > 0 ) { // run up UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos ); } } old_pos = rx_pos ; } } int main ( void ) { while ( 1 ) { if ( uart_new_string == 1 ) { uart_new_string = 0 ; if ( strncmp ( uart_buffer , \"stop\" , 4 ) == 0 ) {...} } } } This tutorial only show a method to process variale string length in a continuous byte stream. The function UART_RX_Process() should be modified to handle different streaming format. Compile and run with variable string length to find how it work. Below captured image was in a debug section to see how many IDLE interrupts are called, how received bytes are saved into the rx_buffer and to monitor the uart_buffer . Communicate with UART in DMA mode","title":"5.6. Process continuous received data"},{"location":"blog/stm32/uart-redirection/","text":"UART Redirection UART Redirection Simple uart-redirection-src.zip UART Redirection setup Disable the standard system calls implementation in syscalls.c Implement new system calls which communicate on the an UART port Enable and setup an UART port Register redirected system calls on the target UART port Use prinf and scanf for standard output and input UART Redirection system calls Some modified system calls may not properly work with standard IO functions as custom code may not cover all cases, such as for file operations. 1. UART Redirection \u2693\ufe0e 1.1. Enable UART port \u2693\ufe0e Start a new project and follow the guide in UART to enable an UART port in the Normal (polling) mode. 1.2. System calls \u2693\ufe0e When using Semihosting , the user\u2019s system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirection also needs to disable the user\u2019s system calls too. Go to the file syscalls.c and select Properties \u00bb C/C++ Build \u00bb Exclude this resources from build . Exclude systemcall.c from build 1.3. Override system calls \u2693\ufe0e Start replacing the system calls by implement necessary functions in new module uart_redirection . The header file is located in Core/Inc/uart_redirection.h which declares main functions to be replaced: uart_redirection.h #ifndef INC_UART_REDIRECTION_H_ #define INC_UART_REDIRECTION_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTION_H_ */ then implement those functions in Core/Src/uart_redirection.c . Here are some notes: Save the UART handler to a global variable to use in the internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _write() can print out as many characters as possible, and standard IO always knows the length of data _read() should return one byte as the UART is set as a character device. However, there is a reason to read one byte at a time. Read to buffer from standard IO When debugging the _read function, standard IO request to read 1024 bytes, and the function should return the actual read byte. The easiest way to react to unknown input length is to read one by one character only. However, this method has overhead in processing due to recalling the read function multiple times. uart_redirection.c #include <stdio.h> #include \"uart_redirection.h\" /* a global UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; } A simple implementation A simpler implementation is to override only _read and _write function, as seen in the debugging with Serial Wire Viewer tutorial, as they are defined as weak functions and standard IO eventually call to them to at driver layer. main.c int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Receive ( & huart1 , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } 1.4. Enable redirection \u2693\ufe0e In main.c , call to the register function Set_UART_Redirection_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirection.h\" char counter = 0 ; int max = 255 ; int main ( void ) { int imax = 255 ; /*Init UART1 */ ... Set_Redirect_UART_Port ( & huart1 ); printf ( \"Set max counter: \" ); scanf ( \"%d\" , & imax ); max = ( unsigned char ) imax ; printf ( \"Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interaction by UART Redirection Current implementation use UART Polling mode with reading / writing one byte at a time, therefore, it has some overhead and affect to the system performance.","title":"UART Redirection"},{"location":"blog/stm32/uart-redirection/#1-uart-redirection","text":"","title":"1. UART Redirection"},{"location":"blog/stm32/uart-redirection/#11-enable-uart-port","text":"Start a new project and follow the guide in UART to enable an UART port in the Normal (polling) mode.","title":"1.1. Enable UART port"},{"location":"blog/stm32/uart-redirection/#12-system-calls","text":"When using Semihosting , the user\u2019s system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirection also needs to disable the user\u2019s system calls too. Go to the file syscalls.c and select Properties \u00bb C/C++ Build \u00bb Exclude this resources from build . Exclude systemcall.c from build","title":"1.2. System calls"},{"location":"blog/stm32/uart-redirection/#13-override-system-calls","text":"Start replacing the system calls by implement necessary functions in new module uart_redirection . The header file is located in Core/Inc/uart_redirection.h which declares main functions to be replaced: uart_redirection.h #ifndef INC_UART_REDIRECTION_H_ #define INC_UART_REDIRECTION_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTION_H_ */ then implement those functions in Core/Src/uart_redirection.c . Here are some notes: Save the UART handler to a global variable to use in the internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _write() can print out as many characters as possible, and standard IO always knows the length of data _read() should return one byte as the UART is set as a character device. However, there is a reason to read one byte at a time. Read to buffer from standard IO When debugging the _read function, standard IO request to read 1024 bytes, and the function should return the actual read byte. The easiest way to react to unknown input length is to read one by one character only. However, this method has overhead in processing due to recalling the read function multiple times. uart_redirection.c #include <stdio.h> #include \"uart_redirection.h\" /* a global UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; } A simple implementation A simpler implementation is to override only _read and _write function, as seen in the debugging with Serial Wire Viewer tutorial, as they are defined as weak functions and standard IO eventually call to them to at driver layer. main.c int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Receive ( & huart1 , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; }","title":"1.3. Override system calls"},{"location":"blog/stm32/uart-redirection/#14-enable-redirection","text":"In main.c , call to the register function Set_UART_Redirection_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirection.h\" char counter = 0 ; int max = 255 ; int main ( void ) { int imax = 255 ; /*Init UART1 */ ... Set_Redirect_UART_Port ( & huart1 ); printf ( \"Set max counter: \" ); scanf ( \"%d\" , & imax ); max = ( unsigned char ) imax ; printf ( \"Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interaction by UART Redirection Current implementation use UART Polling mode with reading / writing one byte at a time, therefore, it has some overhead and affect to the system performance.","title":"1.4. Enable redirection"},{"location":"projects/","text":"I have published some of my projects on my github at vuquangtrong . If you are interested, feel free to ask me for more details. Any feedback or comment is welcome. STM32 Tutorials I made this series of tutorials for one of my training courses in my company, then I\u2019d like to share it here to help others who also start learning about ARM Cortex-M MCUs. MkDocs Material Blog theme Based on the Material for MkDocs theme, I added some modifications to restyle my site to make it look like a blog. As shown here, I added the homepage, tags and a tag cloud, featured posts. It also enables markdown extensions to help writing an blog post faster. Simplify Pelican Theme I used Pelican static site generator before I moved to MkDocs. At that time, I made a theme for this blog using Bootstrap and Jinja template. Pelican, same as MkDocs, is based on Python. VAcamera This is a small project that uses Accord framework and FFmpeg engine to record video streams from 2 cameras and write combined videos with some overlay text to mp4 files. Because the application runs in a very low performance machine, I\u2019ve had to add some optimizations to operate on the image buffer. Tiva C TM4C123G LaunchPad I practiced on ARM Cortext-M4F which was the first ARM core I learnt. That repo contains my self-learnt projects, including Bring Up, Sensors, LCD, BootLoader and Firmware Update labs. SMS WebHub This project uses a mobile phone to process commands from a website on the internet (e.g. hosted on a VPS) via websocket, include sending SMS, checking Balance, calling a number, forwarding messages. Other Proof of Concept (PoC) projects This repo has prototypes for freelance projects I have done. As their source code are not allowed to be published by contracts, I just show some demonstrations with some features some how related to the projects. Show ToC sidebar \u2693\ufe0e .md-nav.md-nav--secondary { display: none; }","title":"Projects"},{"location":"projects/#show-toc-sidebar","text":".md-nav.md-nav--secondary { display: none; }","title":"Show ToC sidebar"},{"location":"tags/","text":"Tags \u2693\ufe0e","title":"Tags"},{"location":"tags/#tags","text":"","title":"Tags"}]}